statement,QCode,SolutionID,Language,Solutions
"
All submissions for this problem are available.Alice and Johnny are playing a simple guessing game. Johnny picks an arbitrary positive integer n (1<=n<=109) and gives Alice exactly k hints about the value of n. It is Alice's task to guess n, based on the received hints. 

Alice often has a serious problem guessing the value of n, and she's beginning to suspect that Johnny occasionally cheats, that is, gives her incorrect hints. 
After the last game, they had the following little conversation:


[Alice] Johnny, you keep cheating!
[Johnny] Indeed? You cannot prove it.
[Alice] Oh yes I can. In fact, I can tell you with the utmost certainty that in the last game you lied to me at least *** times.



So, how many times at least did Johnny lie to Alice? Try to determine this, knowing only the hints Johnny gave to Alice.

Input
The first line of input contains t, the number of test cases (about 20). Exactly t test cases follow. 

Each test case starts with a line containing a single integer k, denoting the number of hints given by Johnny (1<=k<=100000). Each of the next k lines contains exactly one hint. The i-th hint is of the form:

 operator li logical_value

where operator denotes one of the symbols < , > , or =; li is an integer (1<=li<=109), while logical_value is one of the words: Yes or No. The hint is considered correct if logical_value is the correct reply to the question: ""Does the relation: n operator li hold?"", and is considered to be false (a lie) otherwise.

Output
For each test case output a line containing a single integer, equal to the minimal possible number of Johnny's lies during the game.

Example

Input:
3
2
< 100 No
> 100 No
3
< 2 Yes
> 4 Yes
= 3 No
6
< 2 Yes
> 1 Yes
= 1 Yes
= 1 Yes
> 1 Yes
= 1 Yes

Output:
0
1
2

Explanation: for the respective test cases, the number picked by Johnny could have been e.g. n=100, n=5, and n=1. ",A3,S3239948,PYTH,"
    import re
    import pdb
    
    def increase_by_one(start_index, end_index, count):
        for i in range(start_index, end_index):
            count[i] += 1
        return count
    
    def count_lies(result):
        for key in result:
            count = result[key]
    
    if __name__ == '__main__':
        MAX_K = 10
    
        no_of_inputs = int(raw_input())
    
        regex = ur""\A(<|>|=)\s(\d*)\s(No|Yes)\Z""
    
    
        for i in range(0, no_of_inputs):
            no_of_lies = [0] * no_of_inputs
            count = [0] * MAX_K
    
            no_of_guesses = int(raw_input())
            guesses = [0] * no_of_guesses
    
            for j in range(0, no_of_guesses):
                temp = raw_input().split(' ')
                temp[1] = int(temp[1])
    
                if (temp[0] == '<' and temp[2] == 'Yes'):
                    count = increase_by_one(0, temp[1] - 1, count)
                elif (temp[0] == '>' and temp[2] == 'No'):
                    count = increase_by_one(0, temp[1], count)
                elif (temp[0] == '<' and temp[2] == 'No'):
                    count = increase_by_one(temp[1] - 1, MAX_K, count)
                elif (temp[0] == '>' and temp[2] == 'Yes'):
                    count = increase_by_one(temp[1], MAX_K, count)
                elif(temp[0] == '=' and temp[2] == 'Yes'):
                    count = increase_by_one(temp[1] - 1, temp[1], count)
                else: # = 6 No
                    count = increase_by_one(0, temp[1] - 1, count)
                    count = increase_by_one(temp[1], MAX_K, count)
    
                print count
            no_of_lies[i] = no_of_guesses - max(count)
    
        # print result out
        print '\n'.join(str(p) for p in no_of_lies)
    

"
"
All submissions for this problem are available.

Johnny was asked by his math teacher to compute nn (n to the power of n, where n is an integer), and has to read his answer out loud. This is a bit of a tiring task, since the result is probably an extremely large number, and would certainly keep Johnny occupied for a while if he were to do it honestly. But Johnny knows that the teacher will certainly get bored when listening to his answer, and will sleep through most of it! So, Johnny feels he will get away with reading only the first k digits of the result before the teacher falls asleep, and then the last k digits when the teacher wakes up.

Write a program to help Johnny to compute the digits he will need to read out.
Input
The first line contains t, the number of test cases (about 30000). Then t test cases follow.
Each test case consists of one line containing two numbers n and k (1 ≤ n ≤ 109, 1 ≤ k ≤ 9). It is guaranteed that k is not more than the number of digits of nn.
Output
For each test case, print out one line containing two numbers, separated by a space, which are the first and the last k digits of nn.
Example

Input
2
4 2
9 3

Output
25 56
387 489
 ",A4,S11878138,PYTH,"
    import sys
    t = int(raw_input())
    i = 0
    while i < t:
        n,k = map(int, sys.stdin.readline().split())
        mod =  10**18
        while( pow(n,n,mod) != pow(n,n,mod/10)):
            mod = mod /10
        #print mod*10
        print str(pow(n,n,mod))[:k] ,str(pow(n,n,mod))[-k:]       
            
        i += 1
    

"
"
All submissions for this problem are available.
This problem was part of the CodeChef April Challenge.  All user submissions for this contest problem are publicly available here.
Your grandfather is known in the family for his unconventional sense of humour. Since he made his fortune on the network of
pizza parloursa), he has been giving expensive gifts to the members of the family every Christmas. Receiving the gift,
however, always involves solving a more or less fancy mathematical puzzle.
This year, your gift was locked in a safe, self-made by your grandfather. The safe was secured with a two digit code: in order to open it
you had to provide the correct integer number from the range [0,99]. A bit disgruntled that this year's puzzle would apparently be solved with the force (and not even too brute), you were just about to start examining the numbers, when you heard grandfather's voice - ""Beware, kid! After two unsuccessful attempts the content will be annihilated!"" ""Then how am I supposed to solve this, Grandpa?"" - you asked. ""Go and have a better look at the package"" - grandfather replied.
Indeed, at the bottom of the package you found a city map on which were indicated all the pizza parlours belonging to your grandfather, as well as a long sheet of paper with a sequence of positive integers. After analysing the data for a while you realized that the number of integer values is equal to the number of pizza restaurants... Recognizing that you still have too little input, you went to ask grandfather for further guidance.
""Ah, all right, I'll solve the riddle for you"" - grandfather relented. ""For each pizza parlour you have to draw such an axis-aligned square that it is centered at the restaurant and half of the length of its side is equal to the corresponding value from the sheet. Then you have to count all the streets on the map which intersect with the square, and write down the result of calculations. The result for the last pizza parlour will be your magic number.""
You were a bit surprised that grandfather ordered you to draw squares and count streets for all the restaurants (and there were many), since the code would only depend on the last one. Nonetheless you willingly took on the job, drew the square for the last pizza parlour, counted the streets and entered the number. Unfortunately the safe didn't open.
You rushed to grandfather and told him about the first failed attempt. ""Oh dear, did I forget to mention?"" - the old man was slightly taken aback. ""For each restaurant but the first one, you have to modify both its coordinates by bit-xor'ing them with the result of calculations for the directly preceding restaurant, before drawing the square!"". Will you be able to claim the gift now? You have only one attempt left!
Input

The first line of input contains two integers n and m (0 ≤ n ≤ 5000, 1 ≤ m ≤ 50000), the number of streets in the capital city and the number of pizza parlours, respectively. The following n lines contain four integers x1, y1, x2 and y2, each (0 ≤ x1, y1, x2, y2 ≤ 1000<). Each of these lines defines the location of one of the streets, with (x1,y1) representing one of the endpoints and (x2,y2) the other one. The streets can be assumed to be straight line segments. Eventually there are m lines with three integers x, y and r each (0 ≤ x, y ≤ 1000, 1 ≤ r ≤ 20). Each of these lines defines x and y coordinates of one of the pizza parlours and the corresponding number from the sheet attached to your gift, respectively.
You may find it useful to know that:

A street can have identical endpointsb).
Any two distinct streets have at most one common point.
When counting intersecting streets, you should assume that the boundary of the square belongs to the square.
The configuration of the streets guarantees that any square satisfying 0 ≤ x, y ≤ 1000, 1 ≤ r ≤ 20 will contain at most 99 intersecting streets.
Your grandfather is 78 and claims that Fortran is the best language for solving his Christmas puzzles.

Output
The output should contain a single integer value - the code that opens the safe.
Example

Input:
5 2
2 2 4 6
2 2 7 4
4 6 7 4
7 4 10 3
7 4 10 5
10 4 2
0 0 1

Output:
2
Notes
a) This should not surprise anyone. As the IT sector is extremely well-developed in Byteland, pizza network owners are among the richest people there.
b) For some inscrutable reasons such streets are called squares. Not to be mixed up with the squares you draw!
",A7,S150528,PYTH,"
    #!/usr/bin/python
    
    # first take the first point
    # do while there are still nodes left
    # 	create a square
    # 	find which lines intersect with the square
    #	if there is a next point
    #	 	xor this value with the co-ordinates of next point and continue
    #	else
    #		output this value
    line = raw_input()
    t = line.split()
    num_street = int(t[0])
    num_pizza = int(t[1])
    x0 = []
    x1 = []
    x2 = []
    y0 = []
    y1 = []
    y2 = []
    side = []
    for i in range(num_street):
    	line = raw_input()
    	t = line.split()
    	x1 += [int(t[0])]
    	y1 += [int(t[1])]
    	x2 += [int(t[2])]
    	y2 += [int(t[3])]
    for i in range(num_pizza):
    	line = raw_input()
    	t = line.split()
    	x0 += [int(t[0])]
    	y0 += [int(t[1])]
    	side += [int(t[2])]
    
    result = 0
    for i in range(num_pizza):
    	x0[i] ^= result
    	y0[i] ^= result
    	result = 0
    	for j in range(num_street):
    		if((x1[j] < x0[i]-side[i]) and (x2[j] < x0[i]-side[i])):
    			continue
    		elif((y1[j] < y0[i]-side[i]) and (y2[j] < y0[i]-side[i])):
    			continue
    		elif((x1[j] > x0[i]+side[i]) and (x2[j] > x0[i]+side[i])):
    			continue
    		elif((y1[j] > y0[i]+side[i]) and (y2[j] > y0[i]+side[i])):
    			continue
    		if(((x1[j] <= x0[i]+side[i]) and (x1[j] >= x0[i]-side[i])) and ((y1[j] <= y0[i]+side[i]) and (y1[j] >= y0[i]-side[i])) or ((x2[j] <= x0[i]+side[i]) and (x2[j] >= x0[i]-side[i])) and ((y2[j] <= y0[i]+side[i]) and (y2[j] >= y0[i]-side[i]))):
    			result += 1
    		else:
    			m = (x2[j]-x1[j])/(float(y2[j]-y1[j]))
    			y3 = y0[i]+side[i]
    			x3 = x2[j] - (m*(y2[j]-y3))
    			if((x3 <= x0[i]+side[i]) or (x3>= x0[i]-side[i])):
    				result += 1
    				continue
    			y3 = y0[i]-side[i]
    			x3 = x2[j] - (m*(y2[j]-y3))
    			if((x3 <= x0[i]+side[i]) or (x3>= x0[i]-side[i])):
                                    result += 1
                                    continue
    			x3 = x0[i] + side[i]
    			y3 = y2[j] - (x2[j]-x3)/m
    			if((y3 <= y0[i]+side[i]) or (y3 >= y0[i]-side[i])):
    				result += 1
    				continue
    			x3 = x0[i] - side[i]
                            y3 = y2[j] - (x2[j]-x3)/m
                            if((y3 <= y0[i]+side[i]) or (y3 >= y0[i]-side[i])):
                                    result += 1
                                    continue
    print result
    

"
"
All submissions for this problem are available.
Byteland is a strange country, with many cities, but with a poorly developed road network (in fact, there is exactly one route from each city to any other city, possibly leading through other cities). Until recently, the cities of Byteland were independently governed by proud Mayors, who chose not to integrate too tightly with their neighbours. However, recent opinion polls among Bytelandian computer programmers have shown a number of disturbing trends, including a sudden drop in pizza consumption.
Since this had never before happened in Byteland and seemed quite inexplicable, the Mayors sought guidance of the High Council of Wise Men of Byteland. After a long period of deliberation, the Council ruled that the situation was very serious indeed: the economy was in for a long-term depression! Moreover, they claimed that tighter integration was the only way for the Bytelandian cities to survive. Whether they like it or not, the Mayors must now find a way to unite their cities as quickly as possible. However, this is not as easy as it sounds, as there are a number of important constraints which need to be fulfilled:

Initially, each city is an independent State. The process of integration is divided into steps.
At each step, due to the limited number of diplomatic envoys available, a State can only be involved in a unification process with at most one other state. At each step two States can unite to form a new State, but only if there exists a road directly connecting some two cities of the uniting States.
The unification process is considered to be complete when all the cities belong to the same, global State.


The Mayors have asked you to arrange a schedule for the diplomatic talks, so that unification can be completed in as few steps as possible. Can you handle this delicate task?a)
Input
The first line contains t, the number of test cases (less than 1000). The descriptions of t test cases follow.
 Each test case contains the description of the cities of Byteland, given in two lines. The first line contains a single integer k, representing the number of cities in Byteland (2 <= k <= 600); we assume that the cities are numbered 0,...,k-1. The second line contains exactly k-1 integers, and the i-th integer having a value of p represents a road connecting cities having numbers i+1 and p in Byteland.
Output
For each test case, output a separate line containing one number, equal to the minimum number
of steps required to perform the unification.
Example

Input:
3
4
0 1 2
8
0 1 2 0 0 3 3
9
0 1 1 1 1 0 2 2

Output:
2
4
5

a) Some conspiracy theorists claim that this task has in fact nothing to do with unification, and that it was proposed by pizza parlour lobbyists simply to boost their direct revenue at your expense. But don't worry, in any case, you are helping Byteland out of depression!
",A8,S43278,PYTH,"
    import sys
    
    a = sys.stdin.readlines()
    
    t = int(a[0])
    
    for i in range(0, t):
        # k number of initial cities
        # p connections between them
        [k, p] = a[2*i+1:2*i+3]
        p = p.split(' ')
    
        c = [0] * int(k)
    
        # get the most shared city + 1
        for j in range(0, len(p)):
            p[j] = int(p[j])
        p.sort()
        for j in range(0, len(p)):
            c[j] = p.count(j)
    
        print max(c)+1
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese , Russian and Vietnamese as well.
Akhil has many balls of white and black colors. One day, he was playing with them. During the play, he arranged the balls into two rows both consisting of N number of balls. These two rows of balls are given to you in the form of strings X, Y. Both these string consist of 'W' and 'B', where 'W' denotes a white colored ball and 'B' a black colored.

Other than these two rows of balls, Akhil has an infinite supply of extra balls of each color. he wants to create another row of N balls, Z in such a way that the sum of hamming distance between X and Z, and hamming distance between Y and Z is maximized.
Hamming Distance between two strings X and Y is defined as the number of positions where the color of balls in row X differs from the row Y ball at that position. e.g. hamming distance between ""WBB"", ""BWB"" is 2, as at position 1 and 2, corresponding colors in the two strings differ..

As there can be multiple such arrangements of row Z, Akhil wants you to find the lexicographically smallest arrangement which will maximize the above value. 

Input

The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows:
First line of each test case will contain a string X denoting the arrangement of balls in first row
Second line will contain the string Y denoting the arrangement of balls in second row.

Output

For each test case, output a single line containing the string of length N denoting the arrangement of colors of the balls belonging to row Z.

Constraints

1 ≤ T ≤ 3

Subtasks
Subtask #1 (10 points) : 1 ≤ N ≤ 16
Subtask #2 (20 points) : 1 ≤ N ≤ 103
Subtask #3 (70 points) : 1 ≤ N ≤ 105
Example
Input:
1
WBWB
WBBB

Output:
BWBW

Explanation
Example case 1. As we know, Hamming Distance(WBWB, BWBW) + Hamming Distance(WBBB, BWBW) = 4 + 3 = 7.
You can try any other value for string Z, it will never exceed 6.  ",ACBALL,S10211766,PYTH,"
    t = int(raw_input())
    
    while t > 0:
        x = raw_input()
        y = raw_input()
        z = ''
        for i in range(len(x)):
            if x[i] == y[i] == 'B':
                z += 'W'
            elif x[i] == y[i] == 'W':
                z += 'B'
            else:
                z += 'B'
        print z
    

"
"
All submissions for this problem are available.Read problems statements in Mandarin Chinese  and Russian.
You are given a one dimensional integer array A of length N. You need to maintain the array under Q queries of the following four types. Assume 1-based indexing and M = 109 + 7.
Query 1 : 1 x y v  This implies adding v to array A to all the indices from x to y, i.e., 
for (i = x; i <= y; i++)	
	Ai += v;
	Ai %= M; 

 
Query 2 : 2 x y v  This implies multiplying the scalar v with the array A for all the indices from x to y, i.e., 
for (i = x; i <= y; i++)	
        Ai *= v
        Ai %= M

 
Query 3 : 3 x y v  This implies initializing the array A at all the indices from x to y with the value v, i.e., 
for (i = x; i <= y; i++)	
	Ai = v 

 
Query 4 : 4 x y This is a report query which needs to find the sum of the values in A from x to y, i.e., 
sum = 0;
for (i = x; i <= y; i++)
	sum += Ai
	sum %= M
Output sum.

 
Note: a%b represents the remainder of a when divided by b.
Input

First line contains two space separated integers N, Q.
Next line contains N space separated integers denoting the array A.
Next Q lines contain queries which can be of any of the above four types.

Output

For each query of type 4, output a single integer corresponding to the answer in a single line.

Constraints

1 ≤ N ≤ 105
1 ≤ Q ≤ 105
1 ≤ Initial value of Ai ≤ 109
1 ≤ v ≤ 109

Subtasks

 Subtask 1: Queries are of type 1, 3 and 4. Points - 5.
 Subtask 2: Queries are of type 2, 3 and 4. Points - 5.
 Subtask 3: Queries are of type 1, 2 and 4. Points - 30.
 Subtask 4: All the queries are present. Points - 60.

Example
Input:
4 4
1 2 3 4
4 1 4
1 1 3 10
2 2 4 2
4 1 4

Output:
10
69


Explanation
Initial A : [1, 2, 3, 4] Result of first query : 1 + 2 + 3 + 4 = 10 A after second query: [ 11, 12, 13, 4] A after third query : [ 11, 24, 26, 8] Result of fourth query : 11 + 24 + 26 + 8 = 69 ",ADDMUL,S7476207,PYTH,"
    n,q = map(int,raw_input().split("" ""))
    a = map(int,raw_input().split("" ""))
    M = 1000000007
    a.insert(0,0)
    def query1(x,y,v):
    	for j in range(x,y):
    		a[j] += v
    		#a[j] = divmod(a[j],M)[1]
    def query2(x,y,v):
    	for j in range(x,y):
    		a[j] *= v
    		#a[j] = divmod(a[j],M)[1]
    def query3(x,y,v):
    	for j in range(x,y):
    		a[j] = v
    def query4(x,y):
    	sumar = 0
    	for j in range(x,y):
    		sumar += a[j]
    	print divmod(sumar,M)[1]
    for i in range(q):
    	query = raw_input().split("" "")
    	if(query[0]==""1""):
    		query1(int(query[1]),int(query[2])+1,int(query[3]))
    	elif(query[0]==""2""):
    		query2(int(query[1]),int(query[2])+1,int(query[3]))
    	elif(query[0]==""3""):
    		query3(int(query[1]),int(query[2])+1,int(query[3]))
    	else:
    		query4(int(query[1]),int(query[2])+1)
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese  and Russian.
Aditi recently discovered a new magic trick. First, she gives you an integer N and asks you to think an integer between 1 and N. Then she gives you a bundle of cards each having a sorted list (in ascending order) of some distinct integers written on it. The integers in all the lists are between 1 and N. Note that the same integer may appear in more than one card. Now, she shows you these cards one by one and asks whether the number you thought is written on the card or not. After that, she immediately tells you the integer you had thought of.
Seeing you thoroughly puzzled, she explains that she can apply the trick so fast because she is just adding the first integer written on the cards that contain the integer you had thought of, and then gives the sum as the answer. She calls a bundle interesting if when the bundle is lexicographically sorted, no two consecutive cards have any number in common. Now she challenges you to find out the minimum number of cards she will need for making an interesting bundle such that the magic trick will work every time.
Input

The first line of the input contains an integer T denoting the number of test cases.
Each test case contains a line with a single integer N.

Output

For each test case, output a line containing a single integer denoting the minimum number of cards required.

Constraints

1 ≤ T ≤ 105
1 ≤ N ≤ 1018

Sub tasks

Subtask #1: 1 ≤ T ≤ 10, 1 ≤ N ≤ 10 (5 points)
Subtask #2: 1 ≤ T ≤ 100, 1 ≤ N ≤ 1000 (10 points)
Subtask #3: Original Constraints (85 points)

Example
Input:
2
1
4

Output:
1
3
Explanation

In example 1, only 1 card containing {1} will work.
In example 2, make 3 cards containing {1,4}, {2} and {3,4}.

Assume you thought of 1, then you will select the 1st card {1,4}, then she will correctly figure out the integer you thought being 1.
Assume you thought of 2, then you will select the 2nd card {2}, then she will correctly figure out the integer you thought being 2.
Assume you thought of 3, then you will select the 3rd card {3,4}, then she will correctly figure out the integer you thought being 3.
Assume you thought of 4, then you will select 1st card {1,4} and 3rd card {3,4}, then she will calculate the sum of the first integers of the two card 1 + 3 = 4, and she will answer it.

Thus her trick will work well in every case. And we can check it easily that the cards are sorted in lexicographical order and two consecutive cards have no common integers.
 ",ADMAG,S11169224,PYTH,"
    from math import *
    def adityAndMagic(n):
        a=log(n,2)
        return int(a)+1
            
    t=int(raw_input())
    for i in range(t):
        k=int(raw_input())
        print adityAndMagic(k)
        
    

"
"

                    function formatTime(ts) {
                      now = new Date(ts);

                      localtime = new Date();
                      hour = now.getHours();
                      min = now.getMinutes();
                      sec = now.getSeconds();

                      if (min <= 9) {
                        min = ""0"" + min;
                      }
                      if (sec <= 9) {
                        sec = ""0"" + sec;
                      }
                      if (hour > 12) {
                        hour = hour - 12;
                        add = "" PM"";
                      } else {
                        hour = hour;
                        add = "" AM"";
                      }
                      if (hour == 12) {
                        add = "" PM"";
                      }
                      if (hour == 00) {
                        hour = ""12"";
                      }

                      $('#server-time').html(((hour<=9) ? ""0"" + hour : hour) + "":"" + min + "":"" + sec + add);

                      nextSec = (now.getTime() + 1000);

                      setTimeout(""formatTime(""+nextSec+"")"", 1000);
                    }
                    function getDtTimeZone()
                    {
                      var rightNow = new Date();
                      var toDay = new Date(rightNow.getFullYear(), 0, 1, 0, 0, 0, 0);
                      var temp = toDay.toGMTString();
                      var date2 = new Date(temp.substring(0, temp.lastIndexOf("" "") -1));
                      var stdTime = (toDay - date2) / (1000 * 60 * 60);
                      return stdTime;
                    }
/*var d=new Date();
$.ajax({
url: '/umtza',
type:'POST',
data: 'umtza='+d.toString(),
});
*/

CodeChef is a non-commercial competitive programming community




About CodeChef
About Directi
CEO's Corner
C-Programming
Programming Languages
Contact Us


© 2009 Directi Group.  All Rights Reserved.  CodeChef uses SPOJ © by Sphere Research Labs
In order to report copyright violations of any kind, send in an email to copyright@codechef.com



The time now is: 

        formatTime('September 01, 2014 16:46:08');
      




    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-53602-42']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

  


    /* <![CDATA[ */
    var google_conversion_id = 1066618556;
    var google_conversion_language = ""en"";
    var google_conversion_format = ""3"";
    var google_conversion_color = ""666666"";
    var google_conversion_label = ""gbUUCPTlhAIQvJ3N_AM"";
    var google_conversion_value = 0;
    /* ]]> */
  









    /* <![CDATA[ */
    var google_conversion_id = 968176136;
    var google_conversion_language = ""en"";
    var google_conversion_format = ""3"";
    var google_conversion_color = ""ffffff"";
    var google_conversion_label = ""iDk7CPDZ7wMQiOTUzQM"";
    var google_conversion_value = 0;
    /* ]]> */
  








CodeChef - A Platform for Aspiring Programmers
CodeChef was created as a platform to help programmers make it big in the world of algorithms, computer programming and programming contests. At CodeChef we work hard to revive the geek in you by hosting a programming contest at the start of the month and another smaller programming challenge in the middle of the month. We also aim to have training sessions and discussions related to algorithms, binary search, technicalities like array size and the likes. Apart from providing a platform for programming competitions, CodeChef also has various algorithm tutorials and forum discussions to help those who are new to the world of computer programming.

Practice Section - A Place to hone your 'Computer Programming Skills'
Try your hand at one of our many practice problems and submit your solution in a language of your choice. Our programming contest judge accepts solutions in over 35+ programming languages. Preparing for coding contests were never this much fun! Receive points, and move up through the CodeChef ranks. Use our practice section to better prepare yourself for the multiple programming challenges that take place through-out the month on CodeChef. 

Compete - Monthly Programming Contests and Cook-offs
Here is where you can show off your computer programming skills. Take part in our 10 day long monthly coding contest and the shorter format Cook-off coding contest. Put yourself up for recognition and win great prizes. Our programming contests have prizes worth up to Rs.20,000 and $700lots more CodeChef goodies up for grabs. 

Discuss
Are you new to computer programming? Do you need help with algorithms? Then be a part of CodeChef's Forums and interact with all our programmers - they love helping out other programmers and sharing their ideas. Have discussions around binary search, array size, branch-and-bound, Dijkstra's algorithm, Encryption algorithm and more by visiting the CodeChef Forums and Wiki section.

CodeChef Community
As part of our Educational initiative, we give institutes the opportunity to associate with CodeChef in the form of Campus Chapters. Hosting online programming competitions is not the only feature on CodeChef. You can also host a coding contest for your institute on CodeChef, organize an algorithm event and be a guest author on our blog. 

Go For Gold
The Go for Gold Initiative was launched about a year after CodeChef was incepted, to help prepare Indian students for the ACM ICPC World Finals competition. In the run up to the ACM ICPC competition, the Go for Gold initiative uses CodeChef as a platform to train students for the ACM ICPC competition via multiple warm up contests. As an added incentive the Go for Gold initiative is also offering over Rs.8 lacs to the Indian team that beats the 29th position at the ACM ICPC world finals. Find out more about the Go for Gold and the ACM ICPC competition here.
 ",AHWORK,S10241148,PYTH,"
    def removal_count(begin, end, left, right):
    	if(a[begin][end][left][right]==-1):
    		if(begin>end):
    			a[begin][end][left][right]=0
    		elif(begin==end and left==0 and right==0):
    			if(s_list[begin]=='ab' or s_list[begin]=='ba'):
    				a[begin][end][left][right]=1
    			else:
    				a[begin][end][left][right]=0
    		else:
    			if(left!=0):
    				start=s_list[begin-1][left:]
    			else:
    				start=s_list[begin]
    			if(right!=0):
    				stop=s_list[end+1][:right]
    			else:
    				stop=s_list[end]
    			if(start[::-1]==stop):
    				a[begin][end][left][right]=removal_count(begin+1,end-1,0,0)
    			elif(start[0]==stop[-1:]):
    				a[begin][end][left][right]=removal_count(begin+1,end-1,len(s_list[begin])-1,len(s_list[end])-1)
    			else:
    				a[begin][end][left][right]=min(removal_count(begin,end-1,0,0),removal_count(begin+1,end,0,0))+1
    	return a[begin][end][left][right]
    
    
    s = raw_input()
    s_list = s.split()
    a = []
    for i in range(len(s_list)):
    	a.append([])
    	for j in range(len(s_list)):
    		a[i].append([])
    		for k in range(2):
    			a[i][j].append([])
    			for l in range(2):
    				a[i][j][k].append(-1)
    print removal_count(0,len(s_list)-1,0,0)

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 Alexey is trying to develop a program for a very simple microcontroller. It makes readings from various sensors over time, and these readings must happen at specific regular times. Unfortunately, if two of these readings occur at the same time, the microcontroller freezes and must be reset. 

There are N different sensors that read data on a regular basis. For each i from 1 to N, the reading from sensor i will occur every Ai milliseconds with the first reading occurring exactly Ai milliseconds after the microcontroller is powered up. Each reading takes precisely one millisecond on Alexey's microcontroller.


Alexey wants to know when the microcontroller will freeze after he turns it on.

Input
The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
The first line contains single integer N denoting the number of sensors.

The second line contains N space-separated integers A1, A2, ..., AN denoting frequency of measurements. Namely, sensor i will be read every Ai milliseconds with the first reading occurring Ai milliseconds after the microcontroller is first turned on.

 
Output
For each test case, output a single line containing the number of milliseconds until the microcontroller freezes.
 
Constraints

1 ≤ T ≤ 10
2 ≤ N ≤ 500
1 ≤ Ai ≤ 109

 
Subtasks
Subtask #1 (10 points) 1  ≤ T ≤ 10, 2 ≤ N ≤ 9, 1 ≤ Ai ≤ 500
Subtask #2 (20 points) 1  ≤ T ≤ 10, 2 ≤ N ≤ 500, 1 ≤ Ai ≤  1000
Subtask #3 (70 points)  original constraints
 
Example
Input:
3
3
2 3 5
4
1 8 7 11
4
4 4 5 6

Output:
6
7
4

 
Explanation
Case 1: in 6 milliseconds, the third reading will be attempted from the 1st sensor and the second reading will be attempted from the 2nd sensor.
Case 2: in 7 milliseconds the seventh reading will be attempted from the 1st sensor and the first reading will be attempted from the 3rd sensor.
Case 3: in 4 milliseconds, the first readings from the first two sensors will be attempted. ",ALEXTASK,S12121952,PYTH,"
    t = raw_input()
    for i in range(0,int(t)):
      n = raw_input()
      numbers = map(int, raw_input().split())
      numbers.sort()
      if numbers[0]==numbers[1]:
        print numbers[0]
      else:
        multi=numbers[0]*numbers[1]
        print(multi)

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.

As a cryptologist, after working on numerous cryptographic protocols, Alice is now retired and living happily in Wonderland. However Alice is still obsessed with security, she even invented a new way to set passwords. Given a board of n rows and n columns with unitary size cells, Alice creates a password by drawing exactly n+1 lines with vertices of the integer points on the perimeter of the board. 



One day Alice forgot her CodeChef password! She knew that she had set her password in the secure way. She remembers that no two lines were parallel, and that every cell of the board was cut by at least one of the lines. A cell is cut by a line when there exists a point strictly inside of the cell that belongs to the line.


Please help Alice finding one password satisfying the information that she remembered.

Input
The first line of the input contains one integer T the number of test cases.
Each test case is described by a line containing an integer  n representing the size of the board.
Output
For each test case print n + 1 lines each of them containing four integers x1 y1 x2 y2 with x1 ≠ x2 and y1 ≠ y2, representing a line that goes from (x1,y1) to (x2,y2). 
If there are multiple passwords that satisfies the information, print any of them.
Constraints

1 ≤ T ≤ 10 
1 ≤ n ≤ 103 

Example
Input:
1
3

Output:
0 0 3 2
3 0 0 2
0 1 2 3
0 3 3 2

Explanation
One of the possible passwords is depicted in the above figure.
Every cell is cut by at least one line, for example the green cell is cut by the blue and purple lines, but not by the yellow one. The integer points on the perimeter of the board are drawn as small black circles. ",ALICE,S11253155,PYTH,"
    import sys
    
    t = sys.stdin.readline()
    
    for inn in range(int(t)):
    
        n = int(sys.stdin.readline())
        if n != 1:
            flag = 0
            for i in range(n):
                if flag == 0:
                    print ""0 "" + str(i) + "" "" + str(n) + "" "" + str(i+1)
                    flag = 1
                elif flag == 1:
                    print str(n) + "" "" + str(i) + "" 0 "" + str(i+1)
                    flag = 0
            print ""0 0 "" + str(n) + "" "" + str(n)
        else :
            print ""0 0 1 1""
            print ""1 0 0 1""
            
            
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
Not everyone probably knows that Chef has younder brother Jeff. Currently Jeff learns to read.
He knows some subset of the letter of Latin alphabet. In order to help Jeff to study, Chef gave him a book with the text consisting of N words. Jeff can read a word iff it consists only of the letters he knows.
Now Chef is curious about which words his brother will be able to read, and which are not. Please help him!
Input
The first line of the input contains a lowercase Latin letter string S, consisting of the letters Jeff can read. Every letter will appear in S no more than once.
The second line of the input contains an integer N denoting the number of words in the book.
Each of the following N lines contains a single lowecase Latin letter string Wi, denoting the ith word in the book.
Output
For each of the words, output ""Yes"" (without quotes) in case Jeff can read it, and ""No"" (without quotes) otherwise.
Constraints

1 ≤ |S| ≤ 26
1 ≤ N ≤ 1000
1 ≤ |Wi| ≤ 12
Each letter will appear in S no more than once.
S, Wi consist only of lowercase Latin letters.

Subtasks

Subtask #1 (31 point): |S| = 1, i.e. Jeff knows only one letter.
Subtask #2 (69 point)	: no additional constraints

Example
Input:
act
2
cat
dog

Output:
Yes
No

Explanation
The first word can be read.
The second word contains the letters d, o and g that aren't known by Jeff. ",ALPHABET,S11268333,PYTH,"
    x=raw_input()
    
    l=raw_input()
    q=0
    for i in range(int(l)):
        z=raw_input()
        for c in z:
            if c  not in x:
                print 'No'
                q=1
                break
        if q==0:
            print 'Yes'
        
            
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.

There's an array A consisting of N non-zero integers A1..N. A subarray of A is called alternating if any two adjacent elements in it have different signs (i.e. one of them should be negative and the other should be positive).

For each x from 1 to N, compute the length of the longest alternating subarray that starts at x - that is, a subarray Ax..y for the maximum possible y ≥ x. The length of such a subarray is y-x+1.

Input

The first line of the input contains an integer T - the number of test cases.
The first line of each test case contains N.
The following line contains N space-separated integers A1..N.

Output
For each test case, output one line with N space-separated integers - the lengths of the longest alternating subarray starting at x, for each x from 1 to N.
Constraints

1 ≤ T ≤ 10
1 ≤ N ≤ 105
-109 ≤ Ai ≤ 109

Example
Input:
3
4
1 2 3 4
4
1 -5 1 -5
6
-5 -1 -1 2 -2 -3

Output:
1 1 1 1
4 3 2 1
1 1 3 2 1 1
Explanation
Example case 1. No two elements have different signs, so any alternating subarray may only consist of a single number.
Example case 2. Every subarray is alternating.
Example case 3. The only alternating subarray of length 3 is A3..5. ",ALTARAY,S10001454,PYTH,"
    test_cases = input()
    for test_case in range(test_cases):
        n = input()
        ints = map(int, raw_input().split())
        final_counter = ''
        arr = [1]*n
        for i in range(n - 2, -1, -1):
            curr = ints[i]
            next = ints[i+1]
            if (curr > 0 and next > 0) or (curr < 0 and next < 0):
                continue
            else:
                arr[i] = arr[i]+arr[i+1]
        print ' '.join(str(a) for a in arr)

"
"
All submissions for this problem are available. Read problems statements in Russian here
The Head Chef has been playing with Fibonacci numbers for long . He has learnt several tricks related to Fibonacci numbers . Now he wants to test his chefs in the skills . 
A fibonacci number is defined by the recurrence :
f(n) = f(n-1) + f(n-2) for n > 2 and f(1) = 0 and f(2) = 1 .  
Given a number  A   , determine if it is a fibonacci number.
Input

The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
The only line of each test case contains a single integer  A  denoting the number to be checked .

Output

For each test case, output a single line containing ""YES"" if the given number is a fibonacci number , otherwise output a single line containing ""NO"" . 

Constraints

1 ≤ T ≤ 1000
1 ≤ number of digits in A  ≤ 1000
  The sum of number of digits in A in all test cases   <= 10000.  

Example
Input:
3
3
4
5

Output:
YES
NO
YES
Explanation
Example case 1. The first few fibonacci numbers are 0 , 1 , 1 , 2 , 3 ,5 , 8 , 13 and so on and the series is increasing . Only 3 and 5 appear in this series while 4 does not appear in the series .  ",AMIFIB,S10038844,PYTH,"
    #! /usr/bin/env python
    # -*- coding: utf-8 -*-
    
    def fib_int(n):
        return (( 4 << n*(3+n))/((4 << (2*n)) - (2 << n) - 1))%(2 << n)
    
    def evaluate(fromd, to):
        if length <= 3:
            fromd = 0
            to   = 20
        first_iter_int  = fib_int(fromd)
        second_iter_int = fib_int(fromd+1)
        for i in range(fromd, to):
            tmp = second_iter_int
            second_iter_int = first_iter_int + second_iter_int
            first_iter_int = tmp
            if fib_str == str(first_iter_int):
                print ""YES""
                return
        print ""NO""
    
    num = input()
    while num:
        fib_str = raw_input()
        length  = len(fib_str)
        fromd   = int(length*4.784688995215311)-4
        to      = int(length*4.784688995215311)+4
        evaluate(fromd, to)
        num = num-1
    

"
"
All submissions for this problem are available.Kattapa, as you all know was one of the greatest warriors of his time. The kingdom of Maahishmati had never lost a battle under him (as army-chief), and the reason for that was their really powerful army, also called as Mahasena.
Kattapa was known to be a very superstitious person. He believed that a soldier is ""lucky"" if the soldier is holding an even number of weapons, and ""unlucky"" otherwise. He considered the army as ""READY FOR BATTLE"" if the count of ""lucky"" soldiers is strictly greater than the count of ""unlucky"" soldiers, and ""NOT READY"" otherwise.
Given the number of weapons each soldier is holding, your task is to determine whether the army formed by all these soldiers is ""READY FOR BATTLE"" or ""NOT READY"".
Note: You can find the definition of an even number here.
Input

The first line of input consists of a single integer N denoting the number of soldiers. The second line of input consists of N space separated integers A1, A2, ..., AN, where Ai denotes the number of weapons that the ith soldier is holding.
Output
Generate one line output saying ""READY FOR BATTLE"", if the army satisfies the conditions that Kattapa requires or ""NOT READY"" otherwise (quotes for clarity).
Constraints

1 ≤ N ≤ 100
1 ≤ Ai ≤ 100

Example 1
Input:
1
1

Output:
NOT READY

Example 2
Input:
1
2

Output:
READY FOR BATTLE

Example 3
Input:
4
11 12 13 14

Output:
NOT READY

Example 4
Input:
3
2 3 4

Output:
READY FOR BATTLE

Example 5
Input:
5
1 2 3 4 5

Output:
NOT READY

Explanation

Example 1: For the first example, N = 1 and the array A = [1]. There is only 1 soldier and he is holding 1 weapon, which is odd. The number of soldiers holding an even number of weapons = 0, and number of soldiers holding an odd number of weapons = 1. Hence, the answer is ""NOT READY"" since the number of soldiers holding an even number of weapons is not greater than the number of soldiers holding an odd number of weapons.

Example 2: For the second example, N = 1 and the array A = [2]. There is only 1 soldier and he is holding 2 weapons, which is even. The number of soldiers holding an even number of weapons = 1, and number of soldiers holding an odd number of weapons = 0. Hence, the answer is ""READY FOR BATTLE"" since the number of soldiers holding an even number of weapons is greater than the number of soldiers holding an odd number of weapons.

Example 3: For the third example, N = 4 and the array A = [11, 12, 13, 14]. The 1st soldier is holding 11 weapons (which is odd), the 2nd soldier is holding 12 weapons (which is even), the 3rd soldier is holding 13 weapons (which is odd), and the 4th soldier is holding 14 weapons (which is even). The number of soldiers holding an even number of weapons = 2, and number of soldiers holding an odd number of weapons = 2. Notice that we have an equal number of people holding even number of weapons and odd number of weapons. The answer here is ""NOT READY"" since the number of soldiers holding an even number of weapons is not strictly greater than the number of soldiers holding an odd number of weapons.

Example 4: For the fourth example, N = 3 and the array A = [2, 3, 4]. The 1st soldier is holding 2 weapons (which is even), the 2nd soldier is holding 3 weapons (which is odd), and the 3rd soldier is holding 4 weapons (which is even). The number of soldiers holding an even number of weapons = 2, and number of soldiers holding an odd number of weapons = 1. Hence, the answer is ""READY FOR BATTLE"" since the number of soldiers holding an even number of weapons is greater than the number of soldiers holding an odd number of weapons.

Example 5: For the fifth example, N = 5 and the array A = [1, 2, 3, 4, 5]. The 1st soldier is holding 1 weapon (which is odd), the 2nd soldier is holding 2 weapons (which is even), the 3rd soldier is holding 3 weapons (which is odd), the 4th soldier is holding 4 weapons (which is even), and the 5th soldier is holding 5 weapons (which is odd). The number of soldiers holding an even number of weapons = 2, and number of soldiers holding an odd number of weapons = 3. Hence, the answer is ""NOT READY"" since the number of soldiers holding an even number of weapons is not greater than the number of soldiers holding an odd number of weapons.
 ",AMR15A,S10032869,PYTH,"
    #Mahasena
    #https://www.codechef.com/problems/AMR15A
    
    input()
    n=map(int,raw_input().split())
    even=0
    odd=0
    for i in n:
    	if i%2==0:
    		even+=1
    	else:
    		odd+=1
    if even>odd:
    	print ""READY FOR BATTLE""
    else:
    	print ""NOT READY""
    

"
"
All submissions for this problem are available.Devasena was the princess of an unknown kingdom (we'll all know which one, in Baahubali 2 ;) ), and her father arranged for a Swayamvara to get her married. He gave all of them a question, and the question was so hard that nobody was able to answer it (Yes you guessed it right, both Baahubali and Bhallaladeva were not present there for the Swayamvara). We all know that Amarendra Baahubali married her later and as a consequence of so many things, she was imprisoned for 25 years. Who knows, if someone else had answered the question that day, then she would have got married to him and things could have been different. Phew! But the bad part, we wouldn't have had the story of Baahubali. :) 
Although everything is history now, recently archaeologists discovered the secret question that was asked at the Swayamvara, and you think - ""Well, it's such a simple question. I could use a computer to solve it!"". The question goes as follows: 

You are given N integers (not necessarily distinct) => A1, A2, A3, ..., AN. There are 2N possible subsets (including the empty subset). The GCD of a subset is defined as the greatest common divisor of all the integers in that subset. You need to find the product of the GCDs of all the 2N possible subsets you can construct from A. Since the answer can be large, you need to output the answer modulo 1000000007. Do you think you can solve this question?

Note: The greatest common divisor of an empty subset is 1. To know more about the definition of greatest common divisor, check here.

Input
The first line of input consists of a single integer T denoting the number of test cases. The description of T test cases follow. The first line of each test case consists of a single integer N. The second line of each test case consists of N space separated integers A1, A2, ..., AN
Output
For each test case, output an single integer on a separate line denoting the answer for that test case. Note that you need to output all the values modulo  1000000007 (109 + 7).
Constraints

1 ≤ T ≤ 30
1 ≤ N ≤ 105
1 ≤ Ai ≤ 105

Example
Input:
3
1
1
2
1 2
3
1 2 2

Output:
1
2
8

Explanation
For the first test case, N = 1, and A = [1]. There are 2 possible subsets => {}, {1} and both have a gcd of 1. Hence, the answer is 1 * 1 = 1.
For the second test case, N = 2, and A = [1, 2]. There are 4 possible subsets => {}, {1}, {2}, {1, 2}, having a gcd of 1, 1, 2 and 1 respectively. Hence, the answer is 1 * 1 * 2 * 1 = 2.
For the third test case, N = 3, and A = [1, 2, 2]. There are 8 possible subsets => {}, {1}, {2}, {2}, {1, 2}, {2, 2}, {1, 2}, {1, 2, 2}, having a gcd of 1, 1, 2, 2, 1, 2, 1, 1. Hence, the answer is 1 * 1 * 2 * 2 * 1 * 2 * 1 * 1 = 8. ",AMR15B,S11897734,PYTH,"
    import itertools
    from fractions import gcd
    mod =  1000000007
    
    def calculate(a, sub_lst, gcd_lst):
    	if len(sub_lst)  == 1:
    		sub_lst.append(1)
    	pr = gcd_lst[ a[sub_lst[0]]-1 ][ a[sub_lst[1]]-1 ]
    	for i in range(2, len(sub_lst)):
    		pr = pr * gcd_lst[ pr-1 ][ a[sub_lst[i]]-1 ] % mod
    	return pr
    
    t = input()
    for _ in range(t):
    	n = input()
    	a = map(int, raw_input().split())
    	prod = 1
    	max_a = max(a);
    	gcd_lst = [[0 for i in range(max_a)] for j in range(max_a)]
    	for i in range(max_a):
    		for j in range(i, max_a):			
    			gcd_lst[i][j] = gcd_lst[j][i] = gcd(i+1, j+1)
    		
    	for i in range(2, len(a)+1):
    		subset = list(itertools.combinations(range(len(a)), i))
    		for j in range(len(subset)):	
    			prod =  prod * calculate(a, list(subset[j]), gcd_lst) % mod
    			
    	x = reduce(lambda m,n: m*n%mod, a)
    	prod = prod * x % mod
    	print prod
    

"
"
All submissions for this problem are available.The Kalakeyas were a powerful, ferocious and cruel clan of Danavas. They were known to be really strong and they did not have any war strategy. They would just attack the enemy randomly and overpower them with sheer number of soldiers. However, we all know that Baahubali and Bhallaladeva defeated the Kalakeyas by following the Thrishul strategy, and successfully defended their kingdom Maahishmati. We also know that Baahubali was very smart, and the truth is that he predicted how the Kalakeyas would attack and  devised a counter strategy for the same, the night before the war. This is what he found:
The Kalakeyas had N forts, numbered 1 to N and Baahubali had N soldiers, numbered 1 to N. Baahubali discovered that he can permute his soldiers in any way to get a permutation of 1 to N => P1, P2, ..., PN. He would then send his soldiers to attack the forts in the following way: soldier P1 attacks fort 1, soldier P2 attacks fort 2, ..., soldier PN attacks fort N. It is easy to note that each soldier attacks exactly one fort and no two soldiers attack the same fort. Baahubali also got to know about a secret key of the Kalakeyas, which is an integer K. A soldier X can destroy a fort Y, iff abs(X - Y) >= K. For more details on the abs() function, check here.

Your task is to determine whether Baahubali's soldiers can be permuted in some way, such that all forts can be destroyed. In other words, for a permutation P1, P2, ..., PN, Baahubali's soldiers can destroy all the forts iff abs(Pi - i) >= K, for all 1 <= i <= N. If this is possible, you are also required to output the lexicographically smallest such permutation. If it is not possible, output -1.

Note: A permutation A1, A2, ..., AN is said to be lexicographically smaller than a permutation B1, B2, ..., BN, if and only if at the first i where Ai and Bi differ, Ai comes before Bi. You can refer here for a more detailed definition of lexicographic ordering.

Input
The first line of input consists of a single integer T denoting the number of test cases. Each of the following T lines contain two space separated integers N and K denoting the values mentioned in the statement above.
Output
For each test case, output a single line containing N space separated integers (which should be a permutation of [1..N], if Baahubali's soldiers can break all the forts. If it is not possible to break all the forts, output ""-1"" (quotes for clarity).
Constraints

1 ≤ T ≤ 1000
1 ≤ N ≤ 105
0 ≤ K ≤ N
The sum of N over all test cases in a single test file will not exceed 105

Example
Input:
3
2 2
3 0
3 1

Output:
-1
1 2 3
2 3 1
Explanation
For the first test case, N = 2 and K = 2. It is impossible to permute [1, 2] in any way such that abs(P[1]-1) >= 2 and abs(P[2]-2) >= 2. Hence, output is -1.
For the second test case, N = 3 and K = 0. We can just set P[i] = i, and hence the answer is 1 2 3
For the third case, the valid permutations are [2, 3, 1] and [3, 1, 2]. The answer is [2, 3, 1] since it is lexicographically smaller than [3, 1, 2]. ",AMR15C,S10136063,PYTH,"
    test = int(input())
    while (test != 0):
    	test -= 1
    	n,k = map(int,raw_input().split())
    	if (k >= n):
    		print(-1)
    	else:
    		s = """"
    		i = k + 1
    		while (i <= n):
    			s += str(i) + "" ""
    			i += 1
    		i = 1
    		while (i <= k):
    			s += str(i) + "" ""
    			i += 1
    		print(s)

"
"
All submissions for this problem are available.
Chef is playing a game on a sequence of N positive integers, say A1, A2, ... AN. The game is played as follows.

If all the numbers are equal, the game ends.
Otherwise

Select two numbers which are unequal
Subtract the smaller number from the larger number
Replace the larger number with the result from above (see the explanation section for clarity)



Chef has already figured out that the game always terminates. He also knows, for a given sequence of integers, the game will always terminate on the same value, no matter how the game is played. Chef wants you to simulate the game for him and tell him on which value will the game terminate for a given sequence of integers.
Input
The first line of the input contains an integer T, the number of test cases. Then follow the description of T test cases. The first line of each test case contains a single integer N, the length of the sequence. The second line contains N positive integers, each separated by a single space.
Output
For each test case, output a single integer - the value of all the numbers when they are equal (and the game terminates), on a line by itself.
Constraints

1 ≤ T ≤ 100
1 ≤ N ≤ 1000
1 ≤ Ai ≤ 109

Sample

Input
3
2
10 12
2
5 9
3
6 10 15

Output
2
1
1

Explanation
Test Case 1: Since there are only two numbers, the operations are forced.

{ 10, 12 } => Replace 12 with ( 12 - 10 = 2 ) => { 10, 2 }
{ 10, 2 } => Replace 10 with ( 10 - 2 = 8 ) => { 8, 2 }
{ 8, 2 } => Replace 8 with ( 8 - 2 = 6 ) => { 6, 2 }
{ 6, 2 } => Replace 6 with ( 6 - 2 = 4 ) => { 4, 2 }
{ 4, 2 } => Replace 4 with ( 4 - 2 = 2 ) => { 2, 2 }

The value of all the numbers when the game ends is 2.
Test Case 2: Since there are only two numbers, the operations are forced.

{ 5, 9 } => Replace 9 with ( 9 - 5 = 4 ) => { 5, 4 }
{ 5, 4 } => Replace 5 with ( 5 - 4 = 1 ) => { 1, 4 }
{ 1, 4 } => Replace 4 with ( 4 - 1 = 3 ) => { 1, 3 }
{ 1, 3 } => Replace 3 with ( 3 - 1 = 2 ) => { 1, 2 }
{ 1, 2 } => Replace 2 with ( 2 - 1 = 1 ) => { 1, 1 }

The value of all the numbers when the game ends is 1.
Test Case 3: One way to play the game is

{ 6, 10, 15 } => Replace 15 with ( 15 - 6 = 9 ) => { 6, 10, 9 }
{ 6, 10, 9 } => Replace 10 with ( 10 - 6 = 4 ) => { 6, 4, 9 }
{ 6, 4, 9 } => Replace 9 with ( 9 - 6 = 3 ) => { 6, 4, 3 }
{ 6, 4, 3 } => Replace 6 with ( 6 - 4 = 2 ) => { 2, 4, 3 }
{ 2, 4, 3 } => Replace 3 with ( 3 - 2 = 1 ) => { 2, 4, 1 }
{ 2, 4, 1 } => Replace 4 with ( 4 - 2 = 2 ) => { 2, 2, 1 }
{ 2, 2, 1 } => Replace first 2 with ( 2 - 1 = 1 ) => { 1, 2, 1 }
{ 1, 2, 1 } => Replace 2 with ( 2 - 1 = 1 ) => { 1, 1, 1 }

The value of all the numbers when the game ends is 1. You may try to play the game differently and observe that the game will always end when all the values are 1.
",AMSGAME1,S10128943,PYTH,"
    t=int(raw_input())
    def gcd(a,b):
    	if a==0:
    		return b
    	return gcd(b%a,a)
    while t>0:
    	t-=1
    	n=int(raw_input())
    	a=map(int,raw_input().split())
    	b=gcd(a[0],a[1])
    	if n>2:
    		for i in range(2,n):
    		    b=gcd(b,a[i])
    	print b	

"
"
All submissions for this problem are available.
Chef is playing a game on a sequence of N positive integers, say A1, A2, ... AN. The game is played as follows.

If all the numbers are equal, the game ends.
Otherwise

Select two numbers which are unequal
Subtract the smaller number from the larger number
Replace the larger number with the result from above



Chef has already figured out that the game always terminates. He also knows, for a given sequence of integers, the game will always terminate on the same value, no matter how the game is played. Chef wants you to simulate the game for him and tell him if the game terminates on 1.
In fact, there may be many such games. Given a sequence of integers Chef wants to know the number of sub-sequences of the given sequence, for which, playing the above game on the subsuquence will terminate on 1. A sub-sequence can be obtained from the original sequence by deleting 0 or more integers from the original sequence. See the explanation section for clarity.
Input
The first line of the input contains an integer T, the number of test cases. Then follow the description of T test cases. The first line of each test case contains a single integer N, the length of the sequence. The second line contains N positive integers, each separated by a single space.
Output
For each test case, output a single integer - the number of sub-sequences of the original sequence, such that, playing the game on the sub-sequence results in ending the game with all the values equal to 1.
Constraints

1 ≤ T ≤ 100
1 ≤ N ≤ 60
1 ≤ Ai ≤ 104
All Ai will be distinct.

Sample

Input
3
4
2 3 5 7
4
3 4 8 16
3
6 10 15

Output
11
7
1

Explanation
Test Case 1: The following 11 sub-sequences are counted.

{ 2, 3 }
{ 2, 5 }
{ 2, 7 }
{ 3, 5 }
{ 3, 7 }
{ 5, 7 }
{ 2, 3, 5 }
{ 2, 3, 7 }
{ 2, 5, 7 }
{ 3, 5, 7 }
{ 2, 3, 5, 7 }

Test Case 2: The following 7 sub-sequences are counted.

{ 3, 4 }
{ 3, 8 }
{ 3, 16 }
{ 3, 4, 8 }
{ 3, 4, 16 }
{ 3, 8, 16 }
{ 3, 4, 8, 16 }

Test Case 3: There are 8 subsequences of { 6, 10, 15 }

{} => The game cannot be played on this sub-sequence
{ 6 } => The game cannot be played on this sub-sequence
{ 10 } => The game cannot be played on this sub-sequence
{ 15 } => The game cannot be played on this sub-sequence
{ 6, 10 } => The game cannot end at { 1, 1 }
{ 6, 15 } => The game cannot end at { 1, 1 }
{ 10, 15 } => The game cannot end at { 1, 1 }
{ 6, 10, 15 } => The game ends at { 1, 1, 1 }. Hence this is the only sub-sequence that is counted in the result.

",AMSGAME2,S2173558,PYTH,"
    #!/usr/bin/python
    import sys
    import math
    mylist = []
    n = 0
    
    def gcd(a,b):
    	if a < b :
    		temp = b
    		b = a
    		a = temp
    
    	if b==0 :
    		return a 
    	
    	p = a % b
    	
    	return gcd(b , p)
    
    def val(pos,total):
    	global mylist
    	global n
    	if pos==n :
    		if total==1 :
    			return 1
    		else :
    			return 0
    	if total==1 :
    		return math.pow(2 , n-pos)
    
    	return val(pos+1,total) + val(pos+1,gcd(mylist[pos],total))
    
    
    def main():
    	global mylist
    	global n
    	t = int(raw_input())
    	while(t):
    		n = int(raw_input())
    		mylist = []
    		for i in xrange(0,n):
    			mylist.append(int(raw_input()))
    		sum = 0
    		for i in xrange(0,n):
    			#print sum
    			sum = sum + val(i+1,mylist[i])
    			#print sum , i , mylist[i]
    		print int(sum)
    
    		t = t-1
    
    if __name__ == ""__main__"":
    	main()

"
"
All submissions for this problem are available.You are given a sequence of N integer numbers A. Calculate the sum of Ai AND Aj for all the pairs (i, j) where i < j. 
 The AND operation is the Bitwise AND operation, defined as in here. 
Input
The first line of input consists of the integer N. 
The second line contains N integer numbers - the sequence A.
Output
Output the answer to the problem on the first line of the output.
Example
Input:
5
1 2 3 4 5

Output:
9

Scoring

Subtask 1 (13 points): N <= 1000, Ai <= 1. 
Subtask 2 (39 points): N <= 1000, Ai <= 109. 
Subtask 3 (21 points): N <= 105, Ai <= 1. 
Subtask 4 (27 points): N <= 105, Ai <= 106.  ",AND,S12073891,PYTH,"
    N = input()
    A = map(int, raw_input().split())
    su = 0
    for i in range(N):
      for j in range(i+1,N):
        su += A[i] & A[j]
    print su
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
You are given an array of N integers. You should support the following queries on this array.

0 L R : Find the minimum integer in the range AL, AL+1, ..., AR.
1 L R X :  You should apply the assignment A[i] = A[i] & X, for all indices i in range [L, R], where & denotes bitwise AND operation.

Input
First line of the input contains two space separated integers N and Q.
Second line contains N integer numbers denoting array A.
In the next Q lines, each contain one of the queries described above.
Output
For each query of the type 0, output  a single line containing the answer of the query.
Constraints

1 ≤ N, Q ≤ 105
1 ≤ Ai, X ≤ 109
1 ≤ L ≤ R ≤ N 

Example
Input:
5 5
1 5 2 3 4
0 2 5
1 1 5 6
0 2 2
1 2 5 3
0 1 3

Output:
2
4
0
 ",ANDMIN,S10850379,PYTH,"
    inpt = raw_input()
    arr = inpt.split()
    n = int(arr[0])
    q = int(arr[1])
    inp = raw_input()
    w = inp.split()
    for i in range(len(w)):
        w[i] = int(w[i])
    answer = []
    while q:
        query = raw_input()
        li = query.split()
        
        for i in range(len(li)):
            li[i] = int(li[i])
            
        if li[0] == 0:
            l = li[1]
            r = li[2]
            c = []
            c = w[l-1:r]
            c.sort()
            answer.append(c[0])
        
        if li[0] == 1:
            l = li[1]
            r = li[2]
            x = li[3]
            for i in range(l-1,r):
                w[i] = w[i] & x
        
        q -= 1
    
    for i in range(len(answer)):
        print answer[i]
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese  and Russian.
A pair of non-negative integers (A,B) is called and-pair if A & B = B, i.e., bitwise-and of A and B is equal to B. Similarly, a tuple of K non-negative integers (A1,A2,A3 .. AK) is called and-tuple if Ai & Ai+1 = Ai+1 for 1≤i≤K-1.
Given two integers N and K, how many and-tuples of size K exist such that the sum of the elements of the tuple is N?
Input
First line contains T, the number of testcases, then T lines follow. Each of the following lines contain two space-separated integers K and N.
Output
For each testcase, print a single line containing the answer. Since the number can be quite large, print the answer modulo 1000000009.
Constraints

For 20 points: 1 ≤ T ≤ 10000, K = 3, 1 ≤ N ≤ 1018For 80 points: 1 ≤ T ≤ 10000, 3 ≤ K ≤ 4, 1 ≤ N ≤ 1018
Example
Input:
23 24 2Output:
22Explanation:

In the first case, the two and-tuples are (2,0,0) and (1,1,0).
In the second case they are (2,0,0,0) and (1,1,0,0).
 ",ANDTUPLE,S5225340,PYTH,"
    import sys
    
    for __ in range(input()) :
        answer=0
        n,m=map(int,sys.stdin.readline().split(' '))
        if n&1 :
            print (n/2+1)%1000000009
        else :
            print (n/2)%1000000009
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
There are N piles of stones, where i-th pile has Ai stones. A game is played on these piles, in order from pile 1 to N. When the game is on the i-th pile, a player can remove any non-zero number of stones from this pile in a single move. If the current pile becomes empty, the game moves on to the next pile. The player who is unable to make a move loses.
Srijan and Ankit are going to play this game. Ankit, being younger, always gets to start the game. However, Srijan, being clever, sneaks into the game arena early and permutes the order of piles. Then, the game is played on this new order of piles. Your task is to find out the number of orders in which the piles can be arranged so that Ankit wins the game. Assume that both the players play optimally. Since the answer can be very large, output it modulo 109 + 7.
Note that two orders are considered different if their contents are different. Formally, two orders A and B are different if there exists an index k (1 ≤ k ≤ N) such that Ak != Bk.
Input

The first line contains an integer T, denoting the number of test cases to follow. Each of the test cases contains exactly two lines.
The first line for each test case contains an integer N, denoting the number of piles, and the next line contains N space-separated integers, denoting the number of stones in the piles.

Output
For each test case, output a single integer corresponding to the answer for that test case.
Constraints

1 ≤ T ≤ 1000
1 ≤ N ≤ 105
1 ≤ Ai ≤ 1010
The sum of values of N over all test cases does not exceed 106.

Example:
Sample input:


2
3
1 1 2
2
2 3


Sample Output:


2
2


Explanation:

Case 1:
The following different orders are possible:  

[1, 1, 2]
Ankit removes the only stone in the first pile.
Srijan removes the only stone in the second pile.
Ankit removes both the stones in the second pile.
Ankit wins.  

[1, 2, 1]
Ankit removes the only stone in the first pile.
Srijan takes one stone from then the second pile. Ankit removes the remaining one stone from the second pile.
Srijan removes the only stone in the third pile.
Srijan wins.
[2, 1, 1]
Ankit removes both the stones in the first pile.
Srijan removes the only stone in the second pile.
Ankit removes the only stone in the second pile.
Ankit wins.
Thus, Ankit wins on 2 different orders. ",ANKGAME,S7492719,PYTH,"
    import itertools
    test_case = input()
    while(test_case):
    	test_case-=1
    	total=0
    	n = input()
    	l = map(int,raw_input().split("" ""))
    	no_of_ones = l.count(1)
    	per_l = list(itertools.permutations(l))
    	set1=set()
    	set1.update(per_l)
    	l=list(set1)
    	if(no_of_ones==0):
    		print len(l)%1000000007
    		continue
    	for ele in l:
    		if(no_of_ones%2==1):
    			if(ele[0]==1):
    				continue
    			else:
    				total+=1
    		else:
    			if(ele[0]==1):
    				flag=0
    				for i in xrange(1,no_of_ones):
    					if(ele[i]!=1):
    						flag=1
    						break
    				if(flag==0):
    					total+=1
    			else:
    				total+=1
    	print total%1000000007
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese  , Russian and Vietnamese
Chef Rahul likes those arrays that can be rearranged to form an interval of values - an increasing sequence where each element is greater than the previous by exactly one. For example:  

Rahul likes the array [3, 6, 5, 4] as it can be re-arranged to [3, 4, 5, 6].  

Rahul doesn't like [1, 2, 4, 5] as no clear interval can be defined from these elements.  



Given an array a of length n, your task is to write a program that counts the number of contiguous subarrays of a liked by Rahul that have length not less than w.
Input:
The first line contains a single integer T, the number of test cases to follow. Each of the test cases contain exactly 2 lines.
The first line contains two space-separated integers n and w.
The next line contains exactly n space-separated integers, denoting the array a.
Output:
You should output exactly T lines each containing answer for corresponding test case.
Constraints:

1 ≤ T ≤ 105 

1 ≤ n ≤ 106 

sum of n over all testcases does not exceed 106
1 ≤ w ≤ n
a is a permutation of values [1, 2, 3 ... n]

Example
Input:
2
3 1
2 3 1
6 3
6 1 5 3 4 2 


Output:
5
5  


Explanation
Example case #1:
The following 5 subarrays form an interval:  


[2]
[3]
[1]
[2, 3]
[2, 3, 1]


Example case #2:
The following 5 subarrays form an interval:  

[6, 1, 5, 3, 4, 2]  forms [1..6]
[1, 5, 3, 4, 2]  forms [1..5]
[5, 3, 4]  forms [3..5]
[5, 3, 4, 2]  forms [2..5]
[3, 4, 2]  forms [2..4]


Note that [3, 4] also forms an interval but cannot be counted as its length is less than w(= 3). ",ANKINTER,S7123599,PYTH,"
    t = int(raw_input())
    while(t):
    	temp = raw_input().split()
    	n = int(temp[0])
    	w = int(temp[1])
    	elements = raw_input().split()
    	array = []
    	i = 0
    	while(i<n):
    		array.append(int(elements[i]))
    		i = i + 1
    	j=w
    	count=0
    
    	while(w<=len(array)):
    		i = 0
    		j = 0
    		while(j<len(array)):
    			length = len(array[i:w+j])
    			if(length == w):
    				temp = array[i:w+j]
    				if(len(temp)==1):
    					count = count + 1
    				else:
    					big = max(temp)
    					small = min(temp)
    					result = sum(temp)
    					otherresult = ((2*small+(length-1)) * length) / 2
    					if(otherresult==result):
    						count = count+1
    			i = i + 1
    			j = j + 1
    		w = w + 1
    	t = t - 1 
    	print count
    
    
    
    
    
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
Chef VS recently conducted an exam on the subject of Computer Science. Being biased as well as lazy, he awards marks looking at only the students' roll numbers, and not their actual answers on the exam. Students have roll numbers ranging from 1 to N, where N is the number of students in his class. For a student with roll number i, chef VS's favouritism value is given by favi.
For any two students with roll numbers next to each other, VS ensures that the one with the higher favouritism value gets strictly more than twice the marks received by the less favourite student.
The paper consisted of many problems and each problem must be graded with either the full score allotted to that problem, or zero score.
Since he does not want to get caught, VS must make sure that the number of marks awarded to any student must be expressible as a sum of maximum possible scores of problems, repeated any number of times. For example, 
suppose that the problems in the problem set carry marks from the set {2,5,7}.
Clearly, no student can be awarded 1 mark.
7 marks may be awarded, as 7 = 2 + 5.
4 marks may also be handed out, as 4 = 2 + 2.
Note that 0 marks can be awarded as well.

One of the students, Sahil, aspires to top the class, and is therefore very concerned about the marks he would get. While Sahil topping the class could have really been possible if the exam was on The Harry Potter series, his chances are rather bleak on a Computer Science test. So, he finds out the fav array by breaking into VS's office, and uses this information to find the minimum possible average of marks obtained by the class and judge the ground reality. It is certain that VS never violates the conditions mentioned in the earlier paragraphs.
Print the minimum possible average. Please note that test data is generated so as to ensure that every answer is always less than 252
Input
The first line contains an integer T, denoting the number of test cases to follow.
Each test cases contains 4 lines.
The first line contains N, the number of students in the class.
The second line contains N space-separated integers, denoting the favouritism value for each student.
The third line contains the number of distinct marks in the set, K.
The fourth line contains K distinct numbers separated by a single space. These numbers represent the set of marks allotted to problems.
Output
Output exactly T lines, each containing the answer for the corresponding test case. Absolute error of the output should be less than 1e-6. Please note that test data is generated so as to ensure that every answer is always less than 252.


Constraints

1 ≤ T ≤ 10
1 ≤ N ≤ 1000
0 ≤ favi ≤ 109
1 ≤ K ≤ 50 
1 ≤ marks allotted to a problem ≤ 50

Example:
Sample Input:

2
3
1 2 3
3
2 5 7
4
1 2 2 3
3
2 4 8


Sample Output:

2.333333
1.000000

Explanation:

Test 1:
Award 0 to student 1, 2 to student 2 and 5 to student 3.
Total score of the class = 7
Average = 7 / 3 = 2.333333
Note that 4 is also a possible total score for the class, but the condition that student 3 should get strictly more that twice the marks obtained by student 2 would have been violated.
Test 2:
Award 0 to students 1 and 3. Award 2 to students 2 and 4.
Total score of the class = 4
Average = 4 / 4 = 1.000000
Here, you must notice that, despite the fact that student 2 and 3 are favoured equally by VS, they will not necessarily get the same number of marks. ",ANKMARKS,S7265481,PYTH,"
    noc = int(raw_input())
    while noc:
        noc-=1
        
        nos = input()
        favs= map(int,raw_input().split())
        nom = input()
        marks = sorted(map(int,raw_input().split()))
        scores = [0]
        indx = -1
        for i in range(1,len(favs)):
            if favs[i] > favs[i-1]:
                indx+=1
                scores.append(marks[indx])
            elif  favs[i-1]>favs[i]:
                indx+=1
                scores[i-1] = marks[indx]
                scores[i] = 0
            else:
                scores.append(0)
                indx = -1
        print scores       
        print float(sum(scores)) / len(scores)        
                    
                    
                
            
            
        
        
        

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese  , Russian and Vietnamese
Mark has recently started studying string algorithms. So, as to gauge his knowledge, Lucy challenges him to a task.
""Given a string s, answer several times a query to determine whether a substring s[i, j] (inclusive) is palindromic or not."", said Lucy in a confident tone!
As smart as Mark is, he was able to instantly find the solution!
Now, Mark has challenged little Lucy to do the same task by reversing a specific substring beforehand. As Lucy is still just a novice, she asks for your help.
You have to write a program that answers Q queries on a string S.
Each query contains four integers (i, j, k, l).
For every query, first reverse the substring s[i, j] (inclusive) and then report if substring s[k, l] (inclusive) is a palindrome.
Note that the reversal operations are only for the specific query and should not persist for further queries. Please check the explanation section for better understanding.
Input:
The first line of input file contains string S. The next line contains an integer Q.
Each of the following Q lines each contain 4 space separated integers i, j, k and l.
Output:
Output exactly Q lines, each containing the result of corresponding query as ""Yes"" or ""No"".
Constraints:


1 ≤ |S| ≤ 105

1 ≤ Q ≤ 333333

1 ≤ i ≤ j ≤ |S|  

1 ≤ k ≤ l ≤ |S|
S contains only the characters 'a' to 'z'


Example:
Sample Input:

ababa
4
2 3 3 4
1 2 3 4
1 3 3 5
2 4 1 5


Sample Output:

Yes
No
Yes
Yes

Explanation:
Query 1:
The string becomes aabba. The queried substring  is bb, which is a palindrome.
Query 2:
The string becomes baaba. The queried substring is ab, which is not a palindrome.
Query 3:
The string becomes ababa. The queried substring is aba, which is a palindrome.
Query 4:
The string becomes ababa. The queried substring is ababa, which is a palindrome.
Notes:

Here, a substring [i, j] is defined as the string formed by characters s[i], s[i+1],..., s[j].
A palindrome is a sequence of characters which reads the same backward or forward. For example, aba, abba are palindromes, while abab and abcd are not palindromes.
 ",ANKPAL,S11523965,PYTH,"
    a=raw_input()
    
    t=int(input())
    while(t>0):
        c=list()
        b=list(a)
        i,j,k,l=map(int,raw_input().split("" ""))
        for x in range (i-1,j):
            c.append(b[x])
        c.reverse() ;
        y=0
        z=len(c)
        for x in range(i-1,j):
            if(y==z):
                break
            b[x]=c[y]
            y=y+1
        m=l-1
        n=0
        for x in range(k-1,l):
            if(b[x]!=b[m]):
                print ""No""
                n=n+1
                break
            else:
                n=0 ;
            m=m-1
        if(n==0):
            print ""Yes""
        t=t-1
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
Chef has recently learnt about sequences of parentheses. These are special sequences that contain only the characters '(' and ')'.
A regular parentheses sequence follows the following definition:  


An empty sequence is regular
If S is a regular sequence, then (S) is also regular
If A and B represent two regular sequences, then their concatenation AB is also regular.

Therefore, the sequences (), ()() and (())() are regular, while ()(, ) and ))() are non-regular.
Now, you need to find the longest subsequence of the given sequence which is non-regular. Amongst all such distinct answers, output the lexicographically Kth amongst them. If the number of distinct subsequences with maximum length is less than K, please output -1 instead.
Input:
The first line contains a single integer T, denoting the number of test cases to follow.
Each of the test cases have exactly two lines, the first contains the parentheses sequence and the second contains the value of K.
Output:
Output exactly T lines, each containing answer to the corresponding query.
Constraints:

1 ≤ T ≤ 10
1 ≤ |S| ≤ 105
1 ≤ K ≤ 109

Example:
Sample Input:

5
()
2
(()
1
(()
2
(())
2
(())
3


Sample Output:

)
(()
-1
())
-1


Explanation:
Case 1:
Following are the subsequences:  


Length   Subsequence   Regular/Non-Regular

  1			(			Non-regular
  1			)			Non-regular
  2			()			Regular


There are two non-regular subsequences of equal length:'(' and ')'.
We are asked for the lexicographically 2nd, so output should be ')'.
Case 2:
Following are the subsequences:  


Length   Subsequence   Regular/Non-Regular
  1			(			Non-Regular
  1			)			Non-Regular
  2			((			Non-Regular
  2			()			Regular
  3			(()			Non-Regular


In this case, there are non-regular subsequences of lengths 1, 2, and 3. But, as 3 is the maximum among these, we choose, (().
Case 3:
The string is same as Case 2, and we realize that there is only one subsequence of the maximum length 3, thus we must output -1.
Case 4:
We can find that following subsequences have maximum length and are non-regular.

Length 	Subsequence
  3			())	
  3			(()


In lexicographical order, we have following subsequences: [ ((), ()) ]
The query asks for 2nd subsequence, thus the required output is ()).
Case 5:
This is the same sequence as last case, and we know that there are exactly 2 distinct subsequences of maximum length. Thus, answer should be -1.
Notes:

A subsequence of a given sequence A is a non-empty sequence obtained by removing zero or more characters from A. It does not need to be contiguous.
A sequence A is called different from another sequence B, if there exists an integer k, such that 1 ≤ k ≤ N (N  is the length of both sequences), and Ak != Bk.
Consider two different N-length sequences, A and B. Let k be the smallest integer such that A[k] != B[k] and 1 ≤ k ≤ N. If A[k] < B[k], then A is said to be lexicographically smaller than B, and vice-versa.
 ",ANKPAREN,S11849068,PYTH,"
    from itertools import *
    def check(S):
    	stack = []
    	for i in range(len(S)):
    		if(S[i]==""(""):
    			stack.append(S[i])
    		else:
    			if stack:
    				x = stack.pop()
    			else:
    				return 0
    	if not stack:
    		return 1
    	else:
    	 	return 0
    
    t = input()
    while t>0:
    	string = raw_input()
    	ans = []
    	for i in range(1,len(string)+1):
    		temp = list(combinations(string,i))
    		#print temp
    		for j in range(len(temp)):
    			s = """"
    			for k in range(i):	
    				s += temp[j][k]
    			if s not in ans:
    				ans.append(s)
    	
    	#print ans
    	for i in range(len(ans)-1,-1,-1):
    		if(check(ans[i]) == 0):
    #		print ans[i]
    			break
    	l = len(ans[i])
    	temp = []
    	for i in range(len(ans)-1,-1,-1):
    		if(len(ans[i])==l):
    			temp.append(ans[i])
    	temp.sort()
    	k = input()
    	if(k > len(temp)):
    		print ""-1""
    	else:
    	 	print temp[k-1]
    	t = t-1
    
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
Problem description
Abhijeet loves to play with rectangles. Today he has N rectangles of various sizes with him. He started to arrange them on the coordinate plane such that the area of intersection is maximized. However, he never rotated the rectangles he had, he only moved them here and there.
Abhijeet soon realized that the game was boring and decided to introduce a modification. He decided to remove atmost M of those rectangles and arrange others on coordinate plane such that the area of intersection is maximized.
Given the dimensions of N rectangles and M, can you answer maximum possible area of intersection with above rules?
Note: If all the rectangles are removed, the area of intersection is considered as 0.
Input
The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.First line of each test case has two integer N and M. N lines follow, each has two integers representing the length and breadth of the rectangle.
Output
For each test case, output a single line containing the required answer.
Constraints

1 ≤ T ≤ 105
1 ≤ N ≤ 105
0 ≤ M ≤ N
1 ≤ Rectangle Dimensions ≤ 109
1 ≤ Sum of N over all test cases ≤ 106

Example
Input:
3
1 1
10 10
2 0
5 10
5 5
2 1
1 1
2 2

Output:
100
25
4
Explanation
Example case 1
Abhijeet has only one rectangle. He can remove it, but then the area will be 0. Optimal way is not to remove it. Area = 10 * 10 = 100
Example case 2
Abhijeet cannot remove any rectangles in this case. He can however, place them such that the smaller 5 by 5 rectangle is completely inside the larger 5 by 10 rectangle. Then the area of intersection is 5 * 5 = 25
Example case 3
Abhijeet can remove atmost 1 rectangles in this case. He can remove the smaller rectangle of size 1 by 1. He is then left with 2 by 2 rectangle of area 4. ",ANUAHR,S5935818,PYTH,"
    t=input()
    for i in range(t):
        nold,m=map(int,raw_input().split())
        n=nold
        rectangle=[1]*n
        l=[];w=[]
        for j in range(n):
            le,wi=map(int,raw_input().split())
            l.append([le,j])
            w.append([wi,j])
        l.sort(key=lambda x:x[0])
        w.sort(key=lambda x:x[0])
        llow=0;lup=1
        wlow=0;wup=1
        while n>1 and m>0:
            if n>=2:
                if l[llow][0]*w[wup][0]>l[lup][0]*w[wlow][0]:
                    rectangle[w[wlow][1]]=0
                    wlow=wup;wup+=1
                    while wup<nold and rectangle[w[wup][1]]!=1:
                        wup+=1
                    while rectangle[l[llow][1]]!=1:
                        llow+=1
                    if llow==lup:
                        lup+=1
                        while lup<nold and rectangle[l[lup][1]]!=1:
                            lup+=1
                else:
                    rectangle[l[llow][1]]=0
                    llow=lup;lup+=1
                    while lup<nold and rectangle[l[lup][1]]!=1:
                        lup+=1
                    while wlow<nold and rectangle[w[wlow][1]]!=1:
                        wlow+=1
                    if wlow==wup:
                        wup+=1
                        while wup<nold and rectangle[w[wup][1]]!=1:
                            wup+=1
                n-=1;m-=1
        print l[llow][0]*w[wlow][0]
            
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.

N Soldiers are lined up for a memory test. They are numbered from 0 to N-1 from left to right.


In the test, there are M rounds. In each round, Captain selects one position. Soldier at that position will be numbered 0. All the soldiers to the right of selected position will be numbered one greater than the soldier to his left. All the soldiers to the left of selected position will be numbered one greater than the soldier to his right. 
eg. if N = 6 and selected position is 3, then the numbering will be [3, 2, 1, 0, 1, 2].


 After M rounds, Captain asked each soldier to shout out the greatest number he was assigned during the M rounds. In order to check the correctness, Captain asked you to produce the correct values for each soldier (That is the correct value each soldier should shout out).

Input
The first line of the input contains an integer T denoting the number of test cases.
First line of each test case contains two integers, N and M.
Second line of each test case contains M integers, the positions selected by Captain, in that order.
Output
For each test case, output one line with N space separated integers.
Constraints

1 ≤ T ≤ 10^4
1 ≤ N ≤ 10^5
1 ≤ M ≤ 10^5
1 ≤ Sum of N over all testcases ≤ 10^5
1 ≤ Sum of M over all testcases ≤ 10^5
0 ≤ Positions selected by captain ≤ N-1

Example
Input
2
4 1
1
6 2
2 3

Output
1 0 1 2
3 2 1 1 2 3

 ",ANUARM,S10012637,PYTH,"
    for _ in xrange(input()):
            n,m = map(int, raw_input().strip().split())
            l = map(int, raw_input().strip().split())
            mx = max(l)
            mn = min(l)
            out = [max(abs(mx-i), abs(i-mn)) for i in range(n)]
            print "" "".join(map(str,out))

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
Statement
Chef gives you a book with N pages. The pages are numbered from 1 to N.
Chef randomly selects a Secret Digit from 0 to 9. Now he asks you to open one page of the book without looking at the book. You win the game if that page number contains the Secret Digit. For example if the Secret Digit is 8, then 8, 80, 1238213, 98 are all winning pages and 9, 90, 1239123 are loosing pages.
What is the probability of winning, if both Chef's choice and your choice has uniform distribution?
Input
The first line of input contains integer T, denoting the number of test cases.
Each test case consists of a single line with integer N.
Output
For each test case, output the required probability P/Q. P/Q is an irreducible fraction.
Constraints

1 ≤ T ≤ 10000
1 ≤ N ≤ 1017

 
Example
Input:
2
1
5

Output:
1/10
1/10
 
Explanation
Chef can choose any Secret Digit from 0 to 9. But you can only open page with number 1. Probability that the Secret Digit is 1 after you opened the page with number 1 is 1/10. ",ANUBGC,S3923049,PYTH,"
    from math import sqrt
    from fractions import gcd
    
    d0, d1 = [0 for i in range(19)], [1 for i in range(19)]
    
    for i in range(2,18):
    	d0[i] = 10*d0[i-1] + 9*(10**(i-2) - d0[i-2])
    	d1[i] = 10**(i-1) + 9*d1[i-1]
    d1[0] = 0
    
    def fn():
    	num = int(raw_input())
    	global d0, d1
    	ans1 = 0.0
    	s = str(num)
    	n = len(s)
    	cnt = [0 for i in range(10)]
    	for j in range(1,10):
    		for ii in range(len(s)):
    			i = int(s[ii])
    			if i < j:
    				cnt[j] += i*(d1[n-ii-1])
    			elif i>j:
    				cnt[j] += (i-1)*(d1[n-ii-1]) + 10**(n-ii-1)
    			else:
    				cnt[j] += i*d1[n-ii-1]
    				ss = s[ii+1:]
    				if len(ss):
    					cnt[j] += int(ss)
    				break
    	cnt[0] +=d0[n-ii-1] 
    	for ii in range(len(s)):
    		if ii == n-1:
    			cnt[0]+=1
    			break
    		i = int(s[ii])
    		if i == 0:
    			cnt[0]+= int(s[ii:])+1
    			break
    		else:
    			cnt[0] +=  (i-1)*(10**(n-ii-2) +d0[n-ii-1] -d0[n-ii-2])
    
    	#print cnt
    	p = sum(cnt)
    	q = 10*num
    	g = gcd(p,q)
    	p/=g
    	q/=g
    	print str(p)+""/""+str(q)
    	#print cnt
    
    
    
    
    t = int(raw_input())
    for i in range(t):
    	fn()

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
Problem description
It is winter super sale and all the shops have various offers. Suraj selected N items to buy and he is standing in the billing queue. It was then he noticed the offer ""Buy two, get two"". That means for every two items you buy, they give you two items for free. However, items can be of varying price, they always charge for 2 most costly items and give other 2 as free. For example, if the items cost 1, 1, 2, 2, then you have to pay 4 and take all 4 items.
Suraj is busy reordering his items to reduce the total price he has to pay. He can separate the items and get them on different bills if needed. Can you tell me what is the least price Suraj has to pay to buy all the N items?
Input
The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. First line of each test case has single integer N. Second line of each test case has N space separated integers, which are the costs of items Suraj want to buy.
Output
For each test case, output a single line containing the required answer.
Constraints

1 ≤ T ≤ 1000
1 ≤ N ≤ 1000
1 ≤ Cost of items ≤ 1000

Example
Input:
3
4
1 1 2 2
2
10 200
7
1 1 10 2 2 2 1

Output:
4
210
14
Explanation
Example case 1
Suraj pays for 2 costly items and gets other 2 for free.
Example case 2
Suraj has to pay for both the items, he wont get anything for free.
Example case 3
Suraj separates the items into 2 bills. In one bill he pays 12. And in another bill he pays 2. ",ANUBTG,S10078490,PYTH,"
    import sys
    a =  int(raw_input())
    while a>0:
        b=int(raw_input())
        i=sum=0
        p = map(int,sys.stdin.readline().split())
        p.sort()
        p.reverse()
        j=int(b/4)
        l=b%4
        while i<j:
            sum+=p[4*i]+p[(4*i)+1]
            i+=1
        if b==1:
            print p
        elif l==0:
            print sum
        elif l==1:
            print (sum+p[4*j])
        elif l==3 or l==2:
            print (sum+p[4*j]+p[(4*j)+1])
        a-=1
            
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
Problem description.
Given a rooted tree with N nodes. Nodes of the tree are numbered from 1 to N. Node 1 is the root. You need to add M nodes to it in the given order. All the nodes have values. Cost for adding a node A with value va to another node B with value vb is va*vb. There is an additional cost of y (so total cost of va*vb+y) if B has atleast x child nodes. After node A has been added to another node B it becomes a child of B.
After adding a node A to the tree, nodes next in list can be added to A also. You need to calculate the total minimal cost to add all M nodes in given order.
Input
The first line of input contains N. The second line of input contains N integers representing the values of nodes in order from node 1 to node N. N-1 lines follow, each line defines an edge. Each line has 2 integers, which says that those 2 nodes are connected.
Next line of input contains an integer Q, denoting the number of queries you need to answer. Each query consists of 2 lines. The first line of each query has 3 integers, M x y. The second line of each query has M integers representing the values of the nodes to be added in order.
Note that in each query, M nodes are added to the initial tree, and hence changes made in previous query should not be considered in later queries
Output
For each query, output a single line containing the minimal total cost to add all the nodes in given order.
Constraints

1 ≤ N ≤ 100000
1 ≤ x ≤ 1000
1 ≤ y ≤ 1000
1 ≤ Q ≤ 100
1 ≤ M ≤ 100
1 ≤ Values of all nodes in input ≤ 1000

Example
Input:
3
2 2 3
1 2
2 3
2
2 2 10
10 10
3 2 10
1 2 2

Output:
40
6
 
Explanation
Query 1.
Optimal solution is to add the first node from the query to node 1 of the tree and the second node from the query to node 2 of the tree. Cost is 10*2 + 10*2.
Query 2.
Optimal solution is to add the first node from the query to node 1 of the tree for a cost 2. Then add next two nodes from the query to newly added node.
Total cost is 2 + 2 + 2 = 6. ",ANUBTT,S3970073,PYTH,"
    import copy
    
    def minimal_cost( nodes, i, x, y ):
        
        min_cost = 100000000000
        min_node_id = 0
        for n in nodes:
            if nodes.get(n).get(""n_child"") >= x:
                x_cost = y
            else:
                x_cost = 0
            cost =( nodes.get(n).get(""value"") * i )+ x_cost
    
            if cost < min_cost:
                min_cost = cost
                min_node_id = n
    
    
        return min_node_id, min_cost
    
    
    
    def main():
        n = raw_input()
        value_string = raw_input().split("" "")
        nodes = {}
        i = 1
        for a in value_string:
            nodes[ i ] = { ""value"" : int(a),
                    
                            ""n_child"" : 0 }
            i = i + 1
    
        for a in xrange( int(n) -1 ):
             edge = raw_input().split("" "")
             parent = int( edge[0] )
             nodes[parent][""n_child""] = nodes[parent].get(""n_child"") + 1
    
             
        q = raw_input()
        for a in xrange( int(q) ):
            copy_nodes = copy.deepcopy(nodes)
            m, x, y  = raw_input().split("" "")
            nodes_insert  = raw_input().split("" "")
            total_cost = 0
            j = 1
            for i in nodes_insert:
                node_id, cost = minimal_cost( copy_nodes, int(i), x, y )
                total_cost += cost
                copy_nodes.get(node_id)[""n_child""] = copy_nodes.get(node_id).get(""n_child"") + 1
                copy_nodes[ int(n) + j ] = { ""value"" : int(i),
                                        ""n_child"" : 0 }
                j = j + 1
    
            print total_cost
    
    
    
    if __name__ == ""__main__"":
        main()
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese  and Russian.
Statement
Yet another game from chef. Chef gives you N cards and M bags. Each of the N cards has an integer written on it. Now chef asks you to close your eyes and choose a subset of them. He then sums the numbers written on chosen cards, takes its absolute value and gives you those many coins. You win the game if you can divide these coins into M bags with each bag having equal share. As a first step to calculate the probability of winning, you would like to know the number of different subsets which will make you win. Note that all the cards are of different color, so even if 2 cards have the same number written on it, they are still considered as different cards.
Input
The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
First line of each test case contains two integers N and Q. Q denotes the number of queries to be answered. Second line of each test case contains N integers, the numbers written on cards.
Following Q lines contain an integer M.
Output
For each query output the required Answer modulo 1000000009. Answer is the number of subsets that will ensure you win.
Constraints

1 ≤ T ≤ 3
1 ≤ N ≤ 100000
1 ≤ Q ≤ 30
1 ≤ M ≤ 100
-10^9 ≤ Number on card ≤ 10^9

Example
Input
2
5 1
1 2 -1 4 5
9
5 2
1 2 3 4 5
5
15

Output
4
8
2
Explanation
Test Case #1, Query #1
{}, {1,-1}, {1,-1,4,5}, {4,5} are winning subsets. Sums are 0, 0, 9, 9 respectively.
Test Case #2, Query #1
{}, {5}, {1,4}, {2,3}, {1,4,5}, {2,3,5}, {1,2,3,4}, {1,2,3,4,5} are winning subsets. Sums are 0, 5, 5, 5, 10, 10, 10, 15 respectively.
Test Case #2, Query #2
{}, {1,2,3,4,5} are winning subsets. Sums are 0 and 15 respectively.
Author's Note
Time Limit is not very strict (Yes, not very loose either) if correct Algorithm is used.Author's solution passes with 2 sec Time Limit (C++ solution, using scanf and printf).
Maximum Input File Size < 4MB.
 ",ANUCBC,S8323329,PYTH,"
    """"""
    Created on Sat Oct  3 04:23:39 2015
    
    @author: magusverma
    """"""
    
    MOD = 10**9+9
    def modpow(a,b):
        x = 1
        while(b):
            if (b&1):
                x = (x*a)%MOD
            a = (a*a)%MOD
            b/=2
        return x%MOD
    
    precompute_limit = 100003
    fact = [1 for i in range(precompute_limit)]
    inv_fact = [1 for i in range(precompute_limit)]
    
    def gen_facts():
        for i in range(2,precompute_limit):
            fact[i] = (fact[i-1]*i)%MOD
            inv_fact[i] = modpow(fact[i],MOD-2)
    
    gen_facts()
    
    def ncr(n,r):
        if(n<r):
            return 0
        return (((fact[n]*inv_fact[r])%MOD)*inv_fact[n-r])%MOD
    
    from collections import defaultdict
    def fact(n):
        if n==0:
            return 1 
        return reduce(lambda x,y: x*y, [i for i in range(1,n+1)])
    def ncr(n,r):
        return fact(n)/(fact(r)*fact(n-r))
    
    #a = [1,2,-1,-1,-1,0,0]
    #m = 3
    #n = len(a)
    
    t = input()
    for case in range(t):
        [n,q] = map(int, raw_input().strip().split())
        array = map(int, raw_input().strip().split())
        for query in range(q):
            m = input()
            a = [i%m for i in array]
            
            a_ = [0 for i in range(m)]
            for i in a:
                a_[i] += 1
            
            d = defaultdict(int)
            for i,v in enumerate(a_):
                for j in range(1,v+1):
                    d[(i,(i*j)%m)] += ncr(v,j)
                    d[(i,(i*j)%m)] %= MOD
                    
            dp = [[0 for i in range(m)] for i in range(m+1)]
            dp[0][0] = 1
            
            for i in range(1,m+1):
                for j in range(m):
                    dp[i][j] += dp[i-1][j]
                    dp[i][j] %= MOD
                    for k in range(m):
                        dp[i][j] += dp[i-1][(j-k)%m]*d[(i-1,k)]
                        dp[i][j] %= MOD
            
            print dp[m][0]

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
Problem description
Chef loves circular cakes. He divides them into smaller pieces and sells them. You are to help him in this work.
Today Chef has cooked the brand new circular cake. To split the cake Chef can make several (possibly, zero) cuts. Each cut should be a straight line going from the center of the cake to its border. Also, the angle between any two cuts should have positive integer value (Chef measure all the angles in degrees). Chef consider two pieces of cake equal if the appropriate angles are equal.

The picture contains two distinct pieces, and two cuts. Red part on the image shows one piece. The appropriate angle is AOB.
Chef gives to you an integer N, denoting the number of pieces Chef wants to make. You need to answer the following questions:

Is it possible to make exactly N equal pieces from the whole cake?
Is it possible to make exactly N pieces from the whole cake?
Is it possible to make exactly N pieces from the whole cake, in such a way that no two of them are equal?


Input
First line contains a single integer T denoting the number of test cases. Each of the following T lines contain a single integer N denoting the number of pieces Chef wants to make.
Output
For each test case, output one line containing 3 space separated characters.
Above, we defined the 3 questions that Chef will ask. Output 'y' for yes or 'n' for no (quotes for clarity) for each of those questions.
Answers for 3 questions (in the order above) must be space separated on the same line.
Constraints

1 ≤ T ≤ 10000
1 ≤ N ≤ 10000

Example
Input:
2
4
7

Output:
y y y
n y y
 
Explanation
Example case 1.
Is it possible to make N equal pieces?
Yes, you can cut 4 pieces each with 90 degrees angle.
Is it possible to make N pieces?
Yes, you can cut 4 pieces each with 90 degrees angle.
Is it possible to make N pieces, such that no two of them are equal?
Yes, you can cut 4 pieces with angles 88, 89, 91, 92.
 ",ANUDTC,S10161211,PYTH,"
    test_case = int(raw_input())
    for t in range(test_case):
    	n = int(raw_input())
    	if 360 % n == 0:
    		print 'y',
    	else:
    		print 'n',
    	if n <= 360:
    		print 'y',
    	else:
    		print 'n'
    	if (n*(n+1)/2) <= 360:
    		print 'y',
    	else:
    		print 'n'

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese  and Russian.
Statement
You will be given an array A of N integers. You need to answer M queries.
Each query is of the form G x y.
For each query, construct the set S from A. A[i] is included in S if x <= i <= y and GCD(G,A[i]) > 1.
Let MAX be the maximum number present in S. Output MAX and number of occurances of MAX in S. If no such number exists, output ""-1 -1"" (without quotes).

Input
The first line of the input contains 2 integers N and M.
Next line has N integers representing the elements of array A.
M lines follow, one per query. Each line has 3 integers G, x and y
Output
For each query output the required Answer.
Constraints

1 ≤ N,M,G,A[i] ≤ 100000  (1 ≤ i ≤ N)
1 ≤ x ≤ y ≤ N

Example
Input
6 5
1 2 3 4 5 4
2 1 5
121 1 6
3 2 6
5 5 5
24 4 6

Output
4 1
-1 -1
3 1
5 1
4 2
Explanation
Query #1
GCD(2,1)=1, GCD(2,2)=2, GCD(2,3)=1, GCD(2,4)=2, GCD(2,5)=1
S = {2,4}
MAX = 4
Query #2
S = {}
There is no element in A such that GCD(121, A[i])>1
Query #5
GCD(24,4)=4, GCD(24,5)=1, GCD(24,4)=4
S = {4,4}
MAX = 4
Answer is ""4 2"" as there are 2 occurances of 4 in S

Author's Note
Time Limit is not strict if correct Algorithm is used.Author's solution passes with 0.6 sec Time Limit (C++ solution, using scanf and printf).
Maximum Input File Size < 3MB.

-->Author's Note
Time Limit is not strict if correct Algorithm is used.Author's solution passes with 0.6 sec Time Limit (C++ solution, using scanf and printf).
Maximum Input File Size < 3MB.

-->    ",ANUGCD,S3621205,PYTH,"
    # your code goes here
    import fractions
    
    n,m = map(int,raw_input().split())
    
    A = map(int,raw_input().split())
    
    #print n,m
    #print A
    
    while m > 0:
    	
    	G,x,y = map (int,raw_input().split())
    	
    	#print G,x,y
    	
    	S = []
    	
    	while x <= y:
    		
    		if fractions.gcd(G,A[x-1]) > 1:
    			S.append(A[x-1])
    		
    		#print S
    		
    		x = x+1
    		
    	if len(S) > 0:
    		print max(S), S.count(max(S))
    	else:
    		print -1,-1
    	
    	m = m -1
    
    #print n,m

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.

Mahesh got a beautiful array named A as a birthday gift from his beautiful girlfriend Namratha. There are N positive integers in that array. Mahesh loved the array so much that he started to spend a lot of time on it everyday. One day, he wrote down all possible subsets of the array. Then for each subset, he calculated the sum of elements in that subset and wrote it down on a paper. Unfortunately, Mahesh lost the beautiful array :(. He still has the paper on which he wrote all subset sums. Your task is to rebuild beautiful array A and help the couple stay happy :)

Input
The first line of the input contains an integer T denoting the number of test cases.
First line of each test case contains one integer N, the number of elements in A.
Second line of each test case contains 2^N integers, the values written on paper
Output
For each test case, output one line with N space separated integers in non-decreasing order.
Constraints

1 ≤ T ≤ 50
1 ≤ N ≤ 15
0 ≤ Values on paper ≤ 10^9
All input values are valid. A solution always exists

Example
Input
2
1
0 10
2
0 1 1 2

Output
10
1 1
Explanation
Test case #2
For the array [1,1], possible subsets are {}, {1}, {1}, {1,1}, respective sums are 0, 1, 1, 2. ",ANUMLA,S5193077,PYTH,"
    import sys
    t = int(raw_input())
    while t > 0:
    	n = int(raw_input())
    	x = map(int,raw_input().split())
    	x.remove(0)
    	for i in xrange(0,n):
    		a = min(x)
    		y = len(x)
    		sys.stdout.write(str(a))
    		sys.stdout.write("" "")
    		for j in xrange(0,y-1):
    			if x[j] != 0:
    				x[j] -= a
    			if x[j] == 0:
    				x.remove(x[j])
    	print """"
    	t-=1
    	
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
Problem description
Rudreshwar likes random numbers and random arrays. Today Rudreshwar started playing with a couple of Arrays A and B, each of size N.
Initially A is filled with zeros. Rudreshwar filled B with random numbers.
Rudreshwar visits each index i (1 <= i <= N) in random order. When at i, he selects another random index j such that j is greater or equal to i. He then increments A[i], A[i+1], A[i+2] ... A[j] by 1.
Finally if for any index i, A[i] is greater than B[i], he then throws away that array A
For a given B, calculate the number of different arrays A, that Rudreshwar can end up with. Two arrays are called different if there exists an index where the arrays have different values
Input
The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. First line of each test case contains an integer N. Second line contains N space separated integers representing the array B
Output
For each test case, output a single line containing the required answer modulo 1000000007.
Constraints

1 ≤ T ≤ 100
1 ≤ N ≤ 1000
1 ≤ B[i] ≤ N

Example
Input:
2
2
2 2
3
1 1 1

Output:
2
1
Explanation
Test case 1
{1, 1} and {1, 2} are valid.
Test case 2
{1, 1, 1} is the only possible final array A. ",ANURRZ,S5936731,PYTH,"
    T = int(raw_input())
    
    def solve(s,N):
        curr = s[-1]
        for i in xrange(N-1, -1, -1):
            consider = min(i+1, s[i])
            if consider < curr:
                curr = consider
            s[i] = curr
        return reduce(lambda x,y: x*y, s)
    
    for i in xrange(T):
        N = int(raw_input())
        L = map(int, raw_input().split())
        print solve(L, N)
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
Problem description
As a holiday gift, Tojo received a probability problem. The problem read as follows
Consider an N by M grid. Rows are numbered 1 to N, from top to bottom. Columns are numbered 1 to M, from left to right. You are initially at cell (1, 1) and want to go to cell (N, M). From any cell you can move to the cell below it or to the cell right to it. You should never go out of the grid. At any point you should consider all the possibilities of movement with equal probability
Let P[i][j] be the probability of visiting cell (i, j). You need to calculate the sum of P[i][j] for 1 ≤ i ≤ N, 1 ≤ i ≤ M.
As we all know, Tojo really hates probability related problems. He wants you to solve this task
Input
The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.Only line of each test case has two integer N and M.
Output
For each test case, output a single line containing the required answer. Answers within an absolute or relative error of 10-6 will be accepted.
Constraints

1 ≤ T ≤ 1000
1 ≤ N ≤ 1000
1 ≤ M ≤ 1000

Example
Input:
2
2 2
1 6

Output:
3.000000
6.000000
Explanation
Example case 1
Probability matrix P for N=2, M=2 is
1.0 0.5
0.5 1.0
You are at (1, 1) initially. So the probablity of visiting (1, 1) is 1. At (1, 1) you have 2 options, move below to (2, 1) or to right cell (1, 2). Probablity of going to (1, 2) is 0.5. Probability of going to (2, 1) is 0.5. You always end up at (2, 2), so P[2][2] is 1. Required sum = 1.0 + 0.5 + 0.5 + 1.0 = 3.0
Example case 2
Probability matrix P for N=1, M=6 is
1.0 1.0 1.0 1.0 1.0 1.0
Because at any position there is only one possible next position. ",ANUTHM,S10373217,PYTH,"
    t = input()
    while():
    	t-=1
    	n,m=map(int,raw_input().split())
    	print n+m-1

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.

There are N+1 lights. Lights are placed at  (0, 0), (1, 0), (2, 0) ... (N, 0). Initially all the lights are on. You want to turn off all of them one after one.  You want to follow a special pattern in turning off the lights.


You will start at (0, 0). First, you walk to the right most light that is on, turn it off. Then you walk to the left most light that is on, turn it off. Then again to the right most light that is on and so on. You will stop after turning off all lights. You want to know how much distance you walked in the process. Note that distance between (a,0) and (b,0) is |a-b|.

Input
The first line of the input contains an integer T denoting the number of test cases. Each test case has a single integer N on separate line.

Output
For each test case, output the distance you walked.
Constraints

1 ≤ T ≤ 10^5
1 ≤ N ≤ 10^5

Example
Input
2
1
2

Output
2
5
Explanation
Testcase #2
You are initially at (0, 0)
Right most on-light is (2, 0). Distance = 2.
Now you are at (2, 0).
Left most on-light is (0, 0). Distance = 2.
Now you are at (0, 0)
Right most on-light is (1, 0). Distance = 1.
Now you are at (1, 0) and all lights are turned off.
Total distance walked = 5.
 ",ANUWTA,S10512902,PYTH,"
    T = int(raw_input())
    while T:
        N = int(raw_input())
        print N + (N*(N+1))/2
        T-=1
    

"
"
All submissions for this problem are available.
Chef has recently learnt some new facts about the famous number π. For example, he was surprised that ordinary fractions are sometimes used to represent this number approximately. For example, 22/7, 355/113 or even 103993/33102.
Soon, by calculating the value of 22/7 and 355/113 on paper Chef became quite disappointed because these values are not precise enough. For example, 22/7 differs in the third digit after the decimal point. So, these values are definitely should not be used for serious calculations.
However, Chef doesn't know anything about 103993/33102. This fraction is quite inconvenient to calculate on paper. Chef is curious how precise this value is. So he asks you to help him and to calculate the first K digits after the decimal point of such an approximation of π. He consider this ordinary fraction as infinite decimal fraction so formally he asks you to calculate this approximation truncated to the first K digits after the decimal point.
Input
The first line of the input contains an integer T, denoting the number of test cases. The description of T test cases follows. The only line of each test case contains a single integer K.
Output
For each test case output a single line containing the value of 103993/33102 truncated to the first K digits after the decimal point. Note that for K = 0 you should output just ""3"" without decimal point (quotes are for clarity).
Constraints

0 ≤ K ≤ 106
1 ≤ T ≤ 2000
The sum of K over the input does not exceed 106

Example

Input:
3
0
6
20

Output:
3
3.141592
3.14159265301190260407
Explanation
Example case 1. Here K = 0 so we don't need to output any digits after the decimal point. The decimal point itself also should not be output.
Example case 2. Note that here we truncate (not round) the actual value of 103993/33102 to 6 digits after the decimal point. As you see from example case 3 rounded value here differs from truncated one.
Example case 3. This example is only to show that this approximation of π is also far from perfect :)
",APPROX,S11890319,PYTH,"
    import sys
    t=input()
    p=103993.0/33102.0
    while t:
        k=input()
        if k==0:
            print 3
        else:
            l=103993%33102
            q=103993/33102
            j=1
            while j<=k:
                q=((l*10)/33102)*(10**j)+q
                l=(l*10)%33102
                j+=1
            q=str(q)[::-1]
            q=q[:1]+"".""+q[1:]
            print q
        
        t-=1
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese  and Russian.
You are given an array of N integers a1, a2, ..., aN and an integer K. Find the number of such unordered pairs {i, j} that 

i ≠ j
|ai + aj - K| is minimal possible

Output  the minimal possible value of |ai + aj - K| (where i ≠ j) and the number of such pairs for the given array and the integer K.
Input
The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
The first line of each test case consists of two space separated integers - N and K respectively.
The second line contains N single space separated integers - a1, a2, ..., aN respectively.

Output
For each test case, output a single line containing two single space separated integers - the minimal possible value of |ai + aj - K| and the number of unordered pairs {i, j} for which this minimal difference is reached.
Constraints

1 ≤ T ≤ 50
1 ≤ ai, K ≤ 109
N = 2 - 31 point.
2 ≤ N ≤ 1000 - 69 points.

 
Example
Input:
1   
4 9
4 4 2 6

Output:
1 4
Explanation:
The minimal possible absolute difference of 1 can be obtained by taking the pairs of a1 and a2, a1 and a4, a2 and a4, a3 and a4. ",APPROX2,S10497638,PYTH,"
    t=int(input())
    z=0
    while z<t:
        nk = str(input())
        n,k = nk.split(' ')
        a = str(input()).split(' ')
        i=0
        diff=int(k)
        count=0
        i=0
        print(t,n,k,a)
        while i<int(n):
            j=i
            while j<int(n):
                if abs(int(a[i])+int(a[j])-int(k))==diff:
                    count+=1
                if abs(int(a[i])+int(a[j])-int(k))<diff:
                    diff=abs(int(a[i])+int(a[j])-int(k))
                    count=0
                j+=1
            i+=1
        print(diff,count-1)
        z+=1
    

"
"
All submissions for this problem are available.
Byteland is a country located in the Archipelago of Rectangular Islands. The archipelago consists of 1<=n<=1000 islands. A fact that each island has a rectangular shape is very nice for Bytelandian cartographers. 

Bytelandian islands are rather small and none are very fertile, so each of the rectangular pieces of cultivated land is under special control, simply speaking: ‘never enter there if you value your life’. Other areas are guaranteed to be freely accessible for all people.

The communication between islands is possible by ferries. On each island there is 0<=b<=10 terminals, from where crossings to another terminals on other islands are possible.
It is known that total number of crossing connections is 0<=m<=100000. Other infrastructure is practically unknown. Specifically the only possible
way of traveling through  the island is to do it on foot. 

Well, now we are close to a task you are requested to solve. John – one of the Bytelandian citizens is working as a sales manager. He is often requested to travel from one place to another which he rather dislikes.  What he'd rather do is spend his time relaxing on the beach.  Please help him to find a way to spare his time.
Task
 Find the fastest ways for John to travel using ferries and foot paths on islands. Assume that while walking John is always moving one BM (Bytelandian unit of length) per BH  (Bytelandian unit of time).
You can also assume that the ferry departures nearly immediately after John arrives the terminal, it will be enough to round up the walking time to the nearest integer.
Input
In the first line t - the number of tests, then for each test:
in next line n - the number of islands. Description of each island is as follows:

name
w h [island dimensions]
b - [number of terminals]
[description of each terminal in a form:]
name x y [name of a terminal and its coordinates]
F [number of restricted areas F<20]
xl, yd, xr, yu [coordinates of each restricted area,
0 <=xl < xr<=250 0<=yd < yu<=250.]

All coordinates are nonnegative integers measured in BM according to upper left corner of an island.

You can assume that any two restricted areas are disjoint. After the description of all islands all ferry connections are given (each connection is bi-directional). 

m  [number of connections]
[description of each connection]
NB1 NW1 NB2 NW2 time [name of a first terminal, its island, the second respectively
and communiaction time]
...
[description follows]
...
NBS NWS NBC NWC [start and goal terminal for John]
Output

For each test describe the shortest route for John from terminal NBS on NWS island to terminal  NBC on NWC island in the following format:

case nr Y [nr - test number]
T [travel time in BH]
NBS  NWS
...
[consecutive terminals]
...
NBC NWC
[empty line]
[consecutive tests]

If two consecutive terminals are located on the same island and John must take some walk you must give all middle point like in an example.


Example

Input:
1
3
W1
8 7
2
Lindos 4 0
Kamejros 4 7
3
2 1 6 2
2 3 6 4 
2 5 6 6 
W2
14 12
2
Malia 14 1
Knossos 1 12
5
2 6 10 10
11 1 12 6
8 1 10 5
11 7 12 9
3 2 5 4
W3 
1 1
1
Korkyra 0 0
0
2
Kamejros W1 Knossos W2 100
Malia W2 Korkyra W3 100
Korkyra W3 Lindos W1

An example of a correct answer:

Output:
case 1 Y
230
Korkyra W3
Malia W2
12 6
11 7
10 10
Knossos W2
Kamejros W1
2 6
2 1
Lindos W1
 ",ARCHPLG,S4608386,PYTH,"
    import math
    import sys
    from collections import defaultdict
    from itertools import combinations
    
    class Graph:
      def __init__(self):
        self.nodes = set()
        self.edges = defaultdict(list)
        self.distances = {}
     
      def add_node(self, value):
        self.nodes.add(value)
     
      def add_edge(self, from_node, to_node, distance):
        self.edges[from_node].append(to_node)
        self.edges[to_node].append(from_node)
        self.distances[(from_node, to_node)] = distance
        self.distances[(to_node, from_node)] = distance
     
     
    def dijsktra(graph, initial):
      visited = {initial: 0}
      path = {}
     
      nodes = set(graph.nodes)
     
      while nodes: 
        min_node = None
        for node in nodes:
          if node in visited:
            if min_node is None:
              min_node = node
            elif visited[node] < visited[min_node]:
              min_node = node
     
        if min_node is None:
          break
     
        nodes.remove(min_node)
        current_weight = visited[min_node]
     
        for edge in graph.edges[min_node]:
          weight = current_weight + graph.distances[(min_node, edge)]
          if edge not in visited or weight < visited[edge]:
            visited[edge] = weight
            path[edge] = min_node
     
      return visited, path
    
    class Port:
        def __init__(self, name, x, y, island):
            self.name = name
            self.x = x
            self.y = y
            self.island = island
    
        def __eq__(self, other):
            return (isinstance(other, self.__class__)
                and self.__dict__ == other.__dict__)
    
        def __ne__(self, other):
            return not self.__eq__(other)
    
        def __hash__(self):
            return self.x + self.y
    
        def __repr__(self):
            return ' '.join((self.name, self.island))
    
    class Island:
        def __init__(self, name, w, h, ports, rects):
            self.name = name
            self.w = w
            self.h = h
            self.ports = ports
            self.rects = rects
    
        def __repr__(self):
            return str(self.__dict__)
    
    class IslandPoint:
        def __init__(self, x, y, island):
            self.x = x
            self.y = y
            self.island = island
    
        def __eq__(self, other):
            return (isinstance(other, self.__class__)
                and self.__dict__ == other.__dict__)
    
        def __ne__(self, other):
            return not self.__eq__(other)
    
        def __hash__(self):
            return self.x + self.y
    
        def __repr__(self):
            return ' '.join((str(self.x), str(self.y)))
    
    def testprint():
        return sys.stdin.readline().rstrip(' \r\n')
    
    #rdline = sys.stdin.readline
    rdline = testprint
    
    runs = int(rdline())
    
    def line_intersect(x00, y00, x10, y10, x01, y01, x11, y11):
        d = x11 * y01 - x01 * y11
        if d == 0:
            return False
    
        s = (1/d) * ((x00 - x10) * y01 - (y00 - y10) * x01)
        if not 0 <= s <= 1:
            return False
        t = (-1/d) * (-1 * (x00 - x10) * y11 + (y00 - y10) * x11)
        if not 0 <= t <= 1:
            return False
        else:
            return True
    
    def rect_intersect(x0, y0, x1, y1, rects):
        buf = .01
        result = False
        x1 = x1 - x0
        y1 = y1 - y0
        for rect in rects:
    	rectd = (rect[0] + buf, rect[1] - buf, rect[2] + buf, rect[3] - buf)
            result |= (line_intersect(x0,y0,rectd[0],rectd[2],x1,y1,rectd[1]-rectd[0],rectd[2]-rectd[2]) or
                line_intersect(x0,y0,rectd[0],rectd[2],x1,y1,rectd[0]-rectd[0],rectd[3]-rectd[2]) or
                line_intersect(x0,y0,rectd[0],rectd[3],x1,y1,rectd[1]-rectd[0],rectd[3]-rectd[3]) or
                line_intersect(x0,y0,rectd[1],rectd[2],x1,y1,rectd[1]-rectd[1],rectd[3]-rectd[2]) )
            if result: return True
        return result
    
    def distance_form(p0, p1):
        # return int(math.ceil( ( (p0.x-p1.x)**2 + (p0.y-p1.y)**2 ) ** (.5) ))
        # return round(( (p0.x-p1.x)**2 + (p0.y-p1.y)**2 ) ** (.5))
        return (((p0.x-p1.x)**2 + (p0.y-p1.y)**2 ) ** (.5))
    
    for i in xrange(runs):
        islands = {}
        island_graph = Graph()
        num_islands = int(rdline())
        for j in xrange(num_islands):
            is_name = rdline()
            w, h = map(int, rdline().split(' '))
            num_ports = int(rdline())
            ports = {}
            for k in xrange(num_ports):
                l = rdline().split(' ')
                pt_name = l[0]
                pt_x = int(l[1])
                pt_y = int(l[2])
                ports[pt_name] = Port(pt_name, pt_x, pt_y, is_name)
            num_rect = int(rdline())
            rects = []
            for k in xrange(num_rect):
                l = map(int, rdline().rstrip().split(' '))
                rects.append([l[0], l[2], l[1], l[3]])
            islands[is_name] = Island(is_name, w, h, ports, rects)
        num_connections = int(rdline())
        for j in xrange(num_connections):
            l = rdline().split(' ')
            p1, i1, p2, i2 = l[:-1]
            cost = int(l[-1])
            island_graph.add_edge(islands[i1].ports[p1], islands[i2].ports[p2], cost)
        for key in islands:
            island_is = islands[key]
            points = list()
            points.extend(island_is.ports[port] for port in island_is.ports)
            for rect in island_is.rects:
                points.extend(IslandPoint(x,y,island_is) for x in rect[0:2] for y in rect[2:]) 
            for p in points: island_graph.add_node(p)
            for p0, p1 in combinations(points, 2):
                if not rect_intersect(p0.x, p0.y, p1.x, p1.y, island_is.rects):
                    island_graph.add_edge(p0, p1, distance_form(p0,p1))
        p1, i1, p2, i2 = rdline().split(' ')
        visited, paths = dijsktra(island_graph, islands[i1].ports[p1])
        print ' '.join(('case', str(i + 1), 'Y'))
        print int(round(visited[islands[i2].ports[p2]]))
        node = paths[islands[i2].ports[p2]]
        path = [islands[i2].ports[p2]]
        while node:
            path.append(node)
            try:
                node = paths[node]
            except KeyError:
                break
        for j in reversed(path):
            print j
        print

"
"
All submissions for this problem are available.
Our amazing Chef recently met his best friend Joe at his place. Joe is a musician and owns a wide variety of musical instruments. He got introduced to the Arigeom beats in a music training session at Los Angeles. Arigeom beats, as the name suggests, is a combination of two series of beats. One of them has all its frequencies in arithmetic progression while the other series of beats has all its frequencies in geometric progression.
A series of beats is represented by a beat notation, which is the sequence of the frequencies at which the beats are played.
To play Arigeom beats, two digital musical instruments are played simultaneously in front of an instrument known as Sono Phone. One instrument plays the beats in arithmetic progression while the other instrument plays the beats in geometric progression. Sono Phone will capture the beats played by each of the two instruments and process them into Arigeom beats. It will merge the beats, sort the beats in ascending order, and remove duplicate beats.
For example, suppose one instruments plays the following beats notation: (2, 5, 8, 11), an arithmetic progression, while the other plays (2, 4, 8, 16), a geometric progression. The resulting Arigeom beat notation recorded by Sono Phone will be (2, 4, 5, 8, 11, 16).
Because Joe knows how to play Arigeom beats, owns the instruments, and has his friend Chef with him as well, he can't wait anymore to play the beats. Joe has an Arigeom beat notation from his music book and decides that he would play the beats in arithmetic progression while Chef will play the beats in geometric progression. The beat notation consists of N beat frequencies F1, F2, ..., FN. However, he is now confused as to which subset of the beats has to be played by Chef and which one by himself.
Help Joe and Chef figure out the subsets of beats to be played by Joe and Chef.
Input
The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows. For each test case, the first line contains an integer N. The second line contains N space-separated integers F1, F2, ..., FN.
Output
For each test case, output two lines. The first line contain the beat notation to be played by Joe (in arithmetic progression). The second line contain the beat notation to be played by Chef (in geometric progression). Each beat notation must contain at least two beats. The beats in each beat notation must be sorted in ascending order.
If there are more than one possible pair of beat notations, output any one of them.
Constraints

1 ≤ T ≤ 100 2 ≤ N ≤ 10,000 1 ≤ Fi ≤ 100,000F1 < F2 < ... < FNIt is guaranteed that at least one pair of valid beat notations exists.

Example

Input:
462 4 5 8 11 1651 2 3 4 581 3 9 10 19 27 28 8161 4 7 10 13 25

Output:
2 5 8 112 4 8 161 2 3 4 51 2 41 10 19 281 3 9 27 811 7 134 10 25
",ARIGEOM,S8934585,PYTH,"
    import sys
    
    def dfs(d,r,prevA,prevG,curLevel):
      
      if (curLevel>=len(beats)): return None
      curNum = beats[curLevel]
      newd = d
      newr = r
      
      # Will current number go in both lists?
      if(d == 0 and prevA != None): newd = curNum - prevA
      if(r == 0 and prevG != None): newr = (1.0*curNum)/prevG
      
      if((prevA == None or prevA+newd == curNum) and (prevG == None or int(prevG*newr) == curNum)):
        
        # TODO : Success check
        if(curLevel == len(beats)-1): return(newd,newr,curNum,curNum)
        ret = dfs(newd,newr,curNum,curNum,curLevel+1)
        if(ret != None): return ret
      
      # Will current number go in A list?
      newd = d
      newr = r
      if(d == 0 and prevA != None): newd = curNum - prevA
      if(prevA == None or prevA+newd == curNum):
        # TODO : Success check
        if(curLevel == len(beats)-1): return(newd,newr,curNum,prevG)
        ret = dfs(newd,newr,curNum,prevG,curLevel+1)
        if(ret != None): return ret
      
      # Will current number go in G list?
      newd = d
      newr = r
      if(r == 0 and prevG != None): newr = (1.0*curNum)/prevG
      if(prevG == None or int(prevG*newr) == curNum):
        # TODO : Success check
        if(curLevel == len(beats)-1): return(newd,newr,prevA,curNum)
        ret = dfs(newd,newr,prevA,curNum,curLevel+1)
        if(ret != None): return ret
    
      return None
    
    input = [l for l in sys.stdin]
    T = int(input[0].strip())
    for t in xrange(T):
      N = int(input[(t*2)+1].strip())
      beatsLine = input[(t*2)+2].strip()
      beats = [int(b) for b in beatsLine.split()]
      
      sol = dfs(0,0,None,None,0)

"
"
All submissions for this problem are available.

The Chef has prepared the appetizers in the shapes of letters to spell a special message for the guests. There are n appetizers numbered from 0 to n-1 such that if the appetizers are arrayed in this order, they will display the message. The Chef plans to display them in this order on a table that can be viewed by all guests as they enter. The appetizers will only be served once all guests are seated.

The appetizers are not necessarily finished in the same order as they are numbered. So, when an appetizer is finished the Chef will write the number on a piece of paper and place it beside the appetizer on a counter between the kitchen and the restaurant. A server will retrieve this appetizer and place it in the proper location according to the number written beside it.

The Chef has a penchant for binary numbers. The number of appetizers created is a power of 2, say n = 2k. Furthermore, he has written the number of the appetizer in binary with exactly k bits. That is, binary numbers with fewer than k bits are padded on the left with zeros so they are written with exactly k bits.

Unfortunately, this has unforseen complications. A binary number still ""looks"" binary when it is written upside down. For example, the binary number ""0101"" looks like ""1010"" when read upside down and the binary number ""110"" looks like ""011"" (the Chef uses simple vertical lines to denote a 1 bit). The Chef didn't realize that the servers would read the numbers upside down so he doesn't rotate the paper when he places it on the counter. Thus, when the server picks up an appetizer they place it the location indexed by the binary number when it is read upside down.

You are given the message the chef intended to display and you are to display the message that will be displayed after the servers move all appetizers to their locations based on the binary numbers they read.
Input

The first line consists of a single integer T ≤ 25 indicating the number of test cases to follow. Each test case consists of a single line beginning with an integer 1 ≤ k ≤ 16 followed by a string of precisely 2k characters. The integer and the string are separated by a single space. The string has no spaces and is composed only of lower case letters from `a` to `z`.
Output

For each test case you are to output the scrambled message on a single line.
Example

Input:
2
2 chef
4 enjoyourapplepie

Output:
cehf
eayejpuinpopolre

",ARRANGE,S10017776,PYTH,"
    def binInt(n):
            b = bin(n)[2:].zfill(k)
            r = b[::-1]
            return [int(b,2),int(r,2)]
    
    
    for _ in range(input()):
            k,s = raw_input().strip().split()
            k = int(k)
            sl = [i for i in s]
            l = [0] * (2**k)
    
            for i in range(2**k):
                    b,r = binInt(i)
                    if l[b] == 0 or l[r] == 0:
                            sl[b],sl[r] = sl[r],sl[b]
                            l[b] = 1
                            l[r] = 1
            print """".join(sl)

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese , Russian and Vietnamese as well.
You are given an array A, consisting of N integers and an array B, consisting of M integers.
The subsequence of A is the array that can be obtained by picking the elements at the arbitrary sorted set of positions from A.
Your task is to count the number of such subsequences C of A that:

C contains exactly M elements.
The array (C+B) is non-decreasing. Here by + operation, we mean element-wise sum. 
For example, the array (4, 8, 5) plus the array (10, 20, 30) is (14, 28, 35).
Formally, (C+B) is an array of size M such that (C+B)i = Ci + Bi.

In case some subsequence appears more that once, you should counts it as many times as it appears.
Formally, two subarrays of an array a, (ai_1, ai_2, ... ,ai_n) and (aj_1, aj_2, ... ,aj_m) will be considered different if either their lengths are different i.e. n != m or there exists an index k such that such that i_k  != j_k.

Since the answer can be very large, we ask you to calculate it, modulo 109+7.
Input
The first line of input contains a pair of space separated integers N and M, denoting the number of elements in the array A and the number of elements in the array B.
The second line contains N space-separated integers Ai, denoting the array A.
The third line contains M space-separated integers Bj, denoting the array B.
Output
Output a single line containing the number of subsequences C as asked in the problem, modulo 109+7.
Constraints

1 ≤ Ai, Bi ≤ 109
1 ≤ M ≤ N

Subtasks

Subtask #1 (33 points): 1 ≤ N ≤ 50, 1 ≤ M ≤ 5
Subtask #2 (33 points): 1 ≤ N ≤ 500, 1 ≤ M ≤ 50
Subtask #3 (34 points): 1 ≤ N ≤ 2000, 1 ≤ M ≤ 1000

Example

Input #1:
5 3
1 5 2 4 7
7 9 6

Output #1:
4

Input #2:
4 2
7 7 7 7
3 4

Output #2:
6
Explanation
Example case 1. The suitable subsequences are (1, 2, 7), (1, 4, 7), (5, 4, 7), (2, 4, 7).
Example case 2. The suitable subsequence is (7, 7), and it appears 6 times:

at indices (1, 2)
at indices (1, 3)
at indices (1, 4)
at indices (2, 3)
at indices (2, 4)
at indices (3, 4)

So, the answer is 6. ",ARRAYSUM,S9817144,PYTH,"
    M = 10**9 + 7
    def arraysSum():
    	n, m = map(int, raw_input().split())
    	a = map(int, raw_input().split())
    	b = map(int, raw_input().split())
    	dp = [[0 for i in range(m+1)] for j in range(n)]
    	for i in range(n):
    		dp[i][1] = 1
    	for i in range(n):
    		for j in range(i):
    			for k in range(2, m+1):
    				if a[i] + b[k-1] >= a[j] + b[k-2]:
    					dp[i][k] = (dp[i][k] + dp[j][k-1]) % M
    
    	result = 0
    	for i in range(n):
    		result += dp[i][m]
    	print result
    
    arraysSum()
    
    				
    

"
"
All submissions for this problem are available.

Given n numbers, you can perform the following operation any number of times : Choose any subset of the numbers (possibly empty), none of which are 0. Decrement the numbers in the subset by 1, and increment the numbers not in the subset by K.


Is it possible to perform operations such that exactly n - 1 numbers become 0 ?


Input :


The first line contains the number of test cases T. 2*T lines follow, 2 for each case. The first line of a test case contains the numbers n and K. The next line contains n numbers, a_1...a_n.


Output :


Output T lines, one corresponding to each test case. For a test case, output ""YES"" if there is a sequence of operations as described, and ""NO"" otherwise.


Sample Input :
3
2 1
10 10
3 2
1 2 2
3 2
1 2 3


Sample Output :
YES
YES
NO


Constraints :
1 <= T <= 1000
2 <= n <= 100
1 <= K <= 10
0 <= a_i <= 1000
 ",ARRAYTRM,S11192882,PYTH,"
    def solution():
        T = int(raw_input().strip())
        for i in xrange(T):
            n, k = map(int, raw_input().strip().split(' '))
            arr = list(map(int, raw_input().strip().split(' ')))
            rem_1 = arr[0]%(k+1)
            rem_2 = -1
            count_1 = 0
            count_2 = 0
    
            for i in xrange(n):
                if arr[i]%(k+1) == rem_1:
                    count_1 += 1
                else:
                    if arr[i]%(k+1) == rem_2:
                        count_2 += 1
                    else:
                        if rem_2 == -1:
                            rem_2 = arr[i]%(k+1)
                            count_2 += 1
                        else:
                            break
            if i < n - 1:
                print ""NO""
            else:
                if count_1 == n-1 or count_2 == n-1 or count_1 == n:
                    print ""YES""
                else:
                    print ""NO""
    
    
    solution()

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese here
Problem Statement
Little Chef doesn't love math anymore. He loves Aleksandra.


Sashen'ka is nice. They spend all the time together. Even their birthdays they are celebrating together, because they were born on the same day :)


And now, this day is coming...


Chef know that most of all Sasha loves numbers, that's why he bought N positive numbers to a girl.
From her side, Sasha as all girls, thought that if she likes something, then all people like that too. And bought to a boy N numbers too. xD
After all greeting young people decide to play a game with their gifts. The game will be continued for N turns, in each turn the following will be done:
Chef randomly choose some number x from his gift.
Sasha randomly choose some number y form her gift.
If xy > yx then girl will kiss fellow.
Numbers x,y will be discarded from gifts.
Now chef is wondering what is the expected number of times he will be kissed by Sasha ?

 
Input
The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
The first line of each test case contains a single integer N denoting the number of numbers in each gift. The second line contains N space-separated integers A1, A2, ..., AN denoting the numbers Sasha gave to Chef. Next line describe B1, B2, ..., BN numbers boy gave to girl in the same way. 
 
Output
For each test case, output a single line containing answer for corresponding test. Your answer will be considered as correct if it will have absolute error not more then 10-6.
 
Constraints
1 ≤ T ≤ 5
1 ≤ N ≤ 105
1 ≤ Ai ≤ 109
1 ≤ Bi ≤ 109
 
Example

Input
3
1
3
4
2
2 3
1 4
2
2 4
2 2

Output:
1.000000
1.500000
0.000000


 
Explanation
Example case 1. Game will have only 1 turn. Chef will choose 3, while Sasha will choose 4. Since 34>43 girl will kiss boy. Hence answer is 1.  ",ARRGAME2,S10060074,PYTH,"
    for _ in range(int(raw_input())):
        n = int(raw_input())
        girl = [raw_input() for __ in range(n) ]
        boy = [raw_input() for __ in range(n) ]
        count = 0
        
        for i in range(n):
            if girl[i]^boy[i] > boy[i]^girl[i]:
                count += 1
        print count
        

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese  and Russian.
Suraj, the Chief Prankster is back in action now and this time he has stolen the valentine's day gift given by Ashi (the love of Chef) to the Chef and ran away with it to Byteland.
Byteland is a not a regular place like Chef's town. The safest way from Chef's town to Byteland is through the path of tasty dishes. The path is named so because there are magical tasty dishes which appear to the traveler that no one can resist eating. Also, Suraj has added a strong sleep potion to each of the dish on this path to stop anyone from following him.
Knowing the devilish nature of Suraj, Ashi is concerned about the Chef and has asked all of Chef's town people to help. The distance from Chef's town to Byteland through the the path of tasty dishes is X units. They have the location where the magic dishes are and how many people are required to eat it completely. Anyone who eats a dish would go to a long sleep and won't be able to continue. They have the information about the tribal clans that live along the the path of tasty dishes who can be of real help in this journey. 
The journey Chef and his friends can be described as follows: There is a total of B dishes on the path of tasty dishes. Each dish is located at some distance from Chef's town denoted by xi for the ith dish ( xi-1 <  xi). To minimize the number of friends Chef has to leave behind, all of them have decided that exactly yi of them will eat the ith dish, which is the required number of people needed to finish it completely. Also, there are a total of C tribal chef clans, each with their own population and location on the path that Chef and his friends will meet on their way to Byteland. They know that for some clan (say i), they are located at a distance of pi ( pi-1 <  pi) from Chef's town with a population of ri. And if a group of at least qi men approaches them, they would be able to convince them to join their forces against Suraj.
Given the information about all this, help the Chef to find out the minimum size of the group (including him and his friends) he should start with to reach Byteland and get back Ashi's gift from Suraj.
Input
The first line of the input contains an integer T denoting the number of test cases. Each test case contains three lines which are as follows:
First line of each test case contains X, the distance of Byteland from Chef's town.
Next line contains an integer B, the number of dishes on the path of tasty dishes. Then follows B pairs of space separated integers of the form xi yi, where xi yi are as defined above for the ith dish.
Next line contains an integer C, followed C space separated triplets of integers pi qi ri as defined above.
Output
For each test case, print the minimum size of the group  (including Chef) that is needed to reach Byteland.
Constraints

1 ≤ T ≤ 10
1 ≤ X ≤ 109
1 ≤ B ≤ 10000
 Constraints on C

Subproblem 1 (25 points):  C = 0
Subproblem 2 (75 points): 1 ≤ C ≤ 10000


1 ≤ xi < X, xi < xi+1
1 ≤ pi < X, pi < pi+1
1 ≤ yi ≤ 1014
1 ≤ qi ≤ 1014
1 ≤ ri ≤ 1014
All the positions, of the tasty dishes and tribal clans are distinct.

Example
Input:
3
10
2 1 3 8 1
0
10
2 1 3 8 5
0
10
2 2 3 8 5
3 1 2 1 4 3 2 9 1 1 

Output:
5
9
6

Explanation
Example case 1. In the first case, there are no tribal clans, and two dishes, one which needs to be eaten by 3 chefs on their way and one to be eaten by 1 chef. Hence, we have to start with atleast 5 people in total to pass the path of tasty dishes.
Example case 2. Similar as Example Case 1.
Example case 3. In this case, if we start with 5 Chefs. At point 1, we have more than or equal to 2 chefs, hence the tribal clan of size 1 adds to the Chef's party and now they have size of 6. At position 2, three of them would be left behind eating a dish, leaving 3 of them to go ahead. At position 4, since the size is exactly 3, the tribal clan joins the chef's party making it of size 5. At position 8, all 5 of them will stop to eat the dish and none would go ahead. Similarly, if we start with 6, one of them would be able to pass position 8 and reach position 9, where it will also add one of the tribal clans to its party and reach Byteland. ",ASHIGIFT,S6595323,PYTH,"
    t=int(input())
    while(t>0):
    	x=int(input())
    	s=raw_input().split()
    	fdpt=int(s[0])
    	if(fdpt!=0):
    		s=s[1:]
    	xp=[]
    	i=0
    	while(i<fdpt):
    		xp.append([int(s[2*i]),int(s[2*i+1])])
    		i+=1
    	s=raw_input().split()
    	xp.append([10**9+1,1])
    	xp.sort()
    	tpt=int(s[0])
    	if(tpt!=0):
    		s=s[1:]
    	tp=[]
    	tq=[]
    	i=0
    	while(i<tpt):
    		tp.append([int(s[3*i]),int(s[3*i+2])])
    		tq.append([int(s[3*i]),int(s[3*i+1])])
    		i+=1
    	tp.append([10**9+1,1])
    	tp.sort()
    
    	tq.append([10**9+1,0])
    	tq.sort()
    	low=1
    	high=10**30
    	ans=10**30
    	while(low<=high):
    				
    		mid = (low+high)/2
    		tmp=mid
    		no=0
    		i=0
    		tpi=0
    		xpi=0
    		
    		while(tp[tpi][0]!=10**9+1 or xp[xpi][0]!=10**9+1):
    			if(xp[xpi][0]<tp[tpi][0]):
    				tmp-=xp[xpi][1]
    				xpi+=1
    			else:
    				if(tq[tpi][1]<=tmp):
    					tmp+=tp[tpi][1]
    				tpi+=1
    			if(tmp<=0):
    				no=1
    				break
    		if(no==0):
    			ans=mid
    			high=mid-1
    		else:
    			low=mid+1
    
    	print ans
    			
    	
    	t-=1
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.

Given a sequence of n distinct numbers a[1..n], we want to sort them in an ascending order.


An interesting property of some sequences is that all numbers are almost at their correct position! More formally, the distance between the current position of any value is at most 1 from its correct position in a sorted order.


Now, you want to verify whether the input sequence has such a property.


Note that the time limit for this problem is 0.2 seconds. Please try to write a very efficient algorithm and implementation.

Input
The first line contains an integer T denoting the total number of test cases.
For each test case, the first line contains a single integer n, and the second line contains a[1..n] as a single space-separated list.
Output
For each test case, output ""YES"" or ""NO"" (without quotes) to indicate whether the input sequence has such a property.
Constraints

1 <= T <= 10
1 <= n <= 10^6
1 <= a[i] <= 10^9

Example
Input:
2
3
1 2 3
5
2 4 1 3 5
Output:
YES
NO
 ",ASP,S10529727,PYTH,"
    T = int(raw_input(""""))
    for t in xrange(0,T):
    	N = int(raw_input(""""))
    	mylist = map(int,raw_input("""").split())
    	templist = mylist
    	mylist.sort()
    	flag = True
    	for idx, item in enumerate(templist):
    		if( abs(idx - templist.index(item)) > 1 ):
    			print ""NO""
    			flag = False
    			break
    	if flag:
    		print ""YES""

"
"
All submissions for this problem are available.
Teddy and Tracy like to play a game based on strings. The game is as follows. Initially, Tracy writes a long random string on a whiteboard. Then, each player starting with Teddy makes turn alternately. Each turn, the player must erase a contiguous substring that exists in the dictionary. The dictionary consists of N words.
Of course, the player that can't erase any substring in his turn loses the game, and the other player is declared the winner.
Note that after a substring R is erased, the remaining substring becomes separated, i.e. they cannot erase a word that occurs partially to the left of R and partially to the right of R.
Determine the winner of the game, assuming that both players play optimally.
Input
The first line contains a single integer T, the number of test cases. T test cases follow. The first line of each testcase contains a string S, the string Tracy writes on the whiteboard. The next line contains a single integer N. N lines follow. The i-th line contains a single string wi, the i-th word in the dictionary.
Output
For each test case, output a single line containing the name of the winner of the game.
Example

Input:
3
codechef
2
code
chef
foo
1
bar
mississippi
4
ssissi
mippi
mi
ppi

Output:
Tracy
Tracy
Teddy
Constraints

1 <= T <= 5
1 <= N <= 30
1 <= |S| <= 30
1 <= |wi| <= 30
S and wi contain only characters 'a'-'z'

",ASTRGAME,S10867784,PYTH,"
    #print 'mississippi'.split('ssissi')
    t=int(raw_input())
    for z in xrange(t):
        s=raw_input()
        arr,dic=[],[]
        arr.append(s)
        n=int(raw_input())
        for i in xrange(n):
            dic.append(raw_input())
        counter=0
        for i in xrange(len(dic)):
            for j in xrange(len(arr)):
                if dic[i] in arr[j]:
                    x=arr[j].split(dic[i])
                    arr.pop(j)
                    for k in xrange(len(x)):
                        if len(x[k])>0:
                            arr.append(x[k])
                    counter+=1
                    break
        if counter%2==0:
            print ""Tracy""
        else:
            print ""Teddy""

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese , Russian and Vietnamese as well.
Akhil comes across a string S of length N. He started wondering about the smallest lexicographical subsequence of string S of length K.
A subsequence of a string is formed by deleting some characters (possibly none) from it's original string.
A string A is said to be lexicographically smaller than the string B of the same length if at the first position where A and B differ, A contains a letter which appears earlier in the dictionary than the corresponding letter in B.
Input

The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows:
First line of each test case will contain string S
Second line of each test case will contain an integer K.

Output

For each test case, output a single line containing the lexicographically smallest subsequence of S of length K.

Constraints

1 ≤ T ≤ 5
1 ≤ K ≤ N
S consists of lowercase English alphabet characters, i.e. from 'a' to 'z'.

Subtasks
Subtask #1 (10 points) : 1 ≤ |S| ≤ 100
Subtask #2 (20 points) : 1 ≤ |S| ≤ 103
Subtask #3 (70 points) : 1 ≤ |S| ≤ 105
Example
Input:
2
abdc
3
bacb
2

Output:
abc
ab
Explanation
Example case 1. ""abc"" is the smallest lexicographical subsequence out of [""abd"", ""bdc"", ""abc"", ""adc""].
Example case 2. ""ab"" is the smallest lexicographical subsequence of length 2. ",ASTRING,S10211218,PYTH,"
    # cook your code here
    t=int(raw_input())
    for z in range(t):
        s=raw_input()
        k=int(raw_input())
        l=[]
        for i in s:
            l.append(i)
        l.sort()
        g=[]
        final=""""
        for i in range(k,len(l)):
            g.append(l[i])
        for i in s:
            if(i in g):
                g.remove(i)
            else:
                final+=i;
        print final

"
"
All submissions for this problem are available.

Let X be the set of all integers between 0 and n-1. Suppose we have a collection S1, S2, ..., Sm of subsets of X. Say an atom A is a subset of X such that for each Si we have either A is a subset of Si or A and Si do not have any common elements.

Your task is to find a collection A1, ..., Ak of atoms such that every item in X is in some Ai and no two Ai, Aj with i ≠ j share a common item. Surely such a collection exists as we could create a single set {x} for each x in X. A more interesting question is to minimize k, the number of atoms.
Input

The first line contains a single positive integer t ≤ 30 indicating the number of test cases. Each test case begins with two integers n,m where n is the size of X and m is the number of sets Si. Then m lines follow where the i'th such line begins with an integer vi between 1 and n (inclusive) indicating the size of Si. Following this are vi distinct integers between 0 and n-1 that describe the contents of Si.

You are guaranteed that 1 ≤ n ≤ 100 and 1 ≤ m ≤
30. Furthermore, each number between 0 and n-1 will appear in at least one set Si.
Output

For each test case you are to output a single integer indicating the minimum number of atoms that X can be partitioned into to satisfy the constraints.
Example

Input:
2
5 2
3 0 1 2
3 2 3 4
4 3
2 0 1
2 1 2
2 2 3

Output:
3
4

",ATOMS,S11246680,PYTH,"
    t=input()
    while(t>0):
    	t-=1
    	n,m=map(int,raw_input().split())
    	arr=[0]*n;s=[[[] for i in range(0)]for j in range(m)]
    	i=0;j=0;k=0
    	while(i<m):
    		arr1=map(int,raw_input().split())
    		j=0
    		while(j<arr1[0]):
    			arr[arr1[1+j]]+=1
    			s[i].append(arr1[j+1])
    			j+=1
    		i+=1
    	#print 
    	#print ""arr1"",arr
    	#print s
    	#print 
    
    	i=0;sum1=0
    	while(i<n):
    		if(arr[i]>1):
    			sum1+=1
    			arr[i]=0
    		i+=1
    
    	#print ""arr2"",arr
    
    	sum2=[0]*m;i=0;j=0
    
    	while(i<n):
    		if(arr[i]==1):
    			j=0
    			while(j<m):
    				k=0
    				while(k<len(s[j])):
    					if(i==s[j][k]):
    						sum2[j]=1
    					k+=1
    				j+=1
    		i+=1
    
    	print sum1+sum(sum2)

"
"
All submissions for this problem are available.

Digory Kirke and Polly Plummer are two kids living next door to each other. The attics of the two houses are connected to each other through a passage. Digory's Uncle Andrew has been secretly doing strange things in the attic of his house, and he always ensures that the room is locked. Being curious, Digory suspects that there is another route into the attic through Polly's house, and being curious as kids always are, they wish to find out what it is that Uncle Andrew is secretly up to.


So they start from Polly's house, and walk along the passageway to Digory's. Unfortunately, along the way, they suddenly find that some of the floorboards are missing, and that taking a step forward would have them plummet to their deaths below.


Dejected, but determined, they return to Polly's house, and decide to practice long-jumping in the yard before they re-attempt the crossing of the passage. It takes them exactly one day to master long-jumping a certain length. Also, once they have mastered jumping a particular length L, they are able to jump any amount less than equal to L as well.


The next day they return to their mission, but somehow find that there is another place further up the passage, that requires them to jump even more than they had practiced for. So they go back and repeat the process.


Note the following:

 At each point, they are able to sense only how much they need to jump at that point, and have no idea of the further reaches of the passage till they reach there. That is, they are able to only see how far ahead is the next floorboard. 
 The amount they choose to practice for their jump is exactly the amount they need to get across that particular part of the passage. That is, if they can currently jump upto a length L0, and they require to jump a length L1(> L0) at that point, they will practice jumping length L1 that day. 
 They start by being able to ""jump"" a length of 1. 


Find how many days it will take them to cross the passageway. In the input, the passageway is described as a string P of '#'s and '.'s. A '#' represents a floorboard, while a '.' represents the absence of a floorboard. The string, when read from left to right, describes the passage from Polly's house to Digory's, and not vice-versa.

Input

The first line consists of a single integer T, the number of testcases.
Each of the next T lines consist of the string P for that case.

Output

For each case, output the number of days it takes them to cross the passage.

Constraints

 1  ≤ T  ≤ 1,000,000  (106)
 1  ≤ |P|  ≤ 1,000,000 (106)
 The total length of P will be ≤ 5,000,000 (5 * 106)across all test-cases of a test-file 
 P will consist of only the characters # and . 
 The first and the last characters of P will be #. 

Example

Input:
4
####
##.#..#
##..#.#
##.#....#

Output:
0
2
1
2
Explanation

For the first example, they do not need to learn any jump size. They are able to cross the entire passage by ""jumping"" lengths 1-1-1.


For the second example case, they get stuck at the first '.', and take one day learning to jump length 2. When they come back the next day, they get stuck at '..' and take one day to learn to jump length 3.


For the third example case, they get stuck first at '..', and they take one day to learn to jump length 3. On the second day, they are able to jump both length 3 as well as length 2 required to cross the passage.


For the last test case they need to stop and learn jumping two times. At first they need to jump a length 2 and then a length 5.

Appendix

Irrelevant to the problem description, if you're curious about what Uncle Andrew was up to, he was experimenting on Magic Rings that could facilitate travel between worlds. One such world, as some of you might have heard of, was Narnia.

",ATTIC,S12059418,PYTH,"
    t=input()
    while t:
        s=raw_input()
        s=s.split(""#"")
        x=[]
        for i in s:
            n=i.count(""."")
            if n>0:
                x.append(n)
        if x==[]:
            t-=1
            print 0
            continue
        d=1
        m=x[0]
        for i in x:
            if m<i:
                m=i
                d+=1
        print d
        t-=1
    

"
"
All submissions for this problem are available.
Today Tomya buys N retort pouches of food in Chef Ciel's restaurant. The i-th retort pouch contains Vi units of food, and its use-by date is the Ui-th day (1-origin). Moreover, food from the i-th retort pouch can be eaten only within Li days after it was opened. Namely, if Tomya will open the i-th retort pouch on the xi-th day, she can eat food units from it on the k-th day if and only if xi ≤ k ≤ min(Ui, xi+Li−1).
The retort pouches in Ciel's restaurant are designed in such a way that if Vi < Vj, then Ui ≤ Uj.
Tomya will eat at most two units of food everyday. However after the min(Ui, xi+Li−1)-th day, uneaten food units in the i-th retort pouch must be discarded. Your task is to decide when to open each of the retort pouches and which food unit(s) to eat each day in such a way that the number of discarded units will be minimum.
There is also a restriction that once you open some pouch, food units from previously opened pouches should be discarded.
The above restriction is an addition to the problem statement that was made after the contest. We are extremely sorry about that. We all had missed the possibility to achieve better score without this restriction in some situations. We are grateful to Mikhail Kever for pointing out our mistake.
Input
The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
The first line of each test case contains an integer N denoting the number of retort pouches.
Each of the following N lines contains 3 space separated integers Vi, Ui, Li denoting the parameters of the i-th pouch.
Output
For each test case, output a single line containing the minimum number of food units which Tomya must discard.
Constraints

1 ≤ T ≤ 2013
1 ≤ N ≤ 2013
1 ≤ Vi, Ui, Li ≤ 20000000000000 (2 * 1013)
If Vi < Vj, then Ui ≤ Uj
The sum of N in one test file does not exceed 20130.

Example

Input:
3
3
8 9 5
7 5 3
10 100 1
3
5 4 3
7 8 5
8 10 4
1
10000 1 10000

Output:
9
0
9998
Explanation
Example case 1. One of the optimal ways is the following:The 1st pouch is opened on the day x1 = 4,the 2nd pouch is opened on the day x2 = 1,the 3rd pouch is opened on the day x3 = 8,thenthe 1st pouch is available at the interval [4, 8],the 2nd pouch is available at the interval [1, 3],the 3rd pouch is available at the interval [8, 8].On days 1, 2, 3, Tomya eats 2 units of the 2nd pouch each day.On days 4, 5, 6, 7 Tomya eats 2 units of the 1st pouch each day.On day 8, Tomya eats 2 units of the 3rd pouch.In this case, Tomya discard the 1 unit of the 1st pouch, and 8 units of the 3rd pouch.
Example case 2. There is only one optimal way as follows:The 1st pouch is opened on the day x1 = 1,the 2nd pouch is opened on the day x2 = 3,the 3rd pouch is opened on the day x3 = 7,thenthe 1st pouch is available at the interval [1, 3],the 2nd pouch is available at the interval [3, 7],the 3rd pouch is available at the interval [7, 10].On days 1, 2, Tomya eats 2 units of the 1st pouch each day.On day 3, Tomya eats 1 unit of the 1st pouch and 1 unit of the 2nd pouch.On days 4, 5, 6, Tomya eats 2 units of the 2nd pouch each day.On days 7, 8, 9, 10, Tomya eats 2 units of the 3rd pouch each day.In this case, Tomya can eat all units of food.
Example case 3. Please note that here L1 is larger than U1.
",AVDWAST,S4713291,PYTH,"
    no_of_inputs = input()
    
    i0 = []
    for i1 in range(no_of_inputs):
    	i0.append(input())
    
    def prime(x):
        for i12 in range(2, x-1):
            if x % i12 == 0:
                return False
        else:
            return True
    
    def LC(i2):
    	if (i2 <= 1000):
    		return i2
    	else:
    		LC_main(i2)
    
    def sum_of_digits(i5):
    	i7 = 0
    	for i6 in str(i5):
    		i7 = i7+int(i6)
    	return i7
    
    def check_coolness(i4):
    	if (i4 <= 1000):
    		return True
    	else:
    		i9 = i4
    		for i8 in range(2,sum_of_digits(i4)):
    			if prime(i8):
    				while (i9%i8 == 0):
    					i9 = i9/i8
    		if (i9 != 1):
    			return False
    		else:
    			for i10 in range(0,27):
    				if (((((sum_of_digits(i4)-i10))%i4)**i10)%i4 == 0):
    					return True
    			return False
    
    def LC_main(i2):
    	j0 = len(str(i2))-3
    	i3 = i2 #int(str(i2)[:3])*(10**(j0))
    	while i3 >= int(str(i2)[:3])*(10**(j0)):
    		if check_coolness(i3):
    			return i3
    		i3 = i3-1
    	return i3+1
    
    def UC_main(i11):
    	j0 = len(str(i11))-3
    	i12 = i11 + 1
    	while i12 <= (int(str(i11)[:3])+1)*(10**(j0)):
    		if check_coolness(i12):
    			return i12
    		i12 = i12+1
    	return i12-1
    
    for las in i0:
    	print LC_main(las),UC_main(las)
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
There are a lot of problems related to the shortest paths. Nevertheless, there are not much problems, related to the shortest paths in average.
Consider a directed graph G, consisting of N nodes and M edges. Consider a walk from the node A to the node B in this graph. The average length of this walk will be total sum of weight of its' edges divided by number of edges. Every edge counts as many times as it appears in this path.
Now, your problem is quite simple. For the given graph and two given nodes, find out the shortest average length of the walk between these nodes. Please note, that the length of the walk need not to be finite, but average walk length will be.
Input
The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
The first line of each test case contains a pair of space-separated integers N and M denoting the number of nodes and the number of edges in the graph.
Each of the following M lines contains a triple of space-separated integers Xi Yi Zi, denoting the arc, connecting the node Xi to the node Yi (but not vice-versa!) having the weight of Zi.
The next line contains a pair of space separated integers A and B, denoting the first and the last node of the path.
Output
For each test case, output a single line containing the length of the shortest path in average.
If there is no path at all, output just -1 on the corresponding line of the output.
Constraints

1 ≤ N ≤ 500
1 ≤ M ≤ 1000
A is not equal to B
1 ≤ A, B, Xi, Yi ≤ N
1 ≤ Zi ≤ 100
There are no self-loops and multiple edges in the graph.
1 ≤ sum of N over all test cases ≤ 10000
1 ≤ sum of M over all test cases ≤ 20000

Subtasks

Subtask #1 (45 points): 1 ≤ N ≤ 10, 1 ≤ M ≤ 20; Your answer will be considered correct in case it has an absolute or relative error of no more than 10-2.
Subtask #2 (55 points): no additional constraints; Your answer will be considered correct in case it has an absolute or relative error of no more than 10-6.

Example
Input:
2
3 3
1 2 1
2 3 2
3 2 3
1 3
3 3
1 2 10
2 3 1
3 2 1
1 3

Output:
1.5
1.0

Explanation
Example case 1. The walk 1 -> 2 and 2 -> 3 has average length of 3/2 = 1.5. Any other walks in the graph will have more or equal average length than this. ",AVGSHORT,S11276488,PYTH,"
    for t in xrange(int(raw_input())):
        n, m = map(int, raw_input().split())
        ngh = {}
        cyc = {}
        dis = {}
        for i in range(n+1):
            ngh[i] = []
            cyc[i] = False
        for i in range(m):
            a, b, w = map(int, raw_input().split())
            ngh[a].append((b,w))
            dis[(a,b)] = w
        start, end = map(int, raw_input().split())
    
        path = []
        def dfs(s, e, vis):
            #print s, e, vis, '>', 
            vis = vis[:] + [s]
            if (s==e):
                #print ""path added"",
                path.append(vis)
            #print vis
            for ng, w in ngh[s]:
                if ng not in vis:
                    dfs(ng, e, vis)
                else:
                    cyc[s] = True
    
        dfs(start, end, [])
        #print path
        #print cyc
    
        def discyc(e, f, w, v):
            ans = float('inf')
            v += [e]
            for ng, wt in ngh[e]:
                if (ng == f):
                    return w+wt
                if (ng not in v):
                    ans = min(ans, discyc(ng, f, wt+w, v))
            return ans
                
    
        l = []
        for p in path:
            curr = 0
            for i in range(len(p)-1):
                if (cyc[p[i]]):
                    l.append(discyc(p[i], p[i], 0, []))
                curr += dis[(p[i],p[i+1])]
                #print [(p[i],p[i+1])], dis[(p[i],p[i+1])]
            
            if (cyc[p[-1]]):
                l.append(discyc(p[-1], p[-1], 0, []))
            l.append(curr/float(len(p)-1))
        #print l
        if (len(l) == 0):
        	print -1
        else:
    	print min(l)
    

"
"
All submissions for this problem are available.
The following a tie breaker problem.  The best answer will receive one point.  All other successful answers will be scored on a curve and receive a fraction of a point based on how close they come to the best answer.
You are given a large square area with an edge length of 2n, subdivided into unit squares (fields). Some mines have already been planted on certain fields, and we would like to plant as few more mines as possible, so as to destroy all of the fields of the area (assuming all the mines explode simultaneously). For each mine, the fields it destroys are given as follows. For any  k ,  0 <=  k  <= n, we can partition the considered area into 2n rectangles of size 2k x 2n-k. The mine is assumed to destroy a square if and only if the mine and the square belong to the same rectangle in the considered partition, for some value of k.
For example, if n=3, the mine ""*"" placed on the square at position (1,1) will destroy all the fields which are not marked with dots below:

.#......
.#......
.#......
.#......
##......
##......
#*######
####....
Input
The first line will contain integer 8<=n<=16, (where 2n is the size of the area). The second line will contain 0<=m<2n, the number of already planted mines.
The next m lines will contain the 0-based x and y coordinates of the existing mines.
Output
The first line should contain t - the number of mines to be added.
The next t lines should contain the coordinates of the added mines.
Scoring
For each test case, you will receive (2n-m)/t-1 points, provided you destroy all the fields of the area.
Example

Input:
2
1
3 3

Output:
2
0 1
2 2

You will receive (4-1)/2 - 1 = 0.5 pts for such a mine placement.  
Note:
There will be some tests with no initially placed mines, and some tests with initial placements covering most of the area pretty well. Good luck!
",AX,S2164820,PYTH,"
    nCr = [[0 for x in xrange(1001)] for x in xrange(1001)]
    
    for i in range (0,1001):
        nCr[i][0]=1
        nCr[i][i]=1
    for i in range (1,1001):
        for j in range (1,1001):
            if i!=j:
                nCr[i][j] = nCr[i-1][j] + nCr[i-1][j-1]
    t=input()
    for _ in range(0,t):
        s,n,m,k=map(int,raw_input().split(' '))
        y=0
        if s==n:
            print(""1.000000"")
            continue
        if (k>m or k>n):
            print (""0.000000"")
            continue
        total = float(nCr[s-1][n-1])
        if m>n:z=m
        else:z=n
        for i in range(k,z):
            y+=((nCr[m-1][i])*(nCr[s-m][n-i-1]))
        print""%.6f"" % (float(y/total)) 
    

"
"
All submissions for this problem are available.
This problem was part of the CodeChef April Challenge.  All user submissions for this contest problem are publicly available here.
Spaghetti Monsters have stolen The Chef’s golden spoon!  The Chef has a map, on which are marked: his location, the location of the golden spoon, and the locations of the spaghetti monsters. The map is in fact rectangular, consisting of square fields. Each field on the map, except for those adjacent to the boundary, is adjacent to 8 other fields -- fields which share a side or corner are assumed to be at a distance of 1 from each other, and it is possible to move between them directly. The Chef is a bit scared of spaghetti monsters and would prefer not to approach them too closely... Help him compute the minimum distance up to which he must approach some spaghetti monster, so as to find the golden spoon.
Input
The first line of input contains two numbers 1<=n,m<=1000, where n denotes the height of the map, and m its width.
The map is given in the next n lines, each of which consists of m characters: 
The unique field represented by the character '@' is the location of The Chef. 
The unique field represented by the character '$' is the location of the golden spoon.
A field represented by the character 'D' is the location of a spaghetti monsters. 
All the remaining fields are represented by the character '.' and denote empty positions.",B1,S1389756,PYTH,"
    import sys
    import logging
    import copy
    import heapq
    import cProfile
    from math import *
    
    class Map:
    
    	def __init__(self):
    		self.map = []
    
    	def read_map(self,f):
    		size_d = f.readline().split()
    		self.height = int(size_d[0])
    		self.width = int(size_d[1])
    		#logging.info(""Size: %s x %s"", self.height, self.width)	
    		for i in range(0,self.height):
    			self.map.extend(list(f.readline().strip()))
    		self.chef_pos = self.map.index('@')
    		#logging.info(""Chef pos: %d"", self.chef_pos)
    		self.spoon_pos = self.map.index('$')
    		#logging.info(""Spoon pos: %d"", self.spoon_pos)
    		self.min_est_cache=[None] * len(self.map)
    
    	def build_neighbour_list(self):
    		size = len(self.map)
    		self.neighbours = size * [None]
    		
    		h = self.height
    		w = self.width
    
    # Corners
    		
    		self.neighbours[0] = [1,w,w+1]
    		ne = w-1
    		self.neighbours[ne] = [ne-1,ne+w,ne+w-1]
    		sw = size-w
    		self.neighbours[sw] = [sw+1,sw-w,sw-w+1]
    		se = size-1
    		self.neighbours[se] = [se-1,se-w,se-w-1]
    
    # Top row
    		for i in range(1,w-1):
    			self.neighbours[i]=[i-1,i+1,i+w-1,i+w,i+w+1]
    # Bottom row
    		for i in range(size-w+1,size-1):
    			self.neighbours[i]=[i-1,i+1,i-w-1,i-w,i-w+1]
    # Left and right columns
    		for i in range(1,h-1):
    			l = i*w
    			r = (i+1)*w-1
    			self.neighbours[l]=[l-w,l+w,(l+1)-w,(l+1),(l+1)+w]
    			self.neighbours[r]=[r-w,r+w,(r-1)-w,(r-1),(r-1)+w]
    			
    		for i in xrange(size):
    			if not self.neighbours[i]:
    				self.neighbours[i]=[ i-w-1, i-w, i-w+1, i-1, i+1, i+w-1, i+w, i+w+1] 
    
    			
    	def print_map(self):
    
    		for n in range(self.height):
    			i = n*self.width
    			print self.map[i:i+self.width]
    		
    	def get_neighbours(self,pos):
    		return self.neighbours[pos]
    
    
    # Map of distans to monsters, refined as necessary
    
    	def init_monster_dist_map(self):
    		self.monsters = [] 
    		d = {'D':0,'@':None,'$':None,'.':None}
    		for x in xrange(len(self.map)):
    			data = d[self.map[x]]
    			if data==0:
    				self.monsters.append(x)
    			self.map[x]=data	
    
    		self.dist_map_level = 0 
    		self.next_dist_set = self.monsters
    			
    
    	def build_monster_dist_map(self,level):
    		while self.next_dist_set and self.dist_map_level <= level:
    			poslist = self.next_dist_set
    			self.next_dist_set = set() 
    			for pos in poslist:
    				if not self.map[pos]:
    					self.map[pos]=self.dist_map_level
    				else:
    					self.map[pos]=min(self.dist_map_level,self.map[pos])
    				for p in self.get_neighbours(pos):
    					if self.map[p] == None:
    						self.next_dist_set.add(p)
    			self.dist_map_level = self.dist_map_level+1
    			
    		
    # Optimistic estimate for distance to spoon
    	def get_min_est(self,pos):
    		cache =  self.min_est_cache[pos]
    		if cache:
    			return cache
    
    		w = self.width
    		y = pos / w
    		x = pos % w
    		ys = self.spoon_pos / w
    		xs = self.spoon_pos % w
    
    		yd = abs(ys-y)
    		xd = abs(xs-x)
    	
    		est = yd if yd > xs else xd
    		self.min_est_cache[pos]=est
    		return est
    
    # Depth first, using heuristics, fastest when solution exists
    	def solve3(self,min_monster_dist):
    		dmap = self.width*self.height*[None]
    		h = []
    		nodes_checked = 0 
    		d = self.get_min_est(self.chef_pos)
    		nodes = set();
    		heapq.heappush(h,(d,self.chef_pos))
    		nodes.add(self.chef_pos)
    		chef_monster_dist = self.map[self.chef_pos]
    		if chef_monster_dist!=None and chef_monster_dist < min_monster_dist:
    			return False
    
    		while h:
    			(d,pos) = heapq.heappop(h)
    			nodes_checked = nodes_checked+1
    
    			if pos==self.spoon_pos:
    				logging.debug(""Nodes checked: %d"", nodes_checked)
    				return True		
    	
    # Switch to breadth first if no quick solution found
    			if nodes_checked > len(self.map)/8:
    				return self.solve2(min_monster_dist)
    
    			dmap[pos] = True
    			nbl = self.get_neighbours(pos)
    			for nb in nbl:
    				if (dmap[nb] == None) and (self.map[nb]==None or (self.map[nb] >= min_monster_dist)):
    					dmap[nb] = 1
    					d = self.get_min_est(nb)	
    					heapq.heappush(h,(d,nb))
    
    #		logging.debug(""Nodes checked: %d"", nodes_checked)
    		return False	
    
    				
    # Breadth first solver, fastest when no solution exist
    	def solve2(self,min_monster_dist):
    		dmap = self.width*self.height*[False]
    		nbl = self.get_neighbours(self.spoon_pos)
    		dist=1;
    		dmap[self.spoon_pos]=1
    		if self.map[self.spoon_pos]!=None and (self.map[self.spoon_pos] < min_monster_dist):
    			return False
    		changed = True
    		while changed:
    			onbl=nbl
    			changed = False
    			nbl = set()
    			dist=dist+1;
    			for nb in onbl:
    				if nb==self.chef_pos:
    					return True
    				if (dmap[nb] == False) and (self.map[nb]==None or (self.map[nb] >= min_monster_dist)):
    					changed=True
    					dmap[nb]=dist
    
    					for n in self.get_neighbours(nb):
    						nbl.add(n)
    
    		return False
    
    
    	def solve(self):
    		right = 1000
    		left = 0	
    		best = None
    
    		
    		for n in range(0,right+1):
    #			logging.info(""Trying: %d"", n)
    			self.build_monster_dist_map(n)
    			if not self.solve3(n):
    #				logging.info(""Fail: %d"", n)
    				return n-1
    		return
    	
    		
    
    def run():
    #	logging.basicConfig(level=logging.DEBUG)
    	m = Map()
    	m.read_map(sys.stdin)
    	m.build_neighbour_list()
    	m.init_monster_dist_map()
    
    	print m.solve()
    
    
    run()
    #cProfile.run('run()')
    

"
"
All submissions for this problem are available.
This problem was part of the CodeChef April Challenge.  All user submissions for this contest problem are publicly available here.
In the game of ""BattleShip V"", you control a cannon which is attacking a large enemy battleship, armed with many guns. Your goal is to destroy as many of the guns as possible.
The battle field is a 2D Cartesian grid, where your cannon is located at the origin.
The enemy battleship is a horizontal line segment located from the coordinates (X1 , Y) to (X2, Y).
There are exactly (X2 - X1 + 1) guns on the ship, located at the integer points (X1, Y), (X1+1, Y), ..., (X2, Y).


However, the problem is, you cannot always fire at a gun. There are supernatural rocks located at all points of the battlefield whose X and Y coordinates are both integers. In order to fire successfully at an enemy's gun, the line connecting your cannon and that gun must not
go through any rocks.


How many guns you successfully destroy?

Input

The first line contains t, the number of test cases (about 100). Then t test cases follow.


Each test case consists of one line containing three numbers Y, and X1, X2 (2100000000 > ≤ Y ≤ 2100000000, -2100000000 ≤ X 1 ≤ X2 ≤ 2100000000).

Output

For each test case, output the number of the enemy battleship's guns that your cannon can destroy.

Example

Input
1
2 -2 1


Output
2
 ",B3,S5209959,PYTH,"
    import numpy as np
    test=input('No of test cases: ')
    global n1
    
    def check(y,x):
      global n1 
      x=float(x)
      m=(y/x)
      n=0
      if m>0:
          pos=range(1, int(x))
      else:
          pos=range(int(x)+1, 0)
      
      for i in pos:
        k1=(m*i)
        k2=int(k1)
        if k1==k2:
           n=n+1
      
      if n>0:
          n1=n1+1
          
    for l in range(0, test):
      n1=0
      y=input('input y: ')
      x1=input('input x1: ')
      x2=input('input x2: ')
    
      for i in range(x1, x2+1):
        if i!=0:
          check(y, i)
      else:
        n1=n1+1
      print n1
      
    

"
"
All submissions for this problem are available.
This problem was part of the CodeChef April Challenge.  All user submissions for this contest problem are publicly available here.
Bugs have gotten into The Chef’s kitchen!  Help him trap them all and he’ll make you a batch of his famous chocolate chip cookies.  You are given a given a square map of the kitchen divided into tiles, and in each tile sits some known number of bugs.  You also have a square trap, which can be dropped to cover a certain number of tiles (the trap may only cover tiles from within the map, and must be aligned to the borders of the kitchen). However, the trap only catches bugs from one of the tiles which it has covered, having a minimum number of bugs on it. For all possible positions at which the trap can be dropped, determine number of bugs that will be caught.
Input
Two numbers, 0<  n  <= 1000 (size of the map), and 0< k <= n (size of the trap), followed by n rows with n numbers, determining the number of bugs on each tile.  The number of bugs on each tile will fit in an signed 32-bit integer.
Output
You should output n-k+1 rows with n-k+1 numbers in each row. 
Example

Input:
4 2
0 1 2 3
4 5 6 7
8 9 0 1
2 3 4 0

Output:
0 1 2
4 0 0
2 0 0
 ",B5,S270394,PYTH,"
    import pysco
    psyco.full()
    kitchen = []
    result = []
    tresult = []
    final = []
    n = 0
    k = 0
    
    if __name__ == '__main__':
        (n, k) = map(lambda v: int(v), raw_input().split(' '))
        i = 0
        while(i < n):
            kitchen.append([])
            kitchen[i] = map(lambda v: int(v), raw_input().split(' '))
            j = 0
            result.append([])
            while(j < n - k + 1):
                result[i].append(min(kitchen[i][j:j+k]))
                j += 1
            i += 1
        i = 0
        while(i < len(result[0])):
            tresult.append([])
            j = 0 
            while(j < len(result)):
                tresult[i].append(result[j][i])
                j += 1
            i += 1
        i = 0
        while(i < len(tresult)):
            i += 1
            final.append([])
        i = 0
        while(i < len(tresult)):
            j = 0
            while(j < len(tresult)):
                final[j].append(min(tresult[i][j:j+k]))
                j += 1
            i += 1
        i = 0
        while(i < len(tresult)):
            j = 0
            while(j < len(tresult)):
                print(final[i][j]),
                j += 1
            print
            i += 1
        
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin and Russian. Translations in Vietnamese to be uploaded soon.
Two cheeky thieves (Chef being one of them, the more talented one of course) have came across each other in the underground vault of the State Bank of Churuland. They are shocked! Indeed, neither expect to meet a colleague in such a place with the same intentions to carry away all the money collected during Churufest 2015.


They have carefully counted a total of exactly 1 billion (109) dollars in the bank vault. Now they must decide how to divide the booty. But there is one problem: the thieves have only M minutes to leave the bank before the police arrives. Also, the more time they spend in the vault, the less amount could carry away from the bank. Formally speaking, they can get away with all of the billion dollars right now, but after t minutes they can carry away only  1 billion * pt dollars, where p is some non-negative constant less than or equal to unity, and at t = M, they get arrested and lose all the money.
They will not leave the vault until a decision on how to divide the money has been made.

The money division process proceeds in the following way: at the beginning of each minute starting from the 1st (that is, t = 0), one of them proposes his own way to divide the booty. If his colleague agrees, they leave the bank with pockets filled with the proposed amounts of dollars. If not, the other one proposes his way at the next minute etc. To escape arrest, they can only propose plans till the beginning of the Mth minute (i.e., till t = M-1).
Each thief wants to maximize his earnings, but if there are two plans with the same amounts for him, he would choose the one which leads to a larger total amount of stolen dollars.

Chef is about to start this procedure, and he is the first to propose a plan. You are wondering what will be the final division of money, if each thief chooses the optimal way for himself and money is considering real.
Input
The first line of input contains an integer T denoting the number of test cases. The description of T test cases follows. The only line of input for each test case contains an integer M denoting the number of minutes until arrest and a double denoting the constant p.
Output
For each test case, output a single line containing two space-separated doubles denoting the amount of dollars each thief will get in the optimal division. First number: dollars amassed by Chef, and second: by his colleague. The answer will be considered correct if its absolute error doesn't exceed 10-2.
Constraints and subtasks

1 ≤ T ≤ 105
0 ≤ p ≤  1  

Subtask 1 (15 points) :
1 ≤ M ≤ 3

Subtask 2 (55 points) :
1 ≤ M ≤  103

Subtask 3 (30 points) :
1 ≤ M ≤ 109
Example
Input:
2
1 0.5
2 0.5
Output:
1000000000.0 0.0
500000000.0 500000000.0

Explanation
Example case 1. In the second case, if decision isn't made at t = 0, total amount of money decreases to 5*108 at t = 1 which leads to a situation worse than the given solution. ",BANROB,S11570165,PYTH,"
    T = input()
    for _ in xrange(T):
        m,p = map(float,raw_input().strip().split())
        ans = 1e9 * (1 - (-p)**m)/(1+p)
        print ""%.11lf %.11lf"" % (ans,1e9-ans)
        

"
"
All submissions for this problem are available.

Chef Ciel has forgotten the combination to the safe.
It's a serious incident, because the safe contains this month's waitstaff salaries.


To open the safe, N boxes and N balls are used.
The safe has N boxes that numbered from 1 to N uniquely.
Each box can contain only one ball.
Now, the box i contains one ball that numbered i, and the safe is locked.


The only things which Ciel remember for unlocking the safe are the followings:



She must put every ball into some box.


Let the box i contains the ball Ai.
When the safe is opened the number of divisors of i equals to the number of divisors of Ai for all i from 1 to N. 


How many combinations which satisfy above conditions should she check?
The number of combinations can be very large, so you should print this number modulo 500009 (5*105+9).

Input

The first line contains an integer T, the number of test cases.
Then T test cases follow.
The only line of each test case contains an integer N.

Output

For each test case, print the number of combinations modulo 500009 (5*105+9).

Constraints

1 ≤ T ≤ 100000 (105)
3 ≤ N ≤ 2000000000 (2*109)

Sample Input
3
3
5
100Sample Output
1
5
43264Output details

In the first case, the valid combination is

Box: 123
Ball: 132
since the number of divisors of 2 is equal to the number of divisors of 3.


In the second case, the valid combinations are

Box: 12345 12345 12345 12345 12345
Ball: 12543 13245 13542 15243 15342 ",BBSYSTEM,S1657628,PYTH,"
    ## Observations
    ## 1. The problem is asking us for the following quantity Q(n) (munged slightly, see below)
    ##    Q(n) = (number of pos integers <= n with 1 divisor)! * (num of pos integers <= n with 2 divisors)! * ...
    ## 2. The two modifications we need to make to Q(n) are
    ##     -- We need Q(n) - 1, not Q(n)
    ##     -- we need to take the modulus mod 50009
    ## 3. We can relate Q(n) to Q(n-1) in the following way
    ##     -- Lets say that n has k divisors
    ##     -- Lets say that m positive integers strictly less than k also had k divisors.
    ##     -- We claim Q(n) = Q(n-1) * (m+1).  This can be seen by examining the form above and noting that the
    ##        expansion above for Q(n-1) will contain a m! while the expantion for Q(n) will contain a
    ##        (m+1)! = (m+1) * m!.  The other terms are the same.
    ## 4. It still seems a bit daunting that we have a recurrence to find Q(n), but n is allowed to range all
    ##    the way to 2,000,000,000!!  We really have 2 daunting problems here:
    ##      -- How to efficiently calculate the number of divisors in n for large n
    ##      -- How to clip off the recursion to something tolerable
    ## 5. For the first problem, we can divide this into two parts:
    ##      -- Coming up with a list of primes to use to test n
    ##      -- Figuring out how to use that list of primes to figure out how many divisors are in an integer
    ## 6. As far as coming up with a list of primes, we only need a list of primes up to about 15000 to test
    ##    an integer n up to 2,000,000,000 (since, if n is composite, one of the factors must be <= sqrt(n)).
    ##    To create this list, we can use a sieve of erastothenes.  We only have to iterate up to primes <= 125 or so,
    ##    since by similar logic above, we only have to sieve on the sqrt() of the size of the sieve.
    ## 7. Now that we have a list of primes <= 15,000, we need an efficient way to figure out how many divisors
    ##    an integer has.  Assuming we are doing this recursively, this seems like a reasonable approach (without
    ##    having to create a sizable data structure for storing prime factorizations of every number)
    ##    -- Iterate through the primes until we find one that divides n (if none do, then n is prime)
    ##    -- Use that prime p to deconstruct n (by repeated division) to n = p^k * residual where residual is not divisible by p
    ##    -- The number of divisors of n is then (k+1) * the number of divisors of the residual
    ## 8. Once one of the equivalence classes hits 500009 members (500009 is indeed prime), we can stop, since the results after that will simply be Q(k) = 0 mod 500009.
    ##    A quick offline check using the functions sieve() and divisors() below helps us find when this is so we can budget.
    ## def main() :
    ##     primelist = sieve(2000)
    ##     divlist = [0] * 4000001
    ##     divcount = { 1 : 1 } 
    ##     divlist[1] = 1
    ##     for k in xrange (2,4000001) :
    ##         ndiv = divisors(k,primelist,divlist)
    ##         divcount[ndiv] = divcount.get(ndiv,0) + 1
    ##         if (divcount[ndiv] == 500009) : print ""FOUND 500009: k = %d"" % k 
    ##         if k % 1000 == 0:
    ##             ll = sorted(divcount.items(), key=lambda x : (-1*x[1],x[0]))
    ##             print ""k=%s,  Top 5 eq classes %s %s %s %s %s"" % (k,ll[0],ll[1],ll[2],ll[3],ll[4])
    ##  The magic number is : 2229283
    ## 9. Scaling down our numbers:
    ##    Only need primes up to 2000 for 4000000 (a bit of overkill, but whatever)
    ##    We size our arrays to an even 2.3mil
    
    
    def sieve (n) :
        ss = [0] * 2 + [1] * (n-1);
        i = 2;
        while (i * i < n) :
            if (ss[i] == 1) :
                for k in xrange (2*i,n+1,i) : ss[k] = 0
            i += 1;
        primelist = [k for k in range (2,n+1) if ss[k] == 1]
        return primelist
    
    def divisors (n, primelist, divlist) :
        for p in primelist :
            if p*p > n:
                break
            if (p == n) :
                divlist[n] = 2
                return 2
            if (n % p == 0) :
                junkn = n
                junkn /= p
                count = 1;
                while (junkn % p == 0) :
                    junkn /=p
                    count += 1
                divlist[n] = (count+1) * divlist[junkn]
                return divlist[n]
        divlist[n] = 2
        return 2
        
    def domore (lastn, n, primelist, divlist, divcount, qlist) :
        for k in xrange (lastn+1, n+1) :
            ndiv = divisors(k,primelist,divlist)
            divcount[ndiv] = divcount.get(ndiv,0) + 1
            qlist[k] = qlist[k-1] * divcount[ndiv] % 500009
     
    import sys
    filein = sys.stdin
    ##filein = open(""bbsystem.in"",'r')
    filell = filein.readlines()
    f = filell.__iter__()
    outbuf = []
      
    def main() :
        primelist = sieve(2000)
        divlist = [0] * 2300001
        qlist = [0] * 2300001
        qlist[1] = 1
        divcount = { 1 : 1 } 
        divlist[1] = 1
        donesofar = 1
        
        t = int(f.next())
        for tt in xrange (t) :
            n = int(f.next())
            if n > 2300000 :
                outbuf.append(""500008"")
                continue
            if n > donesofar :
                domore(donesofar,n,primelist,divlist,divcount,qlist)
                donesofar = n
            outbuf.append(""%d"" % ((qlist[n] - 1) % 500009))
                
        print ""\n"".join(outbuf)
    main()

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.

Chef is going to participate in 'Who will prepare the most beautiful sandwich?' reality show. The show requires participants to prepare sandwiches that not only look beautiful, but taste delicious too. The show also releases a list of ingredients that you are allowed to use in the sandwich. This time, the list consists of K ingredients. For the purpose of our problem, you can assume that each ingredient is denoted by a lower case Latin character. So the first K lower case Latin letters will describe all the ingredients.

Chef's sandwich consists of N parts of ingredients packed in a row. You can think of it as a string of length N containing the first K English letters only.

Chef thinks the beauty of the sandwich is an integer that can be computed in the following way: 

First partition the sandwich into consecutive blocks of maximal length such that all the parts in the same block are of same ingredient.
Beauty of this sandwich is the sum of squared lengths of the blocks.


For example, let the sandwich be denoted by ""aadddbabb"".

Chef partitions it in this way - aa, ddd, b, a, bb
Beauty of this sandwich is equal to 2*2 + 3*3 + 1*1 + 1*1 + 2*2 = 19


There will be Q judges in the show. Chef diligently worked for days in preparing Q such sandwiches before the show. Now, it is the show time. He just got an information from the back stage anchor that some of the judges are allergic to some ingredients. Now, Chef has to sit down and take out each sandwich and remove all the ingredients that the judge (the one who is supposed to taste it) is allergic to. After doing that, he will rearrange the parts of the sandwich continuously without leaving any ugly looking gap.


Now, Chef is worrying about the beauty of the sandwiches presented to various judges. He asks you to help in this.

Input
The first line of the input contains two space separated integers N and K, denoting the number of parts in the sandwich and the number of available ingredients, respectively.
The second line contains a string of length N having only the first K Latin lower case letters, denoting the sandwich.
The third line contains a single integer Q, denoting the number of judges.
Each of the following Q lines contains a string denoting the ingredients to which the corresponding judge is allergic. The string will be sorted in ascending order of their characters. No character will appear more than once in it.
Output
For each query, output a single integer in a separate line denoting the beauty of the sandwich that the corresponding judge will be tasting.
Constraints
1 ≤ N ≤ 200,000
1 ≤ K ≤ 18
1 ≤ Q ≤ 262,143
Example
Input:
7 4
acabada
2
b
ac

Output:
8
2
Explanation
First judge is allergic to ingredient denoted by 'b'. So Chef has to remove this ingredient from the judge's sandwich. After that, the sandwich will be ""acaada"". Its beauty will be 1*1 + 1*1 + 2*2 + 1*1 + 1*1 = 8

Second judge is allergic to ingredients denoted by characters 'a' and 'c'. After removing these ingredients, the sandwich will become ""bd"" and its beauty will be 2.
 ",BEAUTY,S11972347,PYTH,"
    def beautyof(sandwich):
        i = 0
        beauty = 0
        l = len(sandwich)
        while i<l:
            a = sandwich[i]
            pow = 1
            while i<l-1 and sandwich[i+1]==a:
                i += 1
                pow += 1
            i += 1
            beauty += pow**2
        return beauty
    N, K = map(int, raw_input().split())
    sandwich = raw_input()
    Q = input()
    for q in xrange(Q):
        newwich = sandwich[:]
        alings = raw_input()
        for aling in alings:
            newwich = newwich.replace(aling, '')
        print beautyof(newwich)

"
"
All submissions for this problem are available.
 Given a sequence of positive integers a1,
a2, …, aN, and 1 ≤
i ≤ j ≤ N, the partial sum from
i to j is ai +
ai+1 + … + aj.
 In this problem, you will be given such a sequence and two
integers P and K. Your task is to find the smallest
partial sum modulo P that is at least K.

For example, consider the following sequence of integers:

    12     13     15     11     16     26     11

 Here N = 7. Suppose K = 2 and P = 17.
Then, the answer is 2 because 11+16+26 = 53 and 53 mod 17 is 2.  On
the other hand, if K = 0 the answer is 0 since 15 + 11 + 16 +
26 = 68 and 68 mod 17 is 0.
Input format
The first line contains three integers N, K and
P.  This is followed by N lines each containing a
single integer.
You may assume 1  ≤ N  ≤ 100000.
Output format
A single integer indicating the minimum possible segment sum modulo
P that is at least K.
Example:
Sample Input

7 2 17
12
13
15
11
16
26
11
Sample Output

2
 ",BESTSUM,S112500,PYTH,"
    n,k,p = [int(x) for x in raw_input().split()]
    numbers = [int(raw_input()) for x in xrange(n)]
    
    min = p
    for sum_count in xrange(1, len(numbers)+1):
        for x in xrange(1, len(numbers)-sum_count):
            tmp = sum(numbers[x:x+sum_count+1]) % p
            if tmp >= k and tmp < min:
                min = k
    
    print k

"
"
All submissions for this problem are available.
Harry is a bright student. To prepare thoroughly for exams, he completes all the exercises in his book! Now that the exams are approaching fast, he is doing book exercises day and night. He writes down and keeps updating the remaining number of exercises on the back cover of each book.
Harry has a lot of books messed on the floor. Therefore, he wants to pile up the books that still have some remaining exercises into a single pile. He will grab the books one-by-one and add the books that still have remaining exercises to the top of the pile.
Whenever he wants to do a book exercise, he will pick the book with the minimum number of remaining exercises from the pile. In order to pick the book, he has to remove all the books above it. Therefore, if there are more than one books with the minimum number of remaining exercises, he will take the one which requires the least number of books to remove. The removed books are returned to the messy floor. After he picks the book, he will do all the remaining exercises and trash the book.
Since number of books is rather large, he needs your help to tell him the number of books he must remove, for picking the book with the minimum number of exercises.

Note that more than one book can have the same name.

Input
The first line contains a single integer N denoting the number of actions. Then N lines follow. Each line starts with an integer. If the integer is -1, that means Harry wants to do a book exercise. Otherwise, the integer is number of the remaining exercises in the book he grabs next. This is followed by a string denoting the name of the book.
Output
For each -1 in the input, output a single line containing the number of books Harry must remove, followed by the name of the book that Harry must pick.
Constraints

1 < N ≤ 1,000,000 0 ≤ (the number of remaining exercises of each book) < 100,000 The name of each book consists of between 1 and 15 characters 'a' - 'z'. Whenever he wants to do a book exercise, there is at least one book in the pile.

Example

Input:
6
9 english
6 mathematics
8 geography
-1
3 graphics
-1

Output:
1 mathematics
0 graphics
 ",BEX,S10647731,PYTH,"
    from operator import itemgetter
    arr=[]
    n=int(raw_input())
    for i in range(n):
        x=list(map(str,raw_input().split()))
        if len(x)==2:
            x[0]=int(x[0])
            arr.append((x[0],x[1]))
        else:
            b=min(arr,key=itemgetter(0))
            counter=0
            #print arr,b[0]
            for j in range(len(arr)-1,-1,-1):
                if arr[j][0]==b[0]:
                    break
                arr.pop()
                counter+=1    
            print counter,arr[-1][1]

"
"
All submissions for this problem are available.
The relationship between The University of Byteland and King Johnny was never a friendly one. The king was the easy-going, open-minded sort of person who is prepared to turn a blind eye to the embezzlement of public funds, but inwardly revolts at the thought of money going to waste, and supporting a university was to the king a perfect example of a waste of money. On the other hand, the chancellor of the university showed no tolerance whatsoever, and frequently stated in public that Byteland was being governed by a monarch who took terrible decisions when he was drunk and even worse ones when he was sober. After some time of bad-tempered coexistence, the king had had enough and decided to close down the university. However, the king's councillors advised against this move, suggesting it might cause social unrest. The king yielded to their advice, and instead established a law which banned all organisations, clubs and associations active at the university.

This action had a rather curious effect on the usually lazy students of the university. They had never before even thought of organising any sort of fellowship, but now they immediately decided they needed to set one up. And this is how the Secret Fellowship came to life.

The main problem that faced the management of the Fellowship was to organise members' meetings in such a way as to minimise the risk to the participants. It was decided that the n members of the fellowship should be split into k secret divisions, each consisting of at least 2 members. All members belonging to the same division would then meet regularly, and they would take it in turns to host the meetings of the division in their houses.

But one more important factor has to be taken into account -- the laziness of students. It is therefore your task to form the divisions in such a way that the furthest distance a student may ever be asked to walk is as short as possible.
Input
The first line of input contains a single integer t, the number of test cases (t=1000). t test cases follow.

Each test cases starts with a line containing two integers n k, denoting the number of students and the number of divisions to be formed, respectively (2<=2k<=n<=200). Each of the next n lines contains two integers xi yi each (-1000 <= xi,yi <= 1000), denoting the coordinates of the houses of successive students.
Output

For the i-th test case output a line with the text case i Y or case i N, specifying whether you wish to solve the given case. Then in the former case print exactly k lines. Each line should start with integer nj (nj>=2) and be followed by a space separated list of exactly nj increasing integers sjl, denoting the students belonging to the j-th division, numbered in input order (1<=sjl<=n). All divisions must be disjoint and the sum of all numbers nj must equal n.
Score

The score awarded to your program is the total of scores for the test cases you chose to solve.

For each solved test case you will receive diam / (d*k) points, where diam denotes the distance between the two furthest houses of members of the fellowship, and d is the distance between the two furthest houses of members belonging to the same division.
Example

Input:
2
6 3
0 0
1 0
0 1
1 1
2 0
2 1
6 2
0 0
1 0
0 1
1 1
2 0
2 1
6 2
0 0
1 0
0 1
1 1
2 0
2 1

Output:
case 1 Y
3 1 2 4
3 3 5 6
case 2 Y
3 1 2 5
3 3 4 6
case 3 Y
2 1 3
4 2 4 5 6

Score:
1.849003

Bonus info: If score = xxx.xxxaaa, aaa means the number of test cases with Y answer.
",BFORG,S109159,PYTH,"
    #!/usr/bin/python
    
    num_cases = int(raw_input())
    for i in range(num_cases):
    	print ""case"",i,""N""
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
WARNING: This problem has large input / output files. Use of faster I/O methods is recommended.
You are given an array A consisting of N integers. You have to answer M queries on it. Each query belongs to one of the following three types:

1 L R X : multiply each number in the range AL, AL + 1, ..., AR by X.
2 L R Y : Replace the elements AL, AL + 1, ..., AR by Y, 2 * Y, ... (R - L + 1) * Y. In other words, the number Ai will be equal to (i - L + 1) * Y for each i from L to R.
3 L R : Find the product of all numbers in the range AL, AL + 1, ..., AR. As this number could be very large, you have to just find the number of trailing zeros of this number when represented in decimal notation.

Input
The first line of the input contains an integer T denoting the number of test cases. T test cases follow.
The first line of each test case contains two space-separated integers N and M.
The second line contains N space-separated integers denoting A1, A2, ..., AN
For next M lines, each line contains a query.
Each query is given by three or four (please refer to the statement) space separated integers.
The first integer denotes type of the query. For every type of query next two integers denote L and R. For each query of type 1, next integer denote X. For each query of type 2, next integer denote Y.
Output
For each test case, output a single line containing the sum of answers of all the queries of type 3.
Constraints

1 ≤ T ≤ 5
1 ≤ N, M, N + M  ≤ 105
1 ≤ L ≤ R ≤ N
1 ≤ X, Y, Ai ≤ 109

Subtasks

Subtask #1 (18 points): 1 ≤ N, M, X, Y, Ai ≤ 10
Subtask #2 (31 points): 1 ≤ N, M ≤ 1000
Subtask #3 (51 points): original constraints

Example
Input:
1
5 5
2 4 3 5 5
3 2 4
3 2 5
2 2 4 1
1 3 3 10
3 1 5

Output:
5

Explanation
Array: [2, 4, 3, 5, 5]

1st query: [4, 3, 5], 4 * 3 * 5 = 60 : answer 1.
2nd query: [4, 3, 5, 5], 4 * 3 * 5 * 5 = 300 : answer 2.
3rd query: [2, 4, 3, 5, 5] => [2, 1, 2, 3, 5].
4th query: [2, 1, 2, 3, 5] => [2, 1, 20, 3, 5].
5th query: [2, 1, 20, 3, 5], 2 * 1 * 20 * 3 * 5 = 600 - answer 2.

Sum of all answers = 5. ",BGQRS,S11887302,PYTH,"
    import math
    
    def F(n, x):
    	
    	count = 0
    	while (n % x == 0):
    		count = count + 1
    		n = n/x
    	return count
    
    
    T = input()
    while (T > 0):
    	res = 0
    	x = raw_input()
    	x = x.split("" "")
    	
    	array = raw_input()
    	array = array.split("" "")
    	iarray = [0] * int(x[0])	
    
    	for i in range(int(x[0])):
    		iarray[i] = [F(int(array[i]), 2), F(int(array[i]), 5)]
    	
    	
    	
    	for j in range(int(x[1])):
    		S = raw_input()
    		S = S.split("" "")
    		if (S[0] == '1'):
    			for i in range(int(S[1]) - 1, int(S[2])):
    				t = F(int(S[3]), 2)
    				f = F(int(S[3]), 5)
    				iarray[i][0] = iarray[i][0] + t
    				iarray[i][1] = iarray[i][1] + f
    
    		elif (S[0] == '2'):
    			for i in range(int(S[1]) - 1, int(S[2])):
    				t = F((i - int(S[1]) + 2) * int(S[3]), 2)
    				f = F((i - int(S[1]) + 2) * int(S[3]), 5)
    				iarray[i][0] = t
    				iarray[i][1] = f
    		else:
    			t = 0
    			f = 0
    			for i in range(int(S[1]) - 1, int(S[2])):
    				t = t + iarray[i][0]
    				f = f + iarray[i][1]
    			res = res + min(t, f)
    		
    
    	print res
    
    	T = T - 1

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
The much anticipated video game ""BiCo Grid"" has been released. The rules of ""Bico Grid"" are very simple.
The game field is a 100x100 matrix, where each cell is either a blocked cell, or a cell with some number of coins. For a regular player the look of the field seems pretty random, but the programmer in you recognizes the following pattern: the i-th cell on the n-th row contains C(n, i) coins if and only if 0 ≤ i ≤ n, all other cells are blocked. Record C(n, i) denotes binomial coefficient ""n choose i"".
The player starts from the cell situated at row R and column C in the matrix. The objective is to collect exactly G number of coins from matrix in several moves. There are some rules: 

On each move the player must collect all the coins from some unblocked cell in the current column.
The rules of the game state, that player mustn't be really greedy, so the number of coins he collected must not increase. In other words, if at some move the player collected X coins then further he cannot collect more than X coins in a single move.
After each move, the player is immediately moved to some cell of the column W-1 (where W denotes the current column of the player). If the current column of the player has index 0, the game ends.
The game ends when player collects exactly G number of coins.

You are given the description of the game. Please, output the sequence of moves that win the game (collect exactly G coins)! It is guaranteed that if the player will play optimally it is possible to win the game.
Input
The first line of the input contains an integer T denoting the number of test cases. Then T lines follows. Each containing three integers, R denoting the starting row, C, denoting the starting column, and G, denoting the number of coins to be collected.
Output
For each test case, output two lines. First line contains K, the number of column visited before completion of game. Second line contains K space separated integers, the number of coins collected from the cells, in the order they were collected.
It is guaranteed that a solution exists. And if there are multiple solutions, print any of them.
Constraints
1 ≤ T ≤ 100000 ≤ C ≤ 490 ≤ R ≤ 991 ≤ G ≤ 1012
Example
Input:
3
3 2 5
3 3 10
5 4 7

Output:
2
3 2 
1
10 
3
5 1 1
Explanation
Example case 1. We first pick 3 coins from [3, 2] then we pick 2 coins from [2, 1]Example case 2. As 3rd column contains 10 coins in cell [5, 3] we pick it.Example case 3. We first pick 5 coins from [5, 4] then we pick 1 coin from [3, 3] and again we pick 1 coin from [2, 2]. ",BICO,S3785756,PYTH,"
    C = [[0 for x in xrange(100)] for x in xrange(100)]
    
    def dp():
        for i in range(100):
            for j in range(min(99, i)):
                if j == 0 or j == i:
                    C[i][j] = 1
                else:
                    C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
    
    def work(r, c, g):
        maxUsed = -1
        ans = []
        x = r
        y =  c
        while C[x][y] < g:
            x = x + 1
            if x == 100:
                x = 99;
                break;
        while C[x][y] > g:
            x = x - 1;
            if x < 0:
                x = 0;
                break;
        if C[x][y] == g:
            print 1
            print g
            return;
    
        ans += [C[x][y]]
        g -= C[x][y]
        maxUsed = C[x][y]
        y = y - 1;
        while g > 0:
            while C[x][y] < g and C[x][y] <= maxUsed:
                x = x + 1;
                if x == 100:
                    x = 99;
                    break;
            while C[x][y] > g or C[x][y] >= maxUsed:
                x = x - 1;
                if x < 0:
                    x = 0;
                    break;
            ans += [C[x][y]]
            g -= C[x][y];
            y = y - 1;
    
        print len(ans);
        s = """"
        for q in ans:
            s += str(q) + "" ""
        print s
    
    
    if __name__ == '__main__':
        dp()
        T = int(raw_input())
        while T > 0:
            T = T - 1;
            r, c, g = map(int, raw_input().split());
            work(r, c, g)
        exit(0)
    

"
"

                    function formatTime(ts) {
                      now = new Date(ts);

                      localtime = new Date();
                      hour = now.getHours();
                      min = now.getMinutes();
                      sec = now.getSeconds();

                      if (min <= 9) {
                        min = ""0"" + min;
                      }
                      if (sec <= 9) {
                        sec = ""0"" + sec;
                      }
                      if (hour > 12) {
                        hour = hour - 12;
                        add = "" PM"";
                      } else {
                        hour = hour;
                        add = "" AM"";
                      }
                      if (hour == 12) {
                        add = "" PM"";
                      }
                      if (hour == 00) {
                        hour = ""12"";
                      }

                      $('#server-time').html(((hour<=9) ? ""0"" + hour : hour) + "":"" + min + "":"" + sec + add);

                      nextSec = (now.getTime() + 1000);

                      setTimeout(""formatTime(""+nextSec+"")"", 1000);
                    }
                    function getDtTimeZone()
                    {
                      var rightNow = new Date();
                      var toDay = new Date(rightNow.getFullYear(), 0, 1, 0, 0, 0, 0);
                      var temp = toDay.toGMTString();
                      var date2 = new Date(temp.substring(0, temp.lastIndexOf("" "") -1));
                      var stdTime = (toDay - date2) / (1000 * 60 * 60);
                      return stdTime;
                    }
/*var d=new Date();
$.ajax({
url: '/umtza',
type:'POST',
data: 'umtza='+d.toString(),
});
*/

CodeChef is a non-commercial competitive programming community




About CodeChef
About Directi
CEO's Corner
C-Programming
Programming Languages
Contact Us


© 2009 Directi Group.  All Rights Reserved.  CodeChef uses SPOJ © by Sphere Research Labs
In order to report copyright violations of any kind, send in an email to copyright@codechef.com



The time now is: 

        formatTime('September 01, 2014 16:46:08');
      




    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-53602-42']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

  


    /* <![CDATA[ */
    var google_conversion_id = 1066618556;
    var google_conversion_language = ""en"";
    var google_conversion_format = ""3"";
    var google_conversion_color = ""666666"";
    var google_conversion_label = ""gbUUCPTlhAIQvJ3N_AM"";
    var google_conversion_value = 0;
    /* ]]> */
  









    /* <![CDATA[ */
    var google_conversion_id = 968176136;
    var google_conversion_language = ""en"";
    var google_conversion_format = ""3"";
    var google_conversion_color = ""ffffff"";
    var google_conversion_label = ""iDk7CPDZ7wMQiOTUzQM"";
    var google_conversion_value = 0;
    /* ]]> */
  








CodeChef - A Platform for Aspiring Programmers
CodeChef was created as a platform to help programmers make it big in the world of algorithms, computer programming and programming contests. At CodeChef we work hard to revive the geek in you by hosting a programming contest at the start of the month and another smaller programming challenge in the middle of the month. We also aim to have training sessions and discussions related to algorithms, binary search, technicalities like array size and the likes. Apart from providing a platform for programming competitions, CodeChef also has various algorithm tutorials and forum discussions to help those who are new to the world of computer programming.

Practice Section - A Place to hone your 'Computer Programming Skills'
Try your hand at one of our many practice problems and submit your solution in a language of your choice. Our programming contest judge accepts solutions in over 35+ programming languages. Preparing for coding contests were never this much fun! Receive points, and move up through the CodeChef ranks. Use our practice section to better prepare yourself for the multiple programming challenges that take place through-out the month on CodeChef. 

Compete - Monthly Programming Contests and Cook-offs
Here is where you can show off your computer programming skills. Take part in our 10 day long monthly coding contest and the shorter format Cook-off coding contest. Put yourself up for recognition and win great prizes. Our programming contests have prizes worth up to Rs.20,000 and $700lots more CodeChef goodies up for grabs. 

Discuss
Are you new to computer programming? Do you need help with algorithms? Then be a part of CodeChef's Forums and interact with all our programmers - they love helping out other programmers and sharing their ideas. Have discussions around binary search, array size, branch-and-bound, Dijkstra's algorithm, Encryption algorithm and more by visiting the CodeChef Forums and Wiki section.

CodeChef Community
As part of our Educational initiative, we give institutes the opportunity to associate with CodeChef in the form of Campus Chapters. Hosting online programming competitions is not the only feature on CodeChef. You can also host a coding contest for your institute on CodeChef, organize an algorithm event and be a guest author on our blog. 

Go For Gold
The Go for Gold Initiative was launched about a year after CodeChef was incepted, to help prepare Indian students for the ACM ICPC World Finals competition. In the run up to the ACM ICPC competition, the Go for Gold initiative uses CodeChef as a platform to train students for the ACM ICPC competition via multiple warm up contests. As an added incentive the Go for Gold initiative is also offering over Rs.8 lacs to the Indian team that beats the 29th position at the ACM ICPC world finals. Find out more about the Go for Gold and the ACM ICPC competition here.
 ",BIGTREE,S11203584,PYTH,"
    def find_depth(a,b,m,n,data):
        d=-1
        k=1
        maxx=100000001
        minn=-1
        prev=100000001
        dirr=0
    	
        while(k<=n):
            temp=(a+b*k)%m
            
            if((dirr==0 and prev>temp and temp<=maxx and temp>=minn) or (dirr==1 and (prev<temp or prev==temp) and temp<=maxx and temp>=minn)):
                d=d+1
                prev=temp
                if(prev>data):
                    maxx=prev
                    dirr=0
                else:
                    minn=prev
                    dirr=1
            k=k+1    
        
        return d
    
    t=input()
    arr=[]
    
    for i in range(0,t):
        val=map(int,raw_input().split())
        a=val[0]
        b=val[1]
        m=val[2]
        n=val[3]
        data=(a+b*n)%m
        arr.append(find_depth(a,b,m,n,data))
        
    for i in range(0,t):
        print arr[i]
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
Today is Chef's birthday. His mom decided to surprise him with a truly fantastic gift: his favourite binary string B. But, unfortunately, all the stocks of binary string B have been sold out, and only a binary string A (A ≠ B) is available in the market.
She purchases the string A and tries to convert it to string B by applying any of following three operations zero or more times.

AND Operation:
She will choose a pair of indices i and j such that i != j and perform following sequence of operations.


 result = Ai & Aj 


 Ai = result & Ai 


 Aj = result & Aj 



OR Operation:
She will choose a pair of indices i and j such that i != j and perform following sequence of operations.


 result = Ai | Aj 


 Ai = result | Ai 


 Aj = result | Aj 



XOR Operation:
She will choose a pair of indices i and j such that i != j and perform following sequence of operations.


 result = Ai ^ Aj 


 Ai = result ^ Ai 


 Aj = result ^ Aj 


Chef's mom is eagerly waiting to surprise him with his favourite gift and therefore, she wants to convert string A to string B as fast as possible. Can you please help her by telling her the minimum number of operations she will require? If it is impossible to do so, then let Chef's mom know about it.
Input
First line of input contains a single integer T denoting the number of test cases. T test cases follow.
First line of each test case, will contain binary string A.
Second line of each test case, will contain binary string B.
Output
For each test case, Print ""Lucky Chef"" (without quotes) in first line and minimum number of operations required to convert string A to sting B in second line if conversion is possible. Print ""Unlucky Chef"" (without quotes) in a new line otherwise.
Constraints


1 ≤ T ≤ 105


1 ≤ |A| ≤ 106


1 ≤ |B| ≤ 106


A != B


|A| = |B|


sum of |A| over all test cases does not exceed 106


sum of |B| over all test cases does not exceed 106


Subtasks


 Subtask #1 (40 points) : Sum of |A| & |B| over all test cases does not exceed 103


 Subtask #2 (60 points) : Sum of |A| & |B| over all test cases does not exceed 106


Example

Input
2
101
010
1111
1010
Output
Lucky Chef
2
Unlucky Chef

Explanation
Example case 1. 

Applying XOR operation with indices i = 1 and j = 2. Resulting string will be 011.
Then, Applying AND operation with indices i = 1 and j = 3. Resulting string will be 010.

Example case 2. 

It is impossible to convert string A to string B.
 ",BINOP,S10511847,PYTH,"
    t = int(raw_input())
    while t>0:
    	t-=1
    	a=list(raw_input())
    	b=list(raw_input())
    	if len(set(a))==1:
    		print ""Unlucky Chef""
    		break
    	cnt1 = 0
    	cnt2 = 0
    	for i in xrange(len(a)):
    		if a[i] != b[i]:
    			if a[i]=='1':
    				cnt1+=1
    			else:
    				cnt2+=1
    	print ""Lucky Chef""
    	print max(cnt1, cnt2)
    		

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese  and Russian.
Knights' tournaments were quite popular in the Middle Ages. A lot of boys were dreaming of becoming a knight, while a lot of girls were dreaming of marrying a knight on a white horse.

In this problem we consider one of these tournaments.


Let's us call a tournament binary, if it runs according to the scheme described below:


Exactly N knights take part in the tournament, N=2K for some integer K > 0.
Each knight has a unique skill called strength, described as an integer from the interval [1, N].
Initially, all the knights are standing in a line, waiting for a battle. Since all their strengths are unique, each initial configuration can be described as a permutation of numbers from 1 to N.
There are exactly K rounds in the tournament, 2K - i + 1 knights take part in the i'th round. The K'th round is called the final.
The i'th round runs in the following way: for each positive integer j ≤ 2K - i happens a battle between a knight on the 2∙j'th position and a knight on the 2∙j+1'th position. The strongest of two continues his tournament, taking the j'th position on the next round, while the weakest of two is forced to leave.
The only knight, who has won K rounds, is the winner. The only knight, who has won K - 1 rounds, but lost the final, is the runner-up.
	


As you can see from the scheme, the winner is always the same, an initial configuration doesn't change anything. So, your task is to determine chances of each knight to appear in the final.


Formally, for each knight you need to count the number of initial configurations, which will lead him to the final. Since the number can be extremly huge, you are asked to do all the calculations under modulo 109 + 9.

Input
The first line contains the only integer K, denoting the number of rounds of the tournament.
 
Output
Output should consist of 2K lines. The i'th line should contain the number of initial configurations, which lead the participant with strength equals to i to the final.
 
Constraints
1 ≤ K < 20
 
Examples
Input:
1

Output:
2
2

Input:
2

Output:
0
8
16
24
 
Explanation

In the first example we have N=2 knights. Let's consider each initial configuration that could appear and simulate the tournament.


(1, 2) -> (2)


(2, 1) -> (2)


In the second example we have N=4 knights. Let's consider some initial configurations that could appear and simulate the tournament.


(1, 2, 3, 4) -> (2, 4) -> (4)


(3, 2, 4, 1) -> (3, 4) -> (4)


(4, 1, 3, 2) -> (4, 3) -> (4)
 ",BINTOUR,S10533647,PYTH,"
    k=int(raw_input())
    def power(n,k):
    	value=1
    	
    	while k>0:
    		if not k%2==0:
    			value=(value*n)%1000000009
    		n=n*n
    		n=n%1000000009
    		k=k/2
    	return value
    def mod_inverse(n):
    	return power(n,1000000007)
    from math import factorial
    def fact(n):
    	value=1
    	for i in range(n,0,-1):
    		value=(value*i)%1000000009
    	return value
    def combination(n,r):
    	if r>n:
    		return 0
    	else:
    		
    		return (fact(n)*((mod_inverse(fact(r))*mod_inverse(fact(n-r)))%1000000009))%1000000009
    n=power(2,k)#no of knoights
    strength_oneside=n/2
    if n==2:
    	print 2
    	print 2
    else:
    	for i in range(1,n+1):
    		facto=fact(strength_oneside)
    
    		print combination(i-1,strength_oneside-1)*facto*facto*2

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese  and Russian.
Consider an infinite full binary tree (each node has two children except the leaf nodes) defined as follows. For a node labelled v its left child will be labelled 2*v and its right child will be labelled 2*v+1. The root is labelled as 1.
You are given N queries of the form i j. For each query, you have to print the length of the shortest path between node labelled i and  node labelled j.

Input
First line contains N, the number of queries. Each query consists of two space separated integers i and j in one line.
Output
For each query, print the required answer in one line.
Constraints

1 ≤ N ≤ 105
1 ≤ i,j ≤ 109

Example
Input:
3
1 2
2 3
4 3

Output:
1
2
3
Explanation
For first query, 1 is directly connected to 2 by an edge. Hence distance 1. ",BINTREE,S10386259,PYTH,"
    output = list()
    prime = list()
    val = raw_input()
    t = int(val)
    for i in range(t) :
    	nums = list()
    	counter = 0
    	string1 = raw_input()
    	nums = string1.split()
    	a1 = int(nums[0])
    	b1 = int(nums[1])
    	if a1>b1 :
    		a = a1
    		b = b1
    	else :
    		a = b1
    		b = a1	
    	c = a
    	d = b
    	lev1 = 0
    	lev2 = 0
    	while c > 0:
    		c = c/2
    		lev1 = lev1 + 1
    	while d > 0:
    		d = d/2
    		lev2 = lev2 + 1
    	diff = lev1 - lev2
    	while diff > 0 :
    		a = a/2
    		diff = diff - 1
    		counter = counter + 1
    	while True :
    		if a == b :
    			break
    		a = a/2
    		b = b/2
    		counter = counter + 2
    	output.append(counter)
    for i in range(t) :
    	print output[i]

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
Let's consider a rooted binary tree with the following properties:

The number of nodes and edges in the tree is infinite
The tree root is labeled by 1
A node labeled by v has two children: 2 × v (the left son of v) and 2 × v + 1 (the right son of v)


Here is an image of the first several tree layers of such a tree:

Let's consider four operations, that are allowed to apply during the tree traversal:

move to the left son - move from v to 2 × v
move to the right son - move from v to 2 × v + 1
move to the parent as a left son - move from v to v / 2 if v is an even integer
move to the parent as a right son - move from v to (v - 1) / 2 if v is an odd integer


It can be proven, that for any pair of two nodes u and v, there is only one sequence of such commands, that moves from u to v and visits each node of the tree at most once. Let's call such a sequence of commands a path configuration for a pair of nodes (u, v).
You are asked to process a series of the following queries:
You are given three integers n, u and v (1 ≤ u, v ≤ n). Count the pairs of nodes (w, t) (1 ≤ w, t ≤ n) such that the path configuration for (w, t) is the same with the path configuration for (u, v).
Input
The first line of input contains an integer Q denoting the number of queries to process.
Each of the next Q lines contains three space-separated integers n, u and v denoting a query.
Output
For each query, print the answer on a separate line.
Constraints

1 ≤ Q ≤ 20000
1 ≤ u, v ≤ n ≤ 109

Example
Input:
3
11 9 11
10 2 2
8 1 8

Output:
2
10
1
Explanation
In the first query from the example test case, you should count pairs (5, 7) and (9, 11).
In the second query from the example test case, you should count the following pairs: (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9) and (10, 10).
In the third query from the example test case, you should only count a pair (1, 8). ",BINTREEQ,S10068560,PYTH,"
    import math
    
    list_u = []
    list_v = []
    
    def find_level(n):
    	return int(math.floor(math.log(n,2))) + 1
    
    def find_lca(u, v):
    	while u != v:
    		while u > v:
    			if u % 2 == 0:
    				list_u.append(0)
    			else:
    				list_u.append(1)
    			u = u / 2
    		while v > u:
    			if v % 2 == 0:
    				list_v.append(0)
    			else:
    				list_v.append(1)
    			v = v / 2
    	list_u.reverse()
    	list_v.reverse()
    	return u
    
    if __name__ == ""__main__"":
    	Q = raw_input()
    	Q = int(Q)
    	while(Q > 0):
    		Q -= 1
    		del list_u[:]
    		del list_v[:]
    		ans = 0
    		n_u_v = raw_input()
    		n, u, v = n_u_v.split()
    		n = int(n)
    		u = int(u)
    		v = int(v)
    		lca = find_lca(u, v)
    		n_level = find_level(n)
    		lca_level = find_level(lca)
    		u_level = find_level(u)
    		v_level = find_level(v)
    		max_diff_level = max(u_level - lca_level, v_level - lca_level)
    		ans += 2**(n_level - max_diff_level - 1) - 1
    		complex_level = n_level - max_diff_level
    		start = 2**(complex_level - 1)
    		end = 2**(complex_level)
    		for i in xrange(start, end):
    			tmp = i
    			for item in list_u:
    				tmp = tmp*2 + item
    				if tmp > n:
    					break
    			if tmp > n:
    				break
    			tmp = i
    			for item in list_v:
    				tmp = tmp*2 + item
    				if tmp > n:
    					break
    			if tmp > n:
    				break
    			else:
    				ans += 1
    		print ans
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
Zombies zombies everywhere!! 
In a parallel world of zombies, there are N zombies. There are infinite number of unused cars, each of same model only differentiated by the their colors. The cars are of K colors.


A zombie parent can give birth to any number of zombie-children (possibly zero), i.e. each zombie will have its parent except the head zombie which was born in the winters by combination of ice and fire.


Now, zombies are having great difficulties to commute to their offices without cars, so they decided to use the cars available. Every zombie will need only one car. Head zombie called a meeting regarding this, in which he will allow each zombie to select a car for him.


Out of all the cars, the head zombie chose one of cars for him. Now, he called his children to choose the cars for them. After that they called their children and so on till each of the zombie had a car. Head zombie knew that it won't be a good idea to allow children to have cars of same color as that of parent, as they might mistakenly use that. So, he enforced this rule during the selection of cars.

Professor James Moriarty is a criminal mastermind and has trapped Watson again in the zombie world. Sherlock somehow manages to go there and met the head zombie. Head zombie told Sherlock that they will let Watson free if and only if Sherlock manages to tell him the maximum number of ways in which the cars can be selected by N Zombies among all possible hierarchies. A hierarchy represents parent-child relationships among the N zombies. Since the answer may be large, output the answer modulo 109 + 7. Sherlock can not compute big numbers, so he confides you to solve this for him.

Input
The first line consists of a single integer T, the number of test-cases.
Each test case consists of two space-separated integers N and K, denoting number of zombies and the possible number of colors of the cars respectively.

Output
For each test-case, output a single line denoting the answer of the problem.
Constraints

1 ≤ T ≤ 100
1 ≤ N ≤ 10^9
1 ≤ K ≤ 10^9

Subtasks

Subtask #1 : (10 points)


1 ≤ T ≤ 20
1 ≤ N, K ≤ 10



Subtask 2 : (20 points) 


1 ≤ T ≤ 10
1 ≤ N, K ≤ 10000



Subtask 3 : (70 points) 


1 ≤ T ≤ 100
1 ≤ N, K ≤ 10^9


Example
Input
2
2 2
3 3
Output:
2
12
Explanation
In the first sample test case, there are 2 zombies. Let us name them Z1 and Z2. Let one hierarchy be one in which Z1 is parent of Z2. There are 2 colors, suppose red and blue. If Z1 takes red, then Z2 should take a blue. If Z1 takes blue, then Z2 should take red. 
Note that one other possible hierarchy could be one in which Z2 is a parent of Z1. In that hierarchy also, number of possible ways of assigning cars is 2.
So there maximum number of possible ways is 2.


In the second example, we have 3 Zombies say Z1, Z2, Z3 and cars of 3 colors, suppose red, blue and green.
A hierarchy to maximize the number of possibilities is Z1 is the parent of Z2, Z2 is the parent of Z3.
Zombie Z1 can choose one of red, blue or green cars. Z2 can choose one of the remaining two colors (as its car's color can not be same as its parent car.). Z3 can also choose his car in two colors, (one of them could be color same as Z1, and other being the color which is not same as cars of both Z1 and Z2.). This way, there can be 12 different ways of selecting the cars.

 ",BIPIN3,S10063459,PYTH,"
        # cook your code here
        import math
        t = int(raw_input())
        while(t):
            n,k = raw_input().split()
            n = int(n)
            k = int(k)
            mod1  = 1000000007
            ans = 0
            ans = (pow(k-1,n-1,mod1)*k)%mod1
            print ans
            t = t-1 

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese  and Russian.
Consider the following game that is played on the field of the size of 1 x N cells. The cells are numbered from 1 to N. In the i-th cell there are two positive integers written - Ai and Bi.
The game is as follows. Initially, the player stands at the fictive cell with the index 0 that is located right before all the N cells of the board. Then, he makes moves. Each move consists in moving by no more than by K cells forward. The goal of the game is to reach the fictive N+1-th cell that is located right after all the N cells.
After the N+1-th cell is reached, the player's penalty is calculated. The penalty equals to max(Ax) * max(By), where x and y are the indices of the cells that were visited in between (during the movement to the N+1-th cell).
Please find the minimal possible penalty that can be reached in this game.
Input
The first line of input contains two single space separated integer numbers - N and K respectively.
Then, there are N lines, each containing a pair of signle space separated integers - Ai and Bi respectively.
Output
Output the minimal possible penalty on the first line.
Constraints


1 ≤ K ≤ N
1 ≤ N ≤ 100, 1 ≤ Ai, Bi ≤ 100 - 27 points.
1 ≤ N ≤ 1000, 1 ≤ Ai, Bi ≤ 32000 - 20 points.
1 ≤ N ≤ 5 * 105, 1 ≤ Ai, Bi ≤ 32000 - 53 points.


Example
Input:
5 3
1 5
2 4
3 3
4 2
5 1

Output:
9
 ",BNGAME,S3943760,PYTH,"
    #!/usr/bin/python
    N,K=raw_input().split(' ')         #  Scanning N  and K
    N=int(N) 			   #  Changing data types of N and K (because I scanned N and K as strings)
    K=int(K)			   #  """"
    
    ans=[]			#  This list contains the optimal product of (max of A and max of B) i.e ans[i] represents the minimum
    			#  for reaching step 0 to step i
    
    V=[]			# This list is just for storing A,B as a tuple i.e V[i]=(a_i,a_i)
    
    for n in range(N):      	       # Scanning a_i,b_i and appending them to V as a tuple (a_i,b_i)
    	a,b=raw_input().split(' ')
    	a=int(a)
    	b=int(b)
    	V.append((a,b))
    
    ans.append(V[0][0]*V[0][1])            # this is straight answer, because ans[0] is simply product of a0 and a0.    ### step(1) ###
    
    ################################################################
    i=1				       # In below loop I have iterated from i=1 to i=K-1 and solved for ans[i]. As an example let us take given 
    				       # test case (1,5),(2,4),(3,3),(4,2),(5,1) here K is 3 ,by step(1) ans[0] is 1*5 = 5. Now to find ans[1] 					       # we have two ways one is directly to block 1 and second is through block 0 and then block 1 in each 					       # case I calculated the product,and min product is stored in ans[1],i.e the two possible products are 					       # 2*4=8 and 5*4=20 So I stored ans[1]=8 and now for i=2 we have 3 cases....and evaluated the 3 						       # possible products and appended to ans[].similarly for i<=K-1
    while(i<K):
    	k=1
    	curr_a=V[i][0]
    	curr_b=V[i][1]
    	x=curr_a*curr_b
    	while(k<=K and i-k>=0):
    		temp=max(V[i-k][0],curr_a)*max(V[i-k][1],curr_b)
    		x=min(temp,x)
    		k=k+1
    	ans.append(x)
    	i=i+1
    ##################################################################	 
    				    # Here in this loop I iterated from i=K to N-1. this loop does the job similarly to the above loop but 					    # the change is that the block i can only be reached from prev k blocks so here x is 999999999999999
    	 			    # But in the previous loop x is the product of a_i and b_i itself as block i can be reached directly.
    i=K
    j=0
    while(i<N):
    	k=1
    	curr_a=V[i][0]
    	curr_b=V[i][1]
    	x=999999999999999999999
    	while(k<=K and i-k>=0):
    		temp=max(V[i-k][0],curr_a)*max(V[i-k][1],curr_b)
    		x=min(temp,x)
    		k=k+1
    	ans.append(x)
    	i=i+1
    				   # After the end of this loop. the ans list is [5,8,9,12,10]
    ##################################################################
    				# in this loop I searched for last K blocks and checked for answer i.e I searched for [9,12,10] as min is 9 so  			       # answer is 9
    i=N-1
    k=0
    x=99999999999999999999999
    while(k<K):
    	x=min(x,ans[i])
    	i=i-1
    	k=k+1
    print x
    

"
"
All submissions for this problem are available.

Recently Johnny have learned bogosort sorting algorithm. He thought that it is too ineffective. So he decided to improve it. As you may know this algorithm shuffles the sequence randomly until it is sorted. Johnny decided that we don't need to shuffle the whole sequence every time. If after the last shuffle several first elements end up in the right places we will fix them and don't shuffle those elements furthermore. We will do the same for the last elements if they are in the right places. For example, if the initial sequence is (3, 5, 1, 6, 4, 2) and after one shuffle Johnny gets (1, 2, 5, 4, 3, 6) he will fix 1, 2 and 6 and proceed with sorting (5, 4, 3) using the same algorithm. Johnny hopes that this optimization will significantly improve the algorithm. Help him calculate the expected amount of shuffles for the improved algorithm to sort the sequence of the first n natural numbers given that no elements are in the right places initially.
Input
The first line of input file is number t - the number of test cases. Each of the following t lines hold single number n - the number of elements in the sequence.
Constraints
1 <= t <= 150
2 <= n <= 150
Output
For each test case output the expected amount of shuffles needed for the improved algorithm to sort the sequence of first n natural numbers in the form of irreducible fractions.
Example

Input:
3
2
6
10

Output:
2
1826/189
877318/35343


",BOGOSORT,S10906322,PYTH,"
    def foo(a,b):
        x=a
        y=b
        while y!=0:
            r=x%y
            x=y
            y=r
            
        return ( a/x, b/x )
     
     
    em={0:(0,0),1:(1,1),2:(2,1)}
     
    piss=2
    tc=input()
    for xyz in xrange(tc):
        number=input()
        mass=max(piss,number)
        if(mass==piss):
            c,d=em[number]
            if d==1:
                print c
            else:
                print ""%d/%d"" %(c,d)
        else:
            for i in xrange(piss,number):
                m,n=em[i]
                o,p=em[i-1]
                em[i+1]=foo(n*p*((i+1)**2-3*i)+2*(i)*m*p-n*o,(2*i-1)*n*p)
            piss=number
           # print em
            c,d=em[piss]
            if d==1:
                print c
            else:
                print ""%d/%d"" %(c,d)

"
"
All submissions for this problem are available.
There are n+1 (0 < n <= 109, indexed 0..n) houses lying on a straight street. One day, they are bombed by an enemy. CodeChef is designing defence systems to protect the street from bombing. Each defense system can protect all houses in some interval, and a house can be protected by more than one system. A defence system can be also moved at any time. By agents, CodeChef knows the bombing schedule of the enemy. Each time they bomb a house and CodeChef wants to know how many systems are protecting that house.
Input

The first line contains two integers n, m (0 < m <= 250 000).
Each of the m following lines follows one of these:

P u v: CodeChef adds a defence system protecting all houses from the u-th house to the v-th house (0 <= u <= v <= n). All systems will be indexed by order of appearance in the input, starting from 1.
M i d: CodeChef moves the i-th system by d houses, d < 0 means moving nearer the 0-th house, and d > 0 means moving away (that is, if the i-th system covers houses u through v, it is moved to instead cover houses w=u+d through t=v+d). After being moved the system will protect from the w-th house to t-th house where 0 <= w <= t <= n.
B x: The enemy bombs the x-th house.



Output
For each time of bombing by the enemy (by the appearance in the input), output on a single line a number of systems protecting that house.
Example

Input:
7 5
P 1 4
P 3 5
B 3
M 2 1
B 3

Output:
2
1
 ",BOMBING,S497139,PYTH,"
    def countgreater(a,key,low,high):
        if low>high:
            return 0
        if a[low]>key:
            return (high-low+1)
        elif a[high]<key:
            return 0
        mid=(low+high)>>1
        if a[mid]>key:
            return (high-mid+1)+countgreater(a,key,low,mid-1)
        elif a[mid]<=key:
            return countgreater(a,key,mid+1,high)
    
    def countlesser(a,key,low,high):
        if low>high:
            return 0
        if a[high]<key:
            return (high-low+1)
        elif a[low]>key:
            return 0
        mid=(low+high)>>1
        if a[mid]<key:
            return (mid-low+1)+countlesser(a,key,mid+1,high)
        elif a[mid]>=key:
            return countlesser(a,key,low,mid-1)
    
    def insert(a,key,low,high):
        if high<low:
            a.append(key)
            return
        if low==high:
            if a[low]>=key:
                a.insert(low,key)
            elif a[low]<key:
                a.insert(low+1,key)
            return
        mid=(low+high)>>1
        if a[mid]<=key:
            insert(a,key,low,mid-1)
        elif a[mid]>key:
            insert(a,key,mid+1,high)
    
    def delete(a,key,low,high):
        mid=(high+low)>>1
        if a[mid]==key:
            a.pop(mid)
            return
        elif a[mid]>key:
            delete(a,key,low,mid-1)
            return
        else:
            delete(a,key,mid+1,high)
            return
    
    
    nm=raw_input()
    x=nm.split()
    n=int(x[0])
    m=int(x[1])
    length=0
    lst1=[]
    lst2=[]
    lst3=[]
    lst4=[]
    length=0
    for i in range(m):
        x=raw_input()
        x=x.split()
        if len(x)==2:
            ans=length
            ans1=countgreater(lst1,int(x[1]),0,length-1)
            #print ""Count Greater in lst1 than"", int(x[1]), ""="",ans1 
            ans2=countlesser(lst2,int(x[1]),0,length-1)
            #print ""Count lesser in lst2 than"", int(x[1]), ""="", ans2
            print ans-ans1-ans2
        else:
            if x[0]=='P':
                insert(lst1,int(x[1]),0,length-1)
                insert(lst2,int(x[2]),0,length-1)
                lst3.append(int(x[1]))
                lst4.append(int(x[2]))
                length=length+1
                """"""
                for k in range(length):
                    print lst1[k],
                print
                for k in range(length):
                    print lst2[k],
                print
                """"""
            elif x[0]=='M':
                delete(lst1,lst3[int(x[1])-1],0,length-1)
                delete(lst2,lst4[int(x[1])-1],0,length-1)
                insert(lst1,lst3[int(x[1])-1]+int(x[2]),0,length-2)
                insert(lst2,lst4[int(x[1])-1]+int(x[2]),0,length-2)
                """"""
                for k in range(length):
                    print lst1[k],
                print
                for k in range(length):
                    print lst2[k],
                print
                """"""
                
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
Chef Watson uses a social network called ChefBook, which has a new feed consisting of posts by his friends. Each post can be characterized by f - the identifier of the friend who created the post, p - the popularity of the post(which is pre-calculated by ChefBook platform using some machine learning algorithm) and s - the contents of the post which is a string of lower and uppercase English alphabets.
Also, Chef has some friends, which he has marked as special.
The algorithm used by ChefBook for determining the order of posts in news feed is as follows:

Posts of special friends should be shown first, irrespective of popularity. Among all such posts the popular ones should be shown earlier.
Among all other posts, popular posts should be shown earlier.


Given, a list of identifiers of Chef's special friends and a list of posts, you have to implement this algorithm for engineers of ChefBook and output the correct ordering of posts in the new feed. 
Input
First line contains N, number of special friends of Chef and M, the number of posts. Next line contains N integers A1, A2, ..., AN denoting the identifiers of special friends of Chef. Each of the next M lines contains a pair of integers and a string denoting f, p and s, identifier of the friend who created the post, the popularity of the post and the contents of the post, respectively. It is guaranteed that no two posts have same popularity.
Output
Output correct ordering of posts in news feed in M lines. Output only the contents of a post.

Constraints

1 ≤ N, M ≤ 103
1 ≤ Ai, f, p ≤  105
1 ≤ length(s) ≤  100

Example
Input:
2 4
1 2
1 1 WhoDoesntLoveChefBook
2 2 WinterIsComing
3 10 TheseViolentDelightsHaveViolentEnds
4 3 ComeAtTheKingBestNotMiss

Output:
WinterIsComing
WhoDoesntLoveChefBook
TheseViolentDelightsHaveViolentEnds
ComeAtTheKingBestNotMiss


Explanation

First we should show posts created by friends with identifiers 1 and 2. Among the posts by these friends, the one with more popularity should be shown first.
Among remaining posts, we show those which are more popular first.
 ",BOOKCHEF,S11939070,PYTH,"
        highest = []
        c=0
        for i in xrange(len(arr)):
            if (friends[c] == arr[i][0]):
                highest.append(arr[i])
                c+=1
                i=0
                if c==(len(friends)):
                    break
        highest = sorted(highest, key=itemgetter(1), reverse=True)
        for i in highest:
            sys.stdout.write(i[2]+'\n')
        c=0
        for i in xrange(len(arr)):
            if highest[c] in arr:
                arr.remove(highest[c])
                c+=1
                i=0
                if c==(len(highest)):
                    break
        return sorted(arr, key=itemgetter(1), reverse=True)

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
It's autumn now, the time of the leaf fall.
Sergey likes to collect fallen leaves in autumn. In his city, he can find fallen leaves of maple, oak and poplar. These leaves can be of three different colors: green, yellow or red.
Sergey has collected some leaves of each type and color. Now he wants to create the biggest nice bouquet from them. He considers the bouquet nice iff all the leaves in it are either from the same type of tree or of the same color (or both). Moreover, he doesn't want to create a bouquet with even number of leaves in it, since this kind of bouquets are considered to attract bad luck. However, if it's impossible to make any nice bouquet, he won't do anything, thus, obtaining a bouquet with zero leaves.
Please help Sergey to find the maximal number of leaves he can have in a nice bouquet, which satisfies all the above mentioned requirements.
Please note that Sergey doesn't have to use all the leaves of the same color or of the same type. For example, if he has 20 maple leaves, he can still create a bouquet of 19 leaves.
Input
IThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.""
The first line of each test case contains three space-separated integers MG MY MR denoting the number of green, yellow and red maple leaves respectively.
The second line contains three space-separated integers OG OY OR denoting the number of green, yellow and red oak leaves respectively.
The third line of each test case contains three space-separated integers PG PY PR denoting the number of green, yellow and red poplar leaves respectively.
Output
For each test case, output a single line containing the maximal amount of flowers in nice bouquet, satisfying all conditions or 0 if it's impossible to create any bouquet, satisfying the conditions.
Constraints


1 ≤ T ≤ 10000
Subtask 1 (50 points): 0 ≤ MG, MY, MR, OG, OY, OR, PG, PY, PR ≤ 5
Subtask 2 (50 points): 0 ≤ MG, MY, MR, OG, OY, OR, PG, PY, PR ≤ 109

 
Example
Input:
1
1 2 3
3 2 1
1 3 4

Output:
7

Explanation
Example case 1. We can create a bouquet with 7 leaves, for example, by collecting all yellow leaves. This is not the only way to create the nice bouquet with 7 leaves (for example, Sergey can use all but one red leaves), but it is impossible to create a nice bouquet with more than 7 leaves. ",BOUQUET,S11979827,PYTH,"
    a = int(raw_input())
    for _ in xrange(a):
    	h = []
    	b = map(int,raw_input().split())
    	c = map(int,raw_input().split())
    	d = map(int,raw_input().split())
    	e = reduce(lambda x,y: x+y,b)
    	f = reduce(lambda x,y: x+y,c)
    	g = reduce(lambda x,y: x+y,d)
    	if e%2==0:
    		e = 0
    	if f%2==0:
    		f = 0
    	if g%2==0:
    		g = 0
    	for i in xrange(3):
    		sum = 0
    		sum+=b[i]+c[i]+d[i]
    		if sum%2==0:
    			continue
    		else:
    			h.append(sum)
    	print max(e,f,g,max(h))

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.

	A valid parentheses sequence is a non-empty string where each character is either '(' or ')', which satisfies the following constraint:


You can find a way to repeat erasing adjacent pairs of parentheses '()' until it becomes empty.


	For example, '(())' and '()((()()))' are valid parentheses sequences, but ')()(' and '(()' are not.


	Mike has a valid parentheses sequence. He really likes everything about his sequence, except the fact that it is quite long. So Mike has recently decided that he will replace his parentheses sequence with a new one in the near future. But not every valid parentheses sequence will satisfy him. To help you understand his requirements we'll introduce the pseudocode of function F(S):


	FUNCTION F( S - a valid parentheses sequence )
	BEGIN
		balance = 0
		max_balance = 0
		FOR index FROM 1 TO LENGTH(S)
		BEGIN
			if S[index] == '(' then balance = balance + 1
			if S[index] == ')' then balance = balance - 1
			max_balance = max( max_balance, balance )
		END
		RETURN max_balance
	END


	In other words, F(S) is equal to the maximal balance over all prefixes of S.


	Let's denote A as Mike's current parentheses sequence, and B as a candidate for a new one. Mike is willing to replace A with B if F(A) is equal to F(B). He would also like to choose B with the minimal possible length amongst ones satisfying the previous condition. If there are several such strings with the minimal possible length, then Mike will choose the least one lexicographically, considering '(' to be less than ')'.


	Help Mike!

Input

	The first line of the input contains one integer T denoting the number of testcases to process.


	The only line of each testcase contains one string A denoting Mike's parentheses sequence. It is guaranteed that A only consists of the characters '(' and ')'. It is also guaranteed that A is a valid parentheses sequence.

Output

	The output should contain exactly T lines, one line per each testcase in the order of their appearance. The only line of each testcase should contain one string B denoting the valid parentheses sequence that should be chosen by Mike to replace A.

Constraints
1 ≤ T ≤ 5;
1 ≤ |A| ≤ 100000(105).
Example
Input:
1
()((()()))

Output:
((()))

 ",BRACKETS,S12104032,PYTH,"
    def maximum_balance(a):
        balance, result = 0, 0
        for i in range(len(a)):
            if a[i] == '(':
                balance += 1
            else:
                balance -= 1
            result = max(result, balance)
        s = str()
        for i in range(result):
            s += '('
        for i in range(result):
            s += ')'
        return s
    
    test_cases = int(raw_input())
    while test_cases != 0:
        test_cases -= 1
        string = raw_input()
        print(maximum_balance(string))
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese  and Russian.
Chef is judging a game called ""Broken telephone"". There are total N players taking part in the game. They are all sitting in a line. In the start of the game, first player is given a secret message written on a sheet of paper. Then they keep sending the message by whispering it to the player sitting immediate right to one and so on until it reaches the last person. 
Finally, the message received by the last player is compared with the message said by first player. If these messages aren't equal, there is someone who has misheard the message or whispered it wrongly to the next player. If messages is equal, then the players win and receive a tasty chocolate. 
Note that first player receives the message on a sheet of paper, thus he cannot mishear it.
As Chef wants to be sure that every player has fulfilled his/ her role in the game, so he asks everyone to state their received messages after the end of the game. You are given an array A of N integers denoting messages received by each person.
Please help Chef to find the number of players that could mishear the message or whisper it wrongly.
Input

The first line of the input contains an integer T denoting the number of test cases. 
The first line of each test case contains a single integer N denoting the number of players
The second line contains N space-separated integers A1, A2, ..., AN denoting the messages of players.

Output

For each test case, output a single line containing an integer corresponding to the number of players that could mishear the message or whisper it wrongly.

Constraints and Subtasks

1 ≤ T ≤ 5
1 ≤ Ai ≤ 109

Subtask 1: 40 points

2 ≤ N ≤ 103

Subtask 2: 60 points

2 ≤ N ≤ 105

Example
Input:
3
7
1 1 1 3 3 3 2
5
1 3 1 1 1
4
5 5 5 5

Output:
4
3
0
Explanation

Example 1: The 3-rd, 4-th, 6-th and 7-th player could mishear the message or whisper it wrongly.
Example 2: First 3 players could mishear the message or whisper it wrongly.
 ",BROKPHON,S11993456,PYTH,"
    t  = int(raw_input())
    while t:
        n = int(raw_input())
        a = map(int,raw_input().split())
        c = 0
        l =[0]*n;
        for i in range(0,n-1):
            if a[i]!=a[i+1]:
                if l[i]==0 and l[i+1]==0:
                    c = c+2
                    l[i]=1
                    l[i+1]=1
                else:
                    l[i]=1;
                    l[i+1]=1;
                    c = c+1;
        print c
        t = t-1;
    

"
"
All submissions for this problem are available.
CodeChef Inc. owns a rectangular piece of land sized w×h.  Its edges are parallel to the axes, with the bottom-left corner at (0,0) and top-right corner at (w,h).  They intend to build a new head office within this land.  The new office will be a square whose center is located at a point with integer coordinates, and whose diagonals are parallel to the axes and have length 2*d.
Unfortunately, there are n barricades on the land, some of which may need to be removed in order for the office to be built.  The (i)th barricade is located at (Xi, Yi) and will cost Ci to remove.  The office may only be built once all points it covers (including the boundaries) are free of barricades.

Request
Help them find the minimum total cost of barricade removal.
Input

The first line contains the integers w,h,d,n, respectively.
Within following n lines, the i-th line contains the integers Xi,Yi,Ci respectively.


Output
Output on a single line an integer which is the minimum cost found.
Example
Input:

4 3 1 4
1 3 5
3 3 4
2 2 1
2 1 2

Output:

2
Limitations

2≤w,h≤1 000
0≤n≤200 000
2≤2d≤min(w,h)
0<Ci≤10 000
All the listed barricades are inside or on the boundaries of the CodeChef’s land.
There is at most one barricade at each point.


",BUILDING,S292809,PYTH,"
    #!/usr/bin/env python
    #?
    
    from math import sqrt, floor
    
    C = 2 * sqrt(2)
    X, Y = 0, 1
    
    def valid((w, h), W, H):
        return 0 <= w <= W and 0 <= h <= H
    
    def get(W,H,d, n, barricades):
        minn = 10000*200000 + 1
        for w in xrange(W+1):
            for h in xrange(H+1):
                center = w, h
                up = w, h + d
                left = w - d, h
                right = w + d, h
                bottom = w, h - d
                if not (valid(up, W, H) and valid(left, W, H) and valid(right, W, H) and valid(bottom, W, H)): continue
                
                up = map(int, up)
                left = map(int, left)
                right = map(int, right)
                bottom = map(int, bottom)
                
                cost = 0
                removes = []
                
                #center, up, left
                for y in xrange(center[Y], up[Y]+1):
                    for x in xrange(center[X], left[X] + (y - center[Y]) - 1, -1):
                        c = barricades.get((x, y))
                        if c is None:
                            c = 0
                        else:
                            del barricades[(x, y)]
                            removes.append((x, y, c))
                        cost += c
                
                #center, up, right
                for y in xrange(center[Y], up[Y]+1):
                    for x in xrange(center[X], right[X] - (y - center[Y]) + 1):
                        c = barricades.get((x, y))
                        if c is None:
                            c = 0
                        else:
                            del barricades[(x, y)]
                            removes.append((x, y, c))
                        cost += c
                    
                #center, bottom, right
                for y in xrange(center[Y], bottom[Y]-1, -1):
                    for x in xrange(center[X], right[X] - (center[Y] - y) + 1):
                        c = barricades.get((x, y))
                        if c is None:
                            c = 0
                        else:
                            del barricades[(x, y)]
                            removes.append((x, y, c))
                        cost += c
                
                #center, bottom, left
                for y in xrange(center[Y], bottom[Y]-1, -1):
                    for x in xrange(center[X], left[X] + (center[Y] - y) - 1, -1):
                        c = barricades.get((x, y))
                        if c is None:
                            c = 0
                        else:
                            del barricades[(x, y)]
                            removes.append((x, y, c))
                        cost += c
                
                for x, y, c in removes:
                    barricades[(x, y)] = c
                
                minn = min(minn, cost)
        return minn
    
    def main():
        w,h,d,n = map(int, raw_input().split())
        barricades = {}
        for _ in xrange(n):
            x, y, c = map(int, raw_input().split())
            barricades[(x, y)] = c
        print get(w,h,d, n, barricades)
    
    if __name__ == '__main__':
        main()

"
"
All submissions for this problem are available.
Each cell of an N x N grid is either a 0 or a 1. You are given two such N x N grids, the initial grid and the final grid. There is a button against each row and each column of the initial N x N grid. Pressing a row-button toggles the values of all the cells in that row, and pressing a column-button toggles the values of all the cells in that column. You are required to find the minimum number of button presses required to transform the grid from the initial configuration to the final configuration, and the buttons that must be pressed in order to make this transformation.
Edit: When the initial and the final configurations are the same, print ""0"".
Input
The first line contains t, the number of test cases (about 10). Then t test cases follow.
Each test case has the following form:
    * The first line contains n, the size of the board (1 ≤ n ≤ 1000).
    * n lines follow. The ith line contains n space separated integers representing the ith row of the initial grid. Each integer is either a 0 or a 1.
    * n lines follow, representing the final grid, in the same format as above.
Output
For each test case, output the number of row-button presses, followed by the row buttons that must be pressed. Print the number of column-button presses next, followed by 0-indexed indices of the column buttons that must be pressed. The total number of button presses must be minimized.
Output ""-1"" if it is impossible to achieve the final configuration from the initial configuration. If there is more than one solution, print any one of them.
Example

Input:
1
3
0 0 0
1 1 0
1 1 0
1 1 0
1 1 1
1 1 1

Output:
1
0 
1
2 

",BUTTONS,S1106729,PYTH,"
    #!/usr/bin/env python
    import sys
    
    n_tests = int(sys.stdin.readline())
    
    def read_test(f):
    	n = int(f.readline())
    	I = [ [ bool(int(v)) for v in f.readline().split() ] for _ in  range(0,n) ]
    	F = [ [ bool(int(v)) for v in f.readline().split() ] for _ in  range(0,n) ]
    	return n,I,F
    
    def is_valid(r,c,f,i):
    	return r^c^f^i
    
    def run_test(f):
    	n,I,F = read_test(f)
    	s = (I[0][0]==F[0][0])
    	R = [ i!=f for i,f in zip(I[0],F[0]) ]
    	C = [ I[j][0]==F[j][0] for j in range(0,n)]
    	if s:
    		C = [ (not c) for c in C]
    	for i in range(0,n):
    		for j in range(0,n):
    			v = is_valid(R[j],C[i],F[i][j],I[i][j])
    			if v:
    				print('-1')
    				return
    	#Minimize presses by either taking solution computed or negate it
    	nr = sum(R)
    	nc = sum(C)
    	m1 = nr+nc
    	m2 = 2*n-m1
    	if m1 > m2:
    		R = [ (not r) for r in R]
    		C = [ (not c) for c in C]
    	Lr = [ i for i,f in zip(range(0,n),R) if f]
    	Lc = [ i for i,f in zip(range(0,n),C) if f]
    	print(str(len(Lc)))
    	for i in Lc:
    		print(str(i))
    	print(str(len(Lr)))
    	for i in Lr:
    		print(str(i))
    	return
    
    
    for test in range(0,n_tests):
    	run_test(sys.stdin)
    
    
    

"
"
All submissions for this problem are available.
Emily is coming back from her two-week vacation at the other continent. But when Emily arrived at the airport, she realized that she had got no presents for her K friends! She still had some time before her flight, so she went for a walk around the airport hoping to find something suitable.
Soon Emily found a candy store and decided to buy some of her favorite candies for her friends. The store offers N packs of these candies, where pack i contains Ai candies.
Another reason Emily decided to buy candies is that she is fond of collecting empty candy packs from various parts of the world. That's why she decided to buy exactly M packs and present the friends with the candies and keep the packs for her collection. Emily would also like the total number of candies to be divisible by K so that an equal distribution of candies between friends is possible. Among all possible sets of packs, she would like to buy a set with the smallest possible total number of candies (money is the reason).
Your task is to help Emily, of course.
Input
The first line of the input file contains an integer T -- the number of test cases (no more than 5). T test cases follow, and each test case consists of two lines. The first of them contains three integers N, M and K (1 ≤ M ≤ N ≤ 50000, 1 ≤ K ≤ 20). The second of them contains N integers Ai (1 ≤ Ai ≤ 109).
Output
For each test case, output just one line containing the smallest possible total number of bought candies, or -1 if it's impossible to buy exactly M packs so that the total number of candies is divisible by K.
Example

Input:
2
5 3 5
1 2 3 4 5
6 3 4
9 5 1 7 3 7

Output:
10
-1

Explanation:

In the first test case, it's impossible to buy one candy per friend as three smallest packs contain 6 candies all together. Two candies per friend is possible though -- for example, if you buy packs with 1, 4 and 5 candies.
In the second test case, buying 3 packs implies buying an odd number of candies, which is impossible to distribute equally among 4 friends.
",BUYING,S3001593,PYTH,"
    def main():
      t = int(raw_input())
      for i in range(t):
        n,m,k = map(int,raw_input().split())
        ai= map(int,raw_input().split())
        ai.sort()
        s=-1
        for a in combinations(ai, m):
        	s1=sum(a)
        	if s1%k==0:
        		s=s1
        		break
        print s
         
    def combinations(iterable, r):
        pool = tuple(iterable)
        n = len(pool)
        if r > n:
            return
        indices = range(r)
        yield tuple(pool[i] for i in indices)
        while True:
            for i in reversed(range(r)):
                if indices[i] != i + n - r:
                    break
            else:
                return
            indices[i] += 1
            for j in range(i+1, r):
                indices[j] = indices[j-1] + 1
            yield tuple(pool[i] for i in indices)
    main()

"
"
All submissions for this problem are available.
Banknotes in the state of Strangeland don't have any regulated values like 1, 5, 10, 20, 50, 100, etc. In fact, it's possible to see any positive integer on a banknote of Strangeland. Indeed, this isn't the most convenient thing.
Ann is working as a sweet seller at a shop in Strangeland. Every kind of sweets in this shop has its own cost, and sweets of the same kind have the same cost.
Customers in Strangeland are strange. A customer points at some kind of sweets and gives several banknotes to the seller. This means that he wants to buy a positive number of sweets of that kind. He doesn't tell the exact number of sweets he wants to buy. The only thing Ann knows is: an 'adequate' customer won't give any extra banknotes. It means that if you throw away any banknote, the resulting amount of money won't be enough to buy the wanted number of sweets.
Ann has to determine the number of sweets the customer wants. Help Ann write a program which determines this number or tells that it's impossible.
Input
The first line of the input contains a single integer T, the number of test cases (no more than 20). T test cases follow. Each test case consists of two lines. The first of these lines contains two integers N and X (1 ≤ N, X ≤ 100) separated by a single space. N is the number of banknotes given by the customer. X is the cost of a single sweet of the chosen kind. The second of these lines contains N space-separated integers Ai (1 ≤ Ai ≤ 100), the values of the banknotes.
Output
For each test case output exactly one line containing a single integer:

-1 if the customer is inadequate and has given extra banknotes, or
K, the number of sweets the customer wants to buy. If there are several possible answers, output the largest of them.

Example

Input:
3
4 7
10 4 8 5
1 10
12
2 10
20 50

Output:
-1
1
7
Explanation
In the first test case, the total amount of money received from the customer is 27. He can't buy more than 3 sweets with this amount. If you throw away the banknote of value 5 (or of value 4), it will still be possible to buy 3 sweets. Hence the customer is inadequate.
In the second test case, it's clear that he wants to buy just one sweet (note that this number should be positive).
In the third test case, the total amount of money received is 70, which is enough for 7 sweets. The customer might want to buy only 6 sweets, but we are interested in the largest possible answer.
",BUYING2,S1491532,PYTH,"
    #! /usr/bin/python2.7
    import sys
    
    def main(filename):
        #f = open(filename,'ru')
        #T = int(f.readline())
        try:
            T = int(raw_input(""T test Cases : ""))
            T = int(T)
        except ValueError:
            sys.exit(0)
        if T < 1 or T > 20:
            sys.exit(0)
            
        #totlines = f.readlines()
        #totlines.pop(0)
        while T > 0:
            N = int(raw_input(""Enter number of notes""))
            X = int(raw_input(""Cost of sweets""))
            
            if  N >= 1 and X <= 100:
                 
                for a in range(0,N):
                    a = []
                    z = int(raw_input(""enter value of note""))
                    a.append(z)
                    
                s = sum(a)
                m = min(a)
                K = s/X
                cost = K*X
                if (X>0) and (cost>(s-m)):
                    print K
                else:
                    print -1
                        
                T = T - 1
    
            else: 
                sys.exit(0)
                
    if __name__ == '__main__':
        main(sys.argv[1])
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese , Russian and  Vietnamese
Chef and his best friend Aleksa are into mathematical games these days. Today, they have some ( ≥ 0 ) black cells represented as B, and a white cell represented as W, lying randomly in a straight line.
They have decided to play with these cells. In a move, a player chooses some ( > 0 ) black cells lying on any one side of the white cell and remove them. It should be noted that a player is not allowed to choose black cells from both side of the given white cell. Both the players alternate their moves, and play optimally. The player who is unable to move in his respective turn will lose the game.
Aleksa, being a girl, has a habit of playing first. But Chef is fairly smart himself, and will not play the game if he is going to lose it. Therefore, he wants to know the winner beforehand. Can you tell him who is going to win the game for the given configuration of cells?
Input
 First line of input contains a single integer T denoting the number of test cases. First and the only line of each test case contains a string S consisting of the characters 'B' and 'W', denoting black and white cells, respectively.
Output
For each test case, output ""Chef"" if chef wins the game for the given configuration. Else print ""Aleksa"". (quotes for clarity only).
Constraints

1 ≤ T ≤ 10
1 ≤ |S| ≤ 10000
S contains exactly 1 white cell.

Scoring

 Subtask 1:  1 ≤ T ≤ 10, 1 ≤ |S| ≤ 10 : ( 30 pts )
 Subtask 2:  1 ≤ T ≤ 10, 1 ≤ |S| ≤ 100 : ( 30 pts )
 Subtask 3:  1 ≤ T ≤ 10, 1 ≤ |S| ≤ 10000 : ( 40 pts )

Example

Input
3
W
BW
BWBB

Output
Chef
Aleksa
Aleksa

 Explanation

 Test 1 : Aleksa cannot make a move in her first turn as there is no black cell in the given configuration.
 Test 2 : Aleksa can remove 1 black cell lying on the left of white cell in her turn. But then, Chef cannot make a move in his turn as there will be no black cells left.
 Test 3 : Figure out yourself.
 ",BWCELL,S11655070,PYTH,"
    t=int(raw_input())
    for k in range (t):
        s=raw_input()
        x=s.find(""W"")
        y=len(s)-1-x
        if(x==0):
            if(y!=0):
                print ""Aleksa""
            else:
                print ""Chef""
        elif(y==0):
            if(x!=0):
                print ""Aleksa""
            else:
                print ""Chef""
        elif(x==1):
            if(y==1):
                print ""Chef""
            else:
                print ""Aleksa""
        else:
            if(y==1):
                print ""Aleksa""
            else:
                print ""Chef""
        
                
                    
    

"
"
All submissions for this problem are available.

How many ways are there to place a black and a white knight on an N * M chessboard such that they do not attack each other? The knights have to be placed on different squares. A knight can move two squares horizontally and one square vertically, or two squares vertically and one square horizontally. The knights attack each other if one can reach the other in one move.


Input :


The first line contains the number of test cases T. Each of the next T lines contains two integers N and M.


Output :


Output T lines, one for each test case, each containing the required answer for the corresponding test case.


Sample Input :
3
2 2
2 3
4 5


Sample Output :
12
26
312


Constraints :
1 <= T <= 10000
1 <= N,M <= 100000
 ",BWKNIGHT,S10957290,PYTH,"
    t = int(raw_input())
    for ii in range(t):
        n , m = raw_input().split()
        n=int(n)
        m=int(m)
        if n<m:
            n,m = m,n
        if n==1 or m==1:
            print n*(n-1)
            continue
        print (n*m) * (n*m-1) - 4*( (n-1)*(m-2) + (n-2)*(m-1))
        
            
        

"
"
All submissions for this problem are available.
This problem was part of the CodeChef April Challenge.  All user submissions for this contest problem are publicly available here.
The following a tie breaker problem.  The best solution will receive one point.  All other successful answers will be scored on a curve and receive a fraction of a point based on how close they come to the best answer.
Let's have some fun with soap bubbles... We drive several sticks vertically into a flat surface (so that they look like points from above), and spread a thin film of soap over all of them. The soap film tends to minimize the area of its surface, and eventually becomes very thin, with surfaces turning into lines spread over all points. When everything has settled down, we can assume that the ""bubble"" we have is in fact a set of line segments, which connect all of our sticks into one network (possibly via some intermediate points which can also be the endpoints of lines).
Input
First, 1<=n<=1000, the number of starting points to connect. Then, n pairs of numbers follow, representing the coordinates of sticks which the soap film will connect.
Output
First, you should output the number m of intermediate points you create. Then, the next m pairs of numbers are coordinates of intermediate points.
Then, you should output e, the number of soap-bubble lines you create. Then, the next 2*e numbers represent the indexes of points which are connected by the given line. Each index i should be a number 0<=i < n+m. If i < n, then it represents the i-th input point (stick). If i>=n, then it corresponds to the (i-n)-th intermediate point.
Scoring

Your goal is to minimize the score obtained in this problem.

As longer lines tends to get thinner, for each line segment of length t, you will receive t / max(1, ln(t)) penalty points, where ""ln"" is the logarithm in the natural base.
You will additionally receive ln(m+1) penalty points if your solution uses m intermediate points.

If the soap film given at output does not span  all the input points (connecting them into a network), your solution will be judged as incorrect.
Example

Input:
3
0.0 0.0
0.0 3.0
4.0 0.0

Output:
1
1.0 1.0
3
0 3
1 3
2 3

Score:
7.090148
 ",BX,S5302368,PYTH,"
    n=raw_input('');
    p=raw_input('');
    x=p.split();
    temp=0;
    if ((len(x))==int(n)):
        for i in range(int(n)):
            j=0;
            while ((j>=0) & (j<n)& (j!=i)&(j!=i+1)&(j!=i-1)):
                price=int(x[j])+int(x[i]);
                if (price>temp):
                    temp=price;
                j=j+1;
        print ""Highest price:"", temp;
    else:
        print ""Enter correct no.of goods"";
            
    

"
"
All submissions for this problem are available.
A long school holiday has come, and you decided to visit the famous Byte Island. You know there are only two types of Bytelandians: Byteknights and Byteknaves. A Byteknight always tells the truth, whereas a Byteknave always lies.
It is known that there are N Bytelandians in the island, and now you meet all of them. You are curious about their types. Because you are a smart logician, you don't want to ask them questions that immediately reveal their types (that's too boring). Instead, to each Bytelandian you ask, ""How many Byteknights are there here?""
To your surprise, they also don't answer your questions directly. Instead, the i-th Bytelandian answers of the form ""The number of Byteknights here is between ai and bi, inclusive"". You record all answers in your pocket note.
Now that you have collected all information you need, determine the type of each Bytelandian.
Input
The first line contains a single integer T, the number of test cases. T test cases follow. The first line of each test case contains a single integer N. N lines follow. The i-th line contains two integers ai and bi.
Output
For each test case, output two lines. In the first line, output a single integer indicating the number of different solutions, modulo 1000000007. In the next line, output the lexicographically smallest solution. A solution is a string consisting of N characters, where the i-th character of the string is '1' if the i-th Bytelandian is a Byteknight, or '0' in case of a Byteknave. It is guaranteed that there is at least one valid solution.
Example

Input:
3
1
0 1
4
1 4
2 4
3 4
4 4
3
1 2
0 0
1 3

Output:
1
1
5
0000
1
101
Constraints

1 <= T <= 5
1 <= N <= 50000
0 <= ai <= bi <= N

",BYTEISLE,S1556363,PYTH,"
    #!/usr/bin/python2
    
    from sys import stdin
    
    def readprob():
            l = []
            n = int(stdin.readline())
            for i in range(n):
                    l.append(map(int,stdin.readline().split(' ')))
            return l
    
    def solve(l):
            s = []
            for n in range(0, len(l)+1):
                    t = ''.join('1' if n >= i[0] and n <= i[1] else '0' for i in l)
                    if t.count('1') == n:
                            s.append(t)
            return s
    
    n = int(stdin.readline())
    for i in range(n):
            l = readprob()
            s = solve(l)
            print len(s)
            s.sort()
            print s[0]

"
"
All submissions for this problem are available.
You are given a sequence w of integers. A mismatch is any such pair of neighbouring elements of sequence w[i] and w[i+1], that w[i]>w[i+1]+1.
As long as there is any mismatch, you solve it by swapping the mismatching numbers. Given an input sequence, calculate one of the possible output mismatch-less sequences obtained by successively solving mistmatches by swapping.
Input
First - 1<=t<=10 - the number of tests. For each test: first - 1<=n<=100000. Then, n nonnegative integers.
Output
For each test, you should output exactly n integers.
Example

Input:
2
4
4 3 2 1
4
4 3 1 2

Output:
4 3 2 1
1 4 3 2
 ",C1,S166270,PYTH,"
    t=int(raw_input(""Enter no. of Test Cases :""))
    for j in range (0,t):
        n=int(raw_input(""Enter no. of Integers :""))
        list=[]
        for i in range (0,n):
            list.append(int(raw_input()))
            
        while(1):
            c=0
            for i in range (0,n-1):    
                if list[i] > list[i+1]+1:
                    list[i],list[i+1]=list[i+1],list[i]
                    c+=1
            if c==0:
                break
                
        for i in range (0,n):
            print list[i],
        print ""\n""

"
"
All submissions for this problem are available.
Let us calculate the sum of k-th powers of natural numbers from 1 to n. As the result can be quite large, output the result modulo some integer p.
Input
First t<=10 - the number of test cases.
Each test case consist of numbers: 1<=n<=1000000000, 1<=k<=100, 1<=p<=1000000000.
Output
For each test case, output the value: (1k+2k+...+nk) mod p.
Example
For input:
4
10 1 1000000
10 2 1000000
10 3 1000000
10 4 1000000
the correct output is:
55
385
3025
25333

",C2,S10112507,PYTH,"
    t=int(raw_input())
    for i in range(0,t):
        n,k,p=raw_input().split(' ')
        n,k,p=int(n),int(k),int(p)
        temp=1
        ans=0
        for i in range(1,n+1):
            temp=i
            for j in range(0,k-1):
                temp=((temp%p)*(i%p))%p
            ans+=(temp)%p
        print ans

"
"
All submissions for this problem are available.
In the magic land of Mathtopia, the words of the language are written only using two symbols: ones and zeros.

A given word w is called ""prime"" if it cannot be written in the form of the concatenation of several copies of some shorter word. So, for example the words '100', '1100', and '001100' are prime, while the words '0101', '100100', '1111', and '101010' are not prime.
Your task is to calculate the number of prime words which can be built from exactly a ones and b zeros.
Input
t - the number of test cases. For each test case, two integers: 1<=a<=109, 1<=b<=109.
Output
For each test case, output the required answer modulo 531169.
Example

Input:
1
2 2

Output:
4

Explanation: the 4 words from the example are:
'0011','1100','0110','1001'.
",C3,S10050474,PYTH,"
    import sys
    
    M = 531169
    
    # Assumption is that neither a nor b is 0
    def gcd(a, b):
        if b < a:
            tmp = a
            a = b
            b = tmp
        while a > 1:
            tmp = a
            a = b % a
            b = tmp
        return b
        
    def product_modulo(a, b, m):
        return ((a%m) * (b%m)) % m
        
    def lcm_modulo(a, b, m):
        g = gcd(a, b)
        return product_modulo(product_modulo(a, b, m), ModuloInverse(g, M), M)
        
     
    def BinomialCoeff(n, r):
        if n-r < r:
            r = n-r
        ans = 1
        for i in range(1, r+1):        
            ans = (ans * (n-i+1))
            ans = (ans / i)    
        return ans
    
        
    def Power(n, m):
        if m == 0:
            return 1
        
        p = Power(n, m/2)
        if m % 2 == 1:
            return p * p * n
        else:
            return p * p       
            
    def Power_M(n, m, M):
        if m == 0:
            return 1
        
        p = Power_M(n, m/2, M)
        if m % 2 == 1:
            return ((p*p)%M * n) % M
        else:
            return (p*p) % M
            
    def ModuloInverse(n, P):
        return Power_M(n, P-2, P)
    
    def BinomialCoeff_M(n, r, M):
        if n-r < r:
            r = n-r
        numerator = 1
        denominator = 1
        for i in range(1, r+1):        
            numerator = (numerator * (n-i+1)) % M
            denominator = (denominator * i) % M
            
        d_inverse = ModuloInverse(denominator, M)
        ans = (numerator * d_inverse) % M                
        return ans
    
        
    def Solve(a, b):
        k = product_modulo(lcm_modulo(a, a+b, M), ModuloInverse(a, M), M)
        l = product_modulo(product_modulo(a, k, M), ModuloInverse(a+b, M), M)
        A = BinomialCoeff_M(a+b, a, M)
        B = BinomialCoeff_M(k, l, M)
        print (A - B) % M
            
    if __name__ == ""__main__"":
        t = int(sys.stdin.readline())
        for i in range(0, t):
            nums = [int(x) for x in sys.stdin.readline().split()]
            Solve(nums[0], nums[1])

"
"
All submissions for this problem are available.

From the FAQ:

What am I allowed to post as a comment for a problem?


Do NOT post code.
Do NOT post a comment asking why your solution is wrong.
Do NOT post a comment asking if you can be given the test case your program fails on.
Do NOT post a comment asking how your solution can be improved.
Do NOT post a comment giving any hints or discussing approaches to the problem, or what type or speed of algorithm is required.


Problem Statement

Chef Doom has decided to bake a circular cake. He wants to place N colored cherries around the cake in a circular manner. As all great chefs do, Doom doesn't want any two adjacent cherries to have the same color. Chef has unlimited supply of cherries of K ≤ 10 different colors. Each color is denoted by the digit from the set {0, 1, ..., K – 1}. Different colors are denoted by different digits. Some of the cherries are already placed and the Chef wants you to place cherries in the remaining positions. He understands that there can be many such arrangements, so in the case when the answer is not unique he asks you to find the lexicographically smallest one.


What does it mean?


Let's numerate positions for the cherries by the numbers 1, 2, ..., N starting from one of the positions in a clockwise direction. Then the current (possibly partial) arrangement of the cherries can be represented by a string of N characters. For each position i of the arrangement if the cherry of the color C is placed at this position then the ith character of the string is equal to the digit C. Otherwise, it is equal to the question mark ?. We identify the arrangement with the string that represents it.


One arrangement is called lexicographically smaller than the other arrangement if at the first position where they differ the first one has smaller digit (we compare only complete arrangements so we don't care about relation between digits and the question mark). For example, the arrangement 1230123 is lexicographically smaller than 1231230 since they have first 3 equal characters but the 4th character in the first arrangement is 0 and it is less than 1 which is the 4th character of the second arrangement.


Notes


 The cherries at the first and the last positions are adjacent to each other (recall that we have a circular cake).

 In the case N = 1 any arrangement is valid as long as the color used for the only cherry of this arrangement is less than K.

 Initial arrangement can be already invalid (see the case 3 in the example).




Just to make all things clear. You will be given a usual string of digits and question marks. Don't be confused by circular stuff we have in this problem. You don't have to rotate the answer once you have replaced all question marks by the digits. Think of the output like the usual string for which each two consecutive digits must be different but having additional condition that the first and the last digits must be also different (of course if N > 1).


Next, you don't have to use all colors. The only important condition is that this string should be lexicographically smaller than all other strings that can be obtained from the input string by replacement of question marks by digits and of course it must satisfy conditions on adjacent digits.


One more thing, K here is not the length of the string but the number of allowed colors. Also we emphasize that the given string can have arbitrary number of question marks. So it can have zero number of question marks as well as completely consists of question marks but of course in general situation it can have both digits and question marks.


OK. Let's try to formalize things in order to make all even more clear. You will be given an integer K and a string S=S[1]S[2]...S[N] where each S[i] is either the decimal digit less than K or the question mark. We are serious. In all tests string S can have only digits less than K. Don't ask about what to do if we have digit ≥ K. There are no such tests at all! We guarantee this! OK, let's continue. Your task is to replace each question mark by some digit strictly less than K. If there were no question marks in the string skip this step. Now if N=1 then your string is already valid. For N > 1 it must satisfy the following N conditions S[1] ≠ S[2], S[2] ≠ S[3], ..., S[N-1] ≠ S[N], S[N] ≠ S[1]. Among all such valid strings that can be obtained by replacement of question marks you should choose lexicographically smallest one. I hope now the problem is really clear.


Input

The first line of the input file contains an integer T, the number of test cases. T test cases follow. Each test case consists of exactly two lines. The first line contains an integer K, the number of available colors for cherries. The second line contains a string S that represents the current arrangement of the cherries in the cake.

Constraints
1 ≤ T ≤ 1000
1 ≤ K ≤ 10
1 ≤ |S| ≤ 100, where |S| denotes the length of the string S
Each character in S is either the digit from the set {0, 1, ..., K – 1} or the question mark ?
Output

For each test case output the lexicographically smallest valid arrangement of the cherries in the cake that can be obtained from the given arrangement by replacement of each question mark by some digit from 0 to K – 1. If it is impossible to place the cherries output NO (output is case sensitive).

Example

Input:
7
1
?
2
?0
10
79259?087
2
??
3
0?1
4
?????
3
012

Output:
0
10
NO
01
021
01012
012
Explanation

Case 2. The only possible replacement here is 10. Note that we output 10 since we can not rotate the answer to obtain 01 which is smaller.


Case 3. Arrangement is impossible because cherries at the first and the last positions are already of the same color. Note that K = 10 but the string has length 9. It is normal. K and |S| don't have any connection.


Case 4. There are two possible arrangements: 01 and 10. The answer is the first one since it is lexicographically smaller.


Case 5. There are three possible ways to replace question mark by the digit: 001, 011 and 021. But the first and the second strings are not valid arrangements as in both of them there exists an adjacent pair of cherries having the same color. Hence the answer is the third string.


Case 6. Note that here we do not use all colors. We just find the lexicographically smallest string that satisfies condition on adjacent digit.


Case 7. The string is already valid arrangement of digits. Hence we simply print the same string to the output.

",CAKEDOOM,S1123304,PYTH,"
    import sys;
    def cakedoom():
        test = int(raw_input());
        while test>0:
            k0 = int(raw_input());
            s = list(raw_input());
            if len(s)==1:
                if s[0]=='?':
                    print '0';
                else:
                    if int(s[0])<k0:
                        print s[0];
                    else:
                        print ""NO"";
                test = test-1;
                continue;
            i = 0;
            while(i<len(s)):
                k = i+1;
                if k==len(s):
                    k=0;
                if s[i]=='?':
                    b = ((s[i-1]=='0') & (s[k]=='1')) | ((s[i-1]=='1') & (s[k]=='0'));
                    if b==True:
                        s[i]='2';
                    else:
                        b = ((s[i-1]=='0') | (s[k]=='0'));
                        if b==True:
                            s[i]='1';
                        else:
                            s[i]='0';
                i = i+1;
            ans = """";
            i=0;
            while i<len(s):
                ans = ans+s[i];
                i = i+1;
            i = 0;
            flag = 0;
            while i<len(s):
                k = i+1;
                if k==len(s):
                    k=0;
                if (s[i]==s[k]) | (int(s[i])>=k0):
                    flag=1;
                    break;
                i = i+1;
            if flag==1:
                ans = ""NO"";
            print ans;
            test = test-1;
    
    if __name__==""__main__"":
        cakedoom();
        sys.exit();
                        
    

"
"
All submissions for this problem are available.
The chef is a fan of candies with chocolate and caramel, and has devoted much of his life
to finding the perfect ratio of chocolate to caramel.
He recently discovered the perfect ratio, but to his dismay,
none of his favourite candy shoppes sell candies with exactly that ratio.
So the chef crafted a plan to buy several candies, and melt them together into a larger candy
so that the resulting candy will have the perfect ratio.
How many candies will he have to buy?
The chef may buy multiple candies of the same type.

Input:
Input begins with an integer N,
the number of different candies available at the various shoppes.
N lines follow, each containing 2 integers Chocolatei and Carameli indicating the grams of chocolate and caramel,
respectively, contained in the (i)th candy.
Finally, there is a line containing 2 integers desiredChocolate and desiredCaramel, indicating the chef's desired ratio of
chocolate to caramel.
Output:
For each test case, output on a single line the minimum number of candies the chef will have to buy.
If it is impossible to produce a candy with the desired ratio, output -1 instead.
Example
Input 1:
3
4 5
2 4
4 1
1 1
 
Output 1:
3
 
In this example, the chef purchases one of each candy and combines them to form a candy with 8 grams chocolate and 8 grams caramel.
Input 2:
3
2 3
4 6
10 15
5 8
 
Output 2:
-1
 
Constraints:
1 ≤ N ≤ 15
1 ≤ Chocolatei ≤ 500
1 ≤ Carameli ≤ 500
1 ≤ desiredChocolate ≤ 500
1 ≤ desiredCaramel ≤ 500
For all candies, Chocolatei/Carameli ≠ desiredChocolate/desiredCaramel
No two candies will be identical.

",CANDY,S2842436,PYTH,"
    n = int(raw_input())
     
    while n != -1:
        l = []
        sum = 0
        for i in range(n):
            a = int(raw_input())
            l.append(a)
            sum += a
     
        if sum % n != 0:
            print '-1'
        else:
            count = 0
            avg = sum / n
            for i in l:
                if i > avg:
                    count += i - avg
            print count
     
        n = int(raw_input())

"
"

                    function formatTime(ts) {
                      now = new Date(ts);

                      localtime = new Date();
                      hour = now.getHours();
                      min = now.getMinutes();
                      sec = now.getSeconds();

                      if (min <= 9) {
                        min = ""0"" + min;
                      }
                      if (sec <= 9) {
                        sec = ""0"" + sec;
                      }
                      if (hour > 12) {
                        hour = hour - 12;
                        add = "" PM"";
                      } else {
                        hour = hour;
                        add = "" AM"";
                      }
                      if (hour == 12) {
                        add = "" PM"";
                      }
                      if (hour == 00) {
                        hour = ""12"";
                      }

                      $('#server-time').html(((hour<=9) ? ""0"" + hour : hour) + "":"" + min + "":"" + sec + add);

                      nextSec = (now.getTime() + 1000);

                      setTimeout(""formatTime(""+nextSec+"")"", 1000);
                    }
                    function getDtTimeZone()
                    {
                      var rightNow = new Date();
                      var toDay = new Date(rightNow.getFullYear(), 0, 1, 0, 0, 0, 0);
                      var temp = toDay.toGMTString();
                      var date2 = new Date(temp.substring(0, temp.lastIndexOf("" "") -1));
                      var stdTime = (toDay - date2) / (1000 * 60 * 60);
                      return stdTime;
                    }
/*var d=new Date();
$.ajax({
url: '/umtza',
type:'POST',
data: 'umtza='+d.toString(),
});
*/

CodeChef is a non-commercial competitive programming community




About CodeChef
About Directi
CEO's Corner
C-Programming
Programming Languages
Contact Us


© 2009 Directi Group.  All Rights Reserved.  CodeChef uses SPOJ © by Sphere Research Labs
In order to report copyright violations of any kind, send in an email to copyright@codechef.com



The time now is: 

        formatTime('September 01, 2014 16:46:08');
      




    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-53602-42']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

  


    /* <![CDATA[ */
    var google_conversion_id = 1066618556;
    var google_conversion_language = ""en"";
    var google_conversion_format = ""3"";
    var google_conversion_color = ""666666"";
    var google_conversion_label = ""gbUUCPTlhAIQvJ3N_AM"";
    var google_conversion_value = 0;
    /* ]]> */
  









    /* <![CDATA[ */
    var google_conversion_id = 968176136;
    var google_conversion_language = ""en"";
    var google_conversion_format = ""3"";
    var google_conversion_color = ""ffffff"";
    var google_conversion_label = ""iDk7CPDZ7wMQiOTUzQM"";
    var google_conversion_value = 0;
    /* ]]> */
  








CodeChef - A Platform for Aspiring Programmers
CodeChef was created as a platform to help programmers make it big in the world of algorithms, computer programming and programming contests. At CodeChef we work hard to revive the geek in you by hosting a programming contest at the start of the month and another smaller programming challenge in the middle of the month. We also aim to have training sessions and discussions related to algorithms, binary search, technicalities like array size and the likes. Apart from providing a platform for programming competitions, CodeChef also has various algorithm tutorials and forum discussions to help those who are new to the world of computer programming.

Practice Section - A Place to hone your 'Computer Programming Skills'
Try your hand at one of our many practice problems and submit your solution in a language of your choice. Our programming contest judge accepts solutions in over 35+ programming languages. Preparing for coding contests were never this much fun! Receive points, and move up through the CodeChef ranks. Use our practice section to better prepare yourself for the multiple programming challenges that take place through-out the month on CodeChef. 

Compete - Monthly Programming Contests and Cook-offs
Here is where you can show off your computer programming skills. Take part in our 10 day long monthly coding contest and the shorter format Cook-off coding contest. Put yourself up for recognition and win great prizes. Our programming contests have prizes worth up to Rs.20,000 and $700lots more CodeChef goodies up for grabs. 

Discuss
Are you new to computer programming? Do you need help with algorithms? Then be a part of CodeChef's Forums and interact with all our programmers - they love helping out other programmers and sharing their ideas. Have discussions around binary search, array size, branch-and-bound, Dijkstra's algorithm, Encryption algorithm and more by visiting the CodeChef Forums and Wiki section.

CodeChef Community
As part of our Educational initiative, we give institutes the opportunity to associate with CodeChef in the form of Campus Chapters. Hosting online programming competitions is not the only feature on CodeChef. You can also host a coding contest for your institute on CodeChef, organize an algorithm event and be a guest author on our blog. 

Go For Gold
The Go for Gold Initiative was launched about a year after CodeChef was incepted, to help prepare Indian students for the ACM ICPC World Finals competition. In the run up to the ACM ICPC competition, the Go for Gold initiative uses CodeChef as a platform to train students for the ACM ICPC competition via multiple warm up contests. As an added incentive the Go for Gold initiative is also offering over Rs.8 lacs to the Indian team that beats the 29th position at the ACM ICPC world finals. Find out more about the Go for Gold and the ACM ICPC competition here.
 ",CAOS1,S10990080,PYTH,"
    for _ in xrange(input()):
        r,c = map(int,raw_input().split())
        a = [list(raw_input()) for _ in range(r)]
        tot = 0
        for i in range(r):
            for j in range(c):
                if a[i][j] != '^':
                    continue
                L = 0
                for k in range(i-1,-1,-1):
                    if a[k][j] == '#':
                        break
                    L += 1
                R = 0
                for k in range(i+1,r,1):
                    if a[k][j] == '#':
                        break
                    R += 1
                T = 0
                for k in range(j-1,-1,-1):
                    if a[i][k] == '#':
                        break
                    T += 1
                B = 0
                for k in range(j+1,c,1):
                    if a[i][k] == '#':
                        break
                    B += 1
                fi = min(L,T,B,R)
                if fi >= 2:
                    tot += 1
        print(tot)
                
    

"
"
All submissions for this problem are available.Problem Statement
Past
In the year of 2048, the Virtual Reality Massively Multiplayer Online Role-Playing Game (VRMMORPG), Code Art Online (CAO), is released. With the Chef Gear, a virtual reality helmet that stimulates the user's five senses via their brain, players can experience and control their in-game characters with their minds.
On August the 2nd, 2048, all the players log in for the first time, and subsequently discover that they are unable to log out. They are then informed by Code Master, the creator of CAO, that if they wish to be free, they must reach the second stage of the game.
Kirito is a known star player of CAO. You have to help him log out.
Present

Stage 2
A map is described by a 2D grid of cells. Each cell is either labelled as a # or a ^. # denotes a wall. A monster exists in a cell if the cell is not a wall and the cell is a centre of Prime-Cross (CPC).

Let L be the number of contiguous ^ to the left of X, in the same row as X.
R be the number of contiguous ^ to the right of X, in the same row as X.
T be the number of contiguous ^ above X, in the same column as X.
B be the number of contiguous ^ below X, in the same column as X.

A cell X is said to be a CPC if there exists a prime number P such that P ≤ minimum of [L, R, T, B].
Note that, there can be many such primes, let N be the number of such primes. That CPC can accommodate N monsters.
Note: While computing L, R, T, B for a cell X, you should not count the ^ of the cell X.
Given a map, you have to tell Kirito the number of cells where monsters exist.
Future
Have fun solving other tasks :-)
Input
The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. Each case starts with a line containing two space separated integers R, C, denoting the number of rows and columns in the map respectively. The next R lines contain C characters each, describing the map.
Output
For each test case, output a single line containing the number of monsters the map can accommodate.
Constraints

1 ≤ T ≤ 100
1 ≤ R ≤ 500
1 ≤ C ≤ 500

Example
Input:
2
3 10
#^^^^^#^##
^^^^^^^^^^
^^^^^^^^^#
7 10
^^^^#^^^^#
^^^^^^^^#^
^^##^^#^^^
#^^^^^^^#^
^^#^^^^^^^
^^^^#^^^^^
^^^^^^^^^^

Output:
0
3
 ",CAOS2,S2689994,PYTH,"
    #! /usr/bin/env python
    # -* - coding: UTF-8 -* -
    
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251]
    
    primes_length = len(primes)
    
    rows = 0
    columns = 0
    
    def binary_search_prime(n, s = 0, e = primes_length - 1):
        if n < primes[s] or e < s: return 0
        if n >= primes[e] : return e + 1 # number of primes under n
        
        m = (s + e)/ 2
        if n < primes[m]:
            return binary_search_prime(n, s, m - 1)
        else:
            return binary_search_prime(n, m, e -1)
    
    def count_monsters():
        global rows, columns
        rows, columns = map(int, raw_input().split())
        matrix = []                 # every row is a bitmap represent # or ^
        for _ in range(rows):
            bits = raw_input().replace('#', '0').replace('^', '1')
            matrix.append(int(bits, 2))
        sum = 0
        for i in range(rows):
            for j in range(columns):
                sum += cpc(matrix, i, j)
        return sum
    
    def compute(matrix, i, j):
    
        l = 0
        k = (columns - j)
        mask = 1 << k
        while (matrix[i] & mask ) > 0:
            l += 1
            k += 1
            mask = 1 << k
    
        r = 0
        k = (columns - j - 2)
        while k >= 0 and (matrix[i] & (1 << k) ) > 0:
            r += 1
            k -= 1
        
        t = 0
        k = i - 1
        mask = 1 << (columns - j - 1)
        while k >= 0 and (matrix[k] & mask) > 0:
            t += 1
            k -= 1
        
        b = 0
        k = i + 1
        mask = 1 << (columns - j - 1)
        while k < rows and (matrix[k] & mask) > 0:
            b += 1
            k += 1
        
        return ( l, r, t, b)
    
    def cpc(matrix, i, j):
        ""cpc prime of a cell""
        if matrix[i] & (1 << (columns - j - 1)) == 0: return 0
        l, r, t, b = compute(matrix, i, j)
        return binary_search_prime(min(l, r, t, b))
    
    def main():
        rounds = int(raw_input())
        for _ in range(rounds):
            print count_monsters()
    
    if __name__ == '__main__':
        main()
    

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese  and Russian.
Chef loves to prepare delicious dishes. This time, Chef has decided to prepare a special dish for you, and needs to gather several apples to do so.
Chef has N apple trees in his home garden. Each tree has a certain (non-zero) number of apples on it. In order to create his dish, Chef wants to pluck every apple from every tree.
Chef has an unusual method of collecting apples. In a single minute, he can perform the following task:

Pick any subset of trees such that every tree in the subset has the same number of apples.
From each tree in the subset, pluck any number of apples, as long as the number of apples left on the tree equals the number of apples on a tree not in the subset.

If all trees have the same number of apples left, Chef can pluck all of the apples remaining in a single minute.
Chef does not want to keep you waiting, so wants to achieve this task in the minimum possible time. Can you tell him what the minimum time required is?
Input
The first line of the input contains a single integer T denoting the number of test cases. This will be followed by T test cases. The first line of each test case contains a single integer N denoting the number of apple trees in Chef's garden. The next line of each test case contains N space separated integers denoting the number of apples on each tree.
Output
For each of the T test cases, output a single line - the minimum time to pluck all apples from all trees.
Constraints

1 <= T <= 10
1 <= N <= 105
1 <= Number of apples on a tree <= 105

Scoring

Subtask 1 : 1 <= T <= 10 , 1 <= N <=  103:  (27 pts)  
Subtask 2 : 1 <= T <= 10 , 1 <= N <=  104:  (25 pts)  
Subtask 3 : 1 <= T <= 10 , 1 <= N <=  105:  (48 pts)  

Example

Input
2
3
3 3 3
4
1 2 3 3

Output
1
3
Explanation
For test 1, Chef can select all the trees and can pluck all the apples in 1 minute.
For test 2, there are many ways Chef can pluck all of the apples in 3 minutes. Here is one example: 

First minute: Select the third and fourth trees. Pluck 1 apple from the third tree, and 2 apples from the fourth tree.
Second minute: Select the second and third tree. Pluck 1 apple from each tree.
Third minute: Select all of the trees and pluck the last apple from each tree.
 ",CAPPLE,S10535911,PYTH,"
    T = int(raw_input())
    while T:
        N = int(raw_input())
        L = [int(i) for i in raw_input().split()]; L.sort(); count = 0
        for i in range(len(L)-1,0,-1):
            if L[i-1] != L[i]: count += (L[i] - L[i-1])
        print count + 1; T -= 1
    

"
"
All submissions for this problem are available.
Chef is organizing an online card game tournament and for this purpose he has to provide a card shuffling software. This software has to simulate the following shuffling process. A stack of N cards is placed face down on the table. Cards in the stack are ordered by value. Topmost card has value 1 and the one on the bottom has value N. To shuffle the cards we repeat the following steps M times:

take A cards from the top of the deck.
take another B cards from the top of the deck.
put the A cards, which you removed in the first step, back on top of the remaining deck.
take C cards from the deck
put the B cards, which you're still holding from the second move, card by card on top of the deck.
finally, return the block of C cards on top

Note: taking a block of cards from the top of the deck does not change their order. The entire block is removed in a single move and not card by card. The only exception is the fifth move, where you return cards one by one from the top.
Input
The first line contains integers N and M. The following M lines describe the moves by integers Ai, Bi, Ci as described in the previous section.

In the spirit of random card shuffling, all test cases were generated with uniform random distributions to select where to cut the deck of cards.
Output
In a single line output the cards in the deck after performing all the moves. Cards should be listed from top of the deck to bottom and separated by spaces.
Constraints

1 <= N, M <= 100 000

Example

Input:
10 2
6 2 2
5 3 6

Output:
1 2 8 7 3 9 6 5 4 10

",CARDSHUF,S11584648,PYTH,"
    n,m=map(int,raw_input().split("" ""))
    card=[]
    for i in range(n):
        card.append(i+1)
    for i in range(m):
        A,B,C=map(int,raw_input().split("" ""))
        a=card[:A]
        card=card[A:]
        b=card[:B]
        card=card[B:]
        card=a+card
        c=card[:C]
        card=card[C:]
        b.reverse()
        card=b+card
        card=c+card
    for i in range(n):
        print card[i],

"
"
All submissions for this problem are available.
You are given a single integer N. It's very large, so it's given as a product of several prime powers: N = p1k1 p2k2 ... pmkm.
Let's define φ(N) as Euler's totient function -- the number of positive integers less than or equal to N that are relatively prime to N.
Let N1 = φ(N). Let N2 = φ(N1). Further, let NX = φ(NX-1) for X > 2.
Your task is to find the smallest positive integer X such that NX = 1. Only careful calculation might help... or will it be enough?
Input
The first line of the input file contains one integer T -- the number of test cases (no more than 10). Each test case is described by a line containing one positive integer m followed by m lines, each containing two integers pi and ki (1 < pi < 100000, 1 ≤ ki ≤ 109) separated by a single space. It's guaranteed that all pi are pairwise distinct prime numbers in each test case (note that the upper limit on m can be determined from this constraint).
Output
For each test case output just one line containing the required smallest positive integer X.
Example

Input:
1
2
2 2
3 1

Output:
3

Explanation:
In the example test case N = 22*31 = 12. Then N1 = 4, N2 = 2 and NX = 1 for X ≥ 3, so the answer is 3.
",CAREFUL,S8251863,PYTH,"
    # trying phi ki sequence.
    a = {}
    # a stores min x for each n to get to Nx = 1
    a[2] = 1
    a[3] = 2
    a[4] = 2
    
    def f(n):
    	global a
    	if not a.has_key(n):
    		a[n] = f(phi(n))
    	return a[n]
    
    def sieve(n):
    	j=2
    	k=0
    	yolist=[1]*n
    	while j**2<n:
    		k=j**2
    		while k<n:
    			yolist[k]=0
    			k += j
    		j += 1
    		while yolist[j]==0:
    			j += 1
    	return yolist
    
    def primelist(l):
    	i = 3
    	ans=[2]
    	sieve_n=sieve(l)
    	while i < l:
    		if sieve_n[i]:
    			ans.append(i)
    		i += 1
    	return ans
    
    # print primelist(19)
    
    
    theseprimes = primelist(100000)
    totalp = len(theseprimes)
    
    def phi(n):
    	ans = n
    	ith = 0
    	while ith<totalp and theseprimes[ith]<(n+3)/2:
    		elem = theseprimes[ith]
    		if n%elem == 0:
    			ans *= (elem - 1)
    			ans /= elem
    		ith += 1
    	if ans == n:
    		return (n-1)
    	else:
    		return ans
    	# pfac has all prime factors of n.
    
    # print phi(30)
    # print phi(7)
    # print phi(12)
    
    noCases = int(raw_input())
    
    x = 0
    while x < noCases:
    	n = int(raw_input())
    	y = 0
    	n1 = 1
    	while y < n:
    		strPK = raw_input()
    		pk = strPK.split()
    		p = int(pk[0])
    		k = int(pk[1])
    		n1 *= (p - 1)
    		n1 *= pow(p, k - 1)
    		y += 1
    	# n1 is phi(n)
    	print 1 + f(n1)
    	x += 1

"
"
All submissions for this problem are available.
Most problems on CodeChef highlight chef's love for food and cooking but little is known about his love for racing sports. He is an avid Formula 1 fan. He went to watch this year's Indian Grand Prix at New Delhi. He noticed that one segment of the circuit was a long straight road. It was impossible for a car to overtake other cars on this segment. Therefore, a car had to lower down its speed if there was a slower car in front of it. While watching the race, Chef started to wonder how many cars were moving at their maximum speed.
Formally, you're given the maximum speed of N cars in the order they entered the long straight segment of the circuit. Each car prefers to move at its maximum speed. If that's not possible because of the front car being slow, it might have to lower its speed. It still moves at the fastest possible speed while avoiding any collisions. For the purpose of this problem, you can assume that the straight segment is infinitely long.
Count the number of cars which were moving at their maximum speed on the straight segment.
Input
The first line of the input contains a single integer T denoting the number of test cases to follow. Description of each test case contains 2 lines. The first of these lines contain a single integer N, the number of cars. The second line contains N space separated integers, denoting the maximum speed of the cars in the order they entered the long straight segment.
Output
For each test case, output a single line containing the number of cars which were moving at their maximum speed on the segment.
Example

Input:
3
1
10
3
8 3 6
5
4 5 1 2 3

Output:
1
2
2
Constraints

1 ≤ T ≤ 100
1 ≤ N ≤ 10,000
All speeds are distinct positive integers that fit in a 32 bit signed integer.
Each input file will not be larger than 4 MB (4,000,000,000 bytes) in size.

WARNING! The input files are very large. Use faster I/O.
",CARVANS,S10107156,PYTH,"
    for _ in range(int(raw_input())):
        n = int(raw_input())
        c = list(map(int, raw_input().strip().split()))
        count = 0
        for i in range(len(c) - 1, 0, -1):
            if c[i - 1] > c[i]: count += 1
        print count + 1

"
"
All submissions for this problem are available. Read problems statements in Mandarin Chinese  and Russian.
Recently Chef has decided to make some changes in our beloved Codechef. As you know, each problem at Codechef has its memory and time limits. To make problems even more challenging, he decided to measure allocated memory in a different way. Now judge program will be calculating not the maximum memory usage during the execution of all test files, but all the memory ever allocated by the solution program. But as Chef is not that good in algorithms, so he asks you to write a program that will calculate total memory usage of a solution.
So, you are given N numbers M1, , ,MN representing the measurements of consumed memory (in MBs) for N test files. In other terms, it means that on i-th test file, program took Mi MBs of memory. Initially, there is no memory allocated for your program. Before running your program on each test file, if the currently allocated memory is more than memory needed for the current test file, then there will be a deallocation of the memory to fit the current program. Also, if there is less than needed memory available, then allocation of memory will happen so as to fit the current program. e.g. Let us say that our program took 10 MBs on current test file. So, assuming if there was 12 MBs memory allocated before running the program on current test file, then there will happen a deallocation of 2 MBs. Assuming if there was 8 MBs memory allocated before running the program on current test file, then there will happen a allocation of 2 MBs.


Calculate the total memory allocated for running the solution program on all the N test files. Please see third sample for more clarity.
Input
First line of input contains a single integer T denoting the  number of test cases. First line of each test case contains a single integer N denoting the number of measurements. Second line of each test case contains N space separated integers, where ith integer denotes the consumption of memory for ith i-th test file.
Output
For each test case, print total memory allocated for running the solution program.
Constraints

1 ≤ T ≤ 105
1 ≤ N ≤ 105
1 ≤ Mi ≤ 109
 sum of N over all test cases does not exceed 105

Subtasks

Subtask 1 (30 points):

1 ≤ T ≤ 100
1 ≤ N ≤ 100
1 ≤ Mi ≤ 100


Subtask 3 (70 points): 

Original constraints.


Example
Input:
3
2
1 1
5
1 2 3 4 5
3
1 3 2

Output:
1
5
3
Explanation
Example case 1. Initially, there was no memory allocated. For running first test file, there was a memory allocation of 1 MBs. There was no allocation/ deallocation for running your program on second test file. 
Example case 2. On running on each test file, there was a further allocation of 1 MBs from previous one. So, there are total 5 MBs of memory allocated while running the program.
Example case 3. Initially, there was no memory allocated. For running first test file, there was a memory allocation of 1 MBs. For running second test file, there was a further memory allocation of 2 MBs to have 3 MBs of memory needed, then in the last file, there was a deallocation of 1 MB of memory so as to get 2 MBs of memory needed for running the program. So, overall, there was 1 + 2 = 3 MBs of memory ever allocated in the program. Note that we are only counting allocated memory, not allocated + unallocated. ",CBARG,S10844085,PYTH,"
    string1 = raw_input()
    t = int(string1)
    for i in range(t) :
    	memory = list()
    	string3 = raw_input()
    	n = int(string3)
    	string2 = raw_input()
    	nums1 = string2.split()
    	for j in range(n):
    		memory.append(int(nums1[j]))
    	counter = memory[0]
    	for j in range(1,n) :
    		if memory[j]>memory[j-1] :
    			counter = counter + memory[j] - memory[j-1]
    	print counter
    

"
"
All submissions for this problem are available.

A few days ago Chef decided to cook a new dish – chocolate.  This must be something amazing. The idea is that chocolate bar will be divided into cells. It must be long, but narrow. To interest customers every bar must be unique. Bar will consist of cells of black or white chocolate. In addition every bar must be good looking. It means that the bar must not contain any totally white or totally black rectangle, whose width and length are more than 1 (Note that a bar is good if (width > 1 and length = 1) or (length > 1 and width = 1)). Now, Chef wants to know how many bars can he cook? He’s not good in computer programming, so this task is for you.
 By the way, it's not permitted to rorate bars. It means that WBB and BBW are different bars.
Input

Input contains two integers: width a (1 ≤ a ≤ 6) and length b (1 ≤ b < 263).
Output

Print in output a single integer which is the answer. Answer can be a very big number, so print it modulo 109+7 (1000000007).
Example

Input:
2 2

Output:
14

Input:
3 3

Output:
322
Explanation

In the first sample, there are 2^(2*2) = 16 ways coloring the chocolate in total, and the only following 2 chocolates are not good


WW
WW
The bar contains a totally white rectangle of length = 2 and width = 2.

BB
BB
The bar contains a totally black rectangle of length = 2 and width = 2.
",CBARS,S1553776,PYTH,"
    #!/usr/bin/python
    mod = 1000000007
    #import psyco
    #psyco.full()
    def matrix_mult(A, B):
      C = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
      for i in range(3):
    	  for j in range(3):
    		  for k in range(3):
    			  C[i][k] = (C[i][k] + A[i][j] * B[j][k])
    	  	          if(C[i][k] > 1000000007):
    				C[i][k] = C[i][k] % 1000000007
      return C
    
    def matrix_mult_1(A, B):
      C = [[0, 0],[0,0]]
      for i in range(2):
    	  for j in range(2):
    		  for k in range(2):
    			  C[i][k] = (C[i][k] + A[i][j] * B[j][k]) % 1000000007
      return C
    
    def matrix_mult_4(A, B):
      C = [[0, 0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]
      for i in range(5):
    	  for j in range(5):
    		  for k in range(5):
    			  C[i][k] = (C[i][k] + A[i][j] * B[j][k])
    		          if(C[i][k] > 1000000007):
    				C[i][k] = C[i][k] % 1000000007
      return C
    
    def matrix_mult_5(A,B):
      C=[]
      for i in range(9):
    	  C.append([0,0,0,0,0,0,0,0,0])
      for i in range(9):
    	  for j in range(9):
    		  for k in range(9):
    			  C[i][k] = (C[i][k] + A[i][j] * B[j][k])
    		          if(C[i][k] > 1000000007):
    				C[i][k] = C[i][k] % 1000000007
      return C
    
    def matrix_mult_6(A,B):
      C=[]
      for i in range(18):
    	  C.append([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])
      for i in range(18):
    	  for j in range(18):
    		  for k in range(18):
    			  #if( A[i][j] > mod):
    		#		  A[i][j] = A[i][j] % mod
    		#	  elif (B[j][k] > mod):
    		#		  B[j][k] = B[j][k] % mod
    			  C[i][k] = (C[i][k] + A[i][j] * B[j][k])
    	       #           if(C[i][k] > mod):
    			  C[i][k] = C[i][k] % mod
      return C
    
    def fast_exp(A, n, flag):
      if n == 1:
    	return A
      else:
        if n & 1 == 0:
          A1 = fast_exp(A, n/2,flag)
          if(flag == 2):
    	      return matrix_mult_1(A1, A1)
          elif (flag == 3):
    	      return matrix_mult(A1,A1)
          elif (flag == 4):
    	      return matrix_mult_4(A1,A1)
          elif( flag == 5):
    	      return matrix_mult_5(A1,A1)
          elif (flag == 6):
    	      return matrix_mult_6(A1,A1)
        else:
          A1 = fast_exp(A,n-1,flag)
          if(flag == 2):
    	      return matrix_mult_1(A,A1)
          elif(flag == 3):
    	      return matrix_mult(A,A1)
          elif(flag == 4):
    	      return matrix_mult_4(A,A1)
          elif(flag == 5):
    	      return matrix_mult_5(A,A1)
          elif(flag == 6):
    	      return matrix_mult_6(A,A1)
    
    def fast_pow(n):
      if n == 1:
    	return 2
      if n == 0:
            return 1
      else:
        if n % 2 == 0:
    		        ans = fast_pow(n/2)
          		   	ans = ans % mod
         			return (ans*ans) % mod
        else:
    			ans = fast_pow(n-1)
    		        ans = ans % mod
    		        return ans*2
    
    def solve_1(n):
        A = [[0,1,0],[0,0,1],[1,1,1]]
        A_n = fast_exp(A,n-3)
        return A_n[2][0] + A_n[2][1] + A_n[2][2]*2
    
    def solve_2(n):
        if(n == 1):
    	    return 2
        elif(n == 2):
    	    return 7
        A = [[0,1],[2,3]]
        A_n = fast_exp(A,n-2,2)
        return A_n[1][0]*2 + A_n[1][1]*7
    
    def solve_3(n):
        A = [[0,1,0],[0,0,1],[-2,3,6]]
        if(n == 1):
    	    return 4
        elif(n == 2):
    	    return 25
        elif(n == 3):
        	    return 161
        A_n = fast_exp(A,n-3,3)
        return A_n[2][0]*4 + A_n[2][1]*25 + A_n[2][2]*161
    
    def solve_4(n):
        ans= [8,89,1033,11929,137845]
        if(n <= 5):
    	    return ans[n-1]
        A = [[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1],[8,-30,-21,20,10]]
        A_n = fast_exp(A,n-5,4)
        return A_n[4][0]*8 + A_n[4][1]*89 + A_n[4][2]*1033 + A_n[4][3]*11929 + A_n[4][4]* 137845
    
    def solve_5(n):
        ans = [16,317,6631,137845,2867739,59655167,1240971177,25815151595,537016650729]
        if(n <= 9):
    	    return ans[n-1]
        A = [[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1],[-10,69,29,-662,790,73,-278,9,21]]
        Ab = fast_exp(A,n-9,5)
        return Ab[8][0]*16 + Ab[8][1]*317+ Ab[8][2]*6631+ Ab[8][3]*137845+Ab[8][4]*2867739+Ab[8][5]*59655167 + Ab[8][6]*1240971177 + Ab[8][7]* 25815151595 + Ab[8][8]*537016650729 
    
    def solve_6(n):
    	ans =[32,1129,42563,1592731,59655167,2234126207,83670667271,3133560234217,117355367786585,4395090865370635,164601109918978615,6164497208894901477,230867373009598884627,8646243499452479433569,323811570588787197424201,12127108524504811121752257,454173891617617632766031151,17009324474195992258878836533]
    	if(n <= 18):
    		return ans[n-1]
    	for i in range(18):
    		ans[i] = ans[i] % mod
    	A=[[0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]]
    	A.append([28,-622,3386,6203,-70276,38077,355981,-410368,-499260,751787,154999,-396016,27152,50702,-3905,-2391,120,36])
            Ab = fast_exp(A,n-18,6)
    	#print len(ans)
    	finalans = 0
    	for i in range(18):
    		finalans = finalans + ((Ab[17][i] % mod)*ans[i]) % mod
    		if(finalans > mod):
    			finalans % mod
    	return finalans
    inp = raw_input()
    inp = inp.split()
    #print inp[0],inp[1]
    inp[0] = int(inp[0]); inp[1] = int(inp[1]);
    if(inp[0] == 1):
    	if(inp[1] == 1):
    		print 2
    	else:
    		print fast_pow(inp[1])%mod
    elif(inp[0] == 2):
    	print (solve_2(inp[1])*2)%mod
    elif(inp[0] == 3):
    	print (solve_3(inp[1])*2)%mod
    elif(inp[0] == 4):
    	print (solve_4(inp[1])*2)%mod
    elif(inp[0] == 5):
    	print (solve_5(inp[1])*2)%mod
    elif(inp[0] == 6):
    	print (solve_6(inp[1])*2)%mod
    

"
