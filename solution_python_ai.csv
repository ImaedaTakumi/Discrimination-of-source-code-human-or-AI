Column1,Column2,Column3,Column4,Solutions,,,,,,,,,,,,,,,,,,,,,
statement,QCode,SolutionID,Language,,,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.Alice and Johnny are playing a simple guessing game. Johnny picks an arbitrary positive integer n (1<=n<=109) and gives Alice exactly k hints about the value of n. It is Alice's task to guess n, based on the received hints. 
 
 Alice often has a serious problem guessing the value of n, and she's beginning to suspect that Johnny occasionally cheats, that is, gives her incorrect hints. 
 After the last game, they had the following little conversation:
 
 
 [Alice] Johnny, you keep cheating!
 [Johnny] Indeed? You cannot prove it.
 [Alice] Oh yes I can. In fact, I can tell you with the utmost certainty that in the last game you lied to me at least *** times.
 
 
 
 So, how many times at least did Johnny lie to Alice? Try to determine this, knowing only the hints Johnny gave to Alice.
 
 Input
 The first line of input contains t, the number of test cases (about 20). Exactly t test cases follow. 
 
 Each test case starts with a line containing a single integer k, denoting the number of hints given by Johnny (1<=k<=100000). Each of the next k lines contains exactly one hint. The i-th hint is of the form:
 
  operator li logical_value
 
 where operator denotes one of the symbols < , > , or =; li is an integer (1<=li<=109), while logical_value is one of the words: Yes or No. The hint is considered correct if logical_value is the correct reply to the question: ""Does the relation: n operator li hold?"", and is considered to be false (a lie) otherwise.
 
 Output
 For each test case output a line containing a single integer, equal to the minimal possible number of Johnny's lies during the game.
 
 Example
 
 Input:
 3
 2
 < 100 No
 > 100 No
 3
 < 2 Yes
 > 4 Yes
 = 3 No
 6
 < 2 Yes
 > 1 Yes
 = 1 Yes
 = 1 Yes
 > 1 Yes
 = 1 Yes
 
 Output:
 0
 1
 2
 
 Explanation: for the respective test cases, the number picked by Johnny could have been e.g. n=100, n=5, and n=1.",A3,S3326297,PYTH,"# Read in the number of test cases
t = int(input())

# Loop through each test case
for i in range(t):
  # Read in the number of hints given by Johnny
  k = int(input())

  # Initialize variables to keep track of the lower and upper bounds for n
  lower_bound = 0
  upper_bound = 10**9

  # Initialize a variable to keep track of the number of lies Johnny told
  lies = 0

  # Loop through each hint
  for j in range(k):
    # Read in the hint
    hint = input().split()

    # Extract the operator, value, and logical value from the hint
    operator = hint[0]
    value = int(hint[1])
    logical_value = hint[2]

    # If the hint is a lie, Johnny must have given a false positive
    if logical_value == ""Yes"":
      lies += 1

      # Update the lower or upper bound based on the operator
      if operator == ""<"":
        upper_bound = min(upper_bound, value - 1)
      elif operator == "">"":
        lower_bound = max(lower_bound, value + 1)
      else:
        lower_bound = max(lower_bound, value)
        upper_bound = min(upper_bound, value)
    # If the hint is not a lie, update the lower or upper bound based on the operator
    else:
      if operator == ""<"":
        lower_bound = max(lower_bound, value)
      elif operator == "">"":
        upper_bound = min(upper_bound, value)
      else:
        lower_bound = max(lower_bound, value + 1)
        upper_bound = min(upper_bound, value - 1)

  # Print the minimum number of lies Johnny told
  print(lies)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 
 Johnny was asked by his math teacher to compute nn (n to the power of n, where n is an integer), and has to read his answer out loud. This is a bit of a tiring task, since the result is probably an extremely large number, and would certainly keep Johnny occupied for a while if he were to do it honestly. But Johnny knows that the teacher will certainly get bored when listening to his answer, and will sleep through most of it! So, Johnny feels he will get away with reading only the first k digits of the result before the teacher falls asleep, and then the last k digits when the teacher wakes up.
 
 Write a program to help Johnny to compute the digits he will need to read out.
 Input
 The first line contains t, the number of test cases (about 30000). Then t test cases follow.
 Each test case consists of one line containing two numbers n and k (1 ≤ n ≤ 109, 1 ≤ k ≤ 9). It is guaranteed that k is not more than the number of digits of nn.
 Output
 For each test case, print out one line containing two numbers, separated by a space, which are the first and the last k digits of nn.
 Example
 
 Input
 2
 4 2
 9 3
 
 Output
 25 56
 387 489",A4,S2162087,PYTH,"# t個のテストケースを処理する
t = int(input())
for i in range(t):
    # nとkを読み込む
    n, k = map(int, input().split())

    # nのk桁を表す数字を計算する
    divisor = 10 ** k

    # nの最後のk桁を計算する
    last_k_digits = n % divisor

    # nの最初のk桁を計算する
    first_k_digits = n // divisor

    # 最初のk桁と最後のk桁を出力する
    print(first_k_digits, last_k_digits
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 This problem was part of the CodeChef April Challenge. All user submissions for this contest problem are publicly available here.
 Your grandfather is known in the family for his unconventional sense of humour. Since he made his fortune on the network of
 pizza parloursa), he has been giving expensive gifts to the members of the family every Christmas. Receiving the gift,
 however, always involves solving a more or less fancy mathematical puzzle.
 This year, your gift was locked in a safe, self-made by your grandfather. The safe was secured with a two digit code: in order to open it
 you had to provide the correct integer number from the range [0,99]. A bit disgruntled that this year's puzzle would apparently be solved with the force (and not even too brute), you were just about to start examining the numbers, when you heard grandfather's voice - ""Beware, kid! After two unsuccessful attempts the content will be annihilated!"" ""Then how am I supposed to solve this, Grandpa?"" - you asked. ""Go and have a better look at the package"" - grandfather replied.
 Indeed, at the bottom of the package you found a city map on which were indicated all the pizza parlours belonging to your grandfather, as well as a long sheet of paper with a sequence of positive integers. After analysing the data for a while you realized that the number of integer values is equal to the number of pizza restaurants... Recognizing that you still have too little input, you went to ask grandfather for further guidance.
 ""Ah, all right, I'll solve the riddle for you"" - grandfather relented. ""For each pizza parlour you have to draw such an axis-aligned square that it is centered at the restaurant and half of the length of its side is equal to the corresponding value from the sheet. Then you have to count all the streets on the map which intersect with the square, and write down the result of calculations. The result for the last pizza parlour will be your magic number.""
 You were a bit surprised that grandfather ordered you to draw squares and count streets for all the restaurants (and there were many), since the code would only depend on the last one. Nonetheless you willingly took on the job, drew the square for the last pizza parlour, counted the streets and entered the number. Unfortunately the safe didn't open.
 You rushed to grandfather and told him about the first failed attempt. ""Oh dear, did I forget to mention?"" - the old man was slightly taken aback. ""For each restaurant but the first one, you have to modify both its coordinates by bit-xor'ing them with the result of calculations for the directly preceding restaurant, before drawing the square!"". Will you be able to claim the gift now? You have only one attempt left!
 Input
 
 The first line of input contains two integers n and m (0 ≤ n ≤ 5000, 1 ≤ m ≤ 50000), the number of streets in the capital city and the number of pizza parlours, respectively. The following n lines contain four integers x1, y1, x2 and y2, each (0 ≤ x1, y1, x2, y2 ≤ 1000<). Each of these lines defines the location of one of the streets, with (x1,y1) representing one of the endpoints and (x2,y2) the other one. The streets can be assumed to be straight line segments. Eventually there are m lines with three integers x, y and r each (0 ≤ x, y ≤ 1000, 1 ≤ r ≤ 20). Each of these lines defines x and y coordinates of one of the pizza parlours and the corresponding number from the sheet attached to your gift, respectively.
 You may find it useful to know that:
 
 A street can have identical endpointsb).
 Any two distinct streets have at most one common point.
 When counting intersecting streets, you should assume that the boundary of the square belongs to the square.
 The configuration of the streets guarantees that any square satisfying 0 ≤ x, y ≤ 1000, 1 ≤ r ≤ 20 will contain at most 99 intersecting streets.
 Your grandfather is 78 and claims that Fortran is the best language for solving his Christmas puzzles.
 
 Output
 The output should contain a single integer value - the code that opens the safe.
 Example
 
 Input:
 5 2
 2 2 4 6
 2 2 7 4
 4 6 7 4
 7 4 10 3
 7 4 10 5
 10 4 2
 0 0 1
 
 Output:
 2
 Notes
 a) This should not surprise anyone. As the IT sector is extremely well-developed in Byteland, pizza network owners are among the richest people there.
 b) For some inscrutable reasons such streets are called squares. Not to be mixed up with the squares you draw!",A7,S150539,PYTH,"n, m = map(int, input().split())

# 街のすべての道路を保存するリスト
streets = []

# 街のすべての道路を読み込む
for i in range(n):
    x1, y1, x2, y2 = map(int, input().split())
    streets.append((x1, y1, x2, y2))

# 最終的な答えを保存する変数
result = 0

# ピザパーラーをすべて確認する
for i in range(m):
    x, y, r = map(int, input().split())

    # 前のピザパーラーの結果をxorで計算する
    if i > 0:
        x ^= result
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 Byteland is a strange country, with many cities, but with a poorly developed road network (in fact, there is exactly one route from each city to any other city, possibly leading through other cities). Until recently, the cities of Byteland were independently governed by proud Mayors, who chose not to integrate too tightly with their neighbours. However, recent opinion polls among Bytelandian computer programmers have shown a number of disturbing trends, including a sudden drop in pizza consumption.
 Since this had never before happened in Byteland and seemed quite inexplicable, the Mayors sought guidance of the High Council of Wise Men of Byteland. After a long period of deliberation, the Council ruled that the situation was very serious indeed: the economy was in for a long-term depression! Moreover, they claimed that tighter integration was the only way for the Bytelandian cities to survive. Whether they like it or not, the Mayors must now find a way to unite their cities as quickly as possible. However, this is not as easy as it sounds, as there are a number of important constraints which need to be fulfilled:
 
 Initially, each city is an independent State. The process of integration is divided into steps.
 At each step, due to the limited number of diplomatic envoys available, a State can only be involved in a unification process with at most one other state. At each step two States can unite to form a new State, but only if there exists a road directly connecting some two cities of the uniting States.
 The unification process is considered to be complete when all the cities belong to the same, global State.
 
 
 The Mayors have asked you to arrange a schedule for the diplomatic talks, so that unification can be completed in as few steps as possible. Can you handle this delicate task?a)
 Input
 The first line contains t, the number of test cases (less than 1000). The descriptions of t test cases follow.
  Each test case contains the description of the cities of Byteland, given in two lines. The first line contains a single integer k, representing the number of cities in Byteland (2 <= k <= 600); we assume that the cities are numbered 0,...,k-1. The second line contains exactly k-1 integers, and the i-th integer having a value of p represents a road connecting cities having numbers i+1 and p in Byteland.
 Output
 For each test case, output a separate line containing one number, equal to the minimum number
 of steps required to perform the unification.
 Example
 
 Input:
 3
 4
 0 1 2
 8
 0 1 2 0 0 3 3
 9
 0 1 1 1 1 0 2 2
 
 Output:
 2
 4
 5
 
 a) Some conspiracy theorists claim that this task has in fact nothing to do with unification, and that it was proposed by pizza parlour lobbyists simply to boost their direct revenue at your expense. But don't worry, in any case, you are helping Byteland out of depression!",A8,S43278,PYTH,"from collections import deque

def minimum_steps_to_unify(t, test_cases):
    # t: int, the number of test cases
    # test_cases: list of tuple, containing the description of the cities of Byteland
    #             each tuple contains two elements:
    #             - int, the number of cities in Byteland
    #             - list of int, a road connecting cities having numbers i+1 and p in Byteland

    results = []
    for test_case in test_cases:
        k, roads = test_case
        # 各市が属する国を示すリスト
        countries = [i for i in range(k)]
        # 国を統一するために必要なステップ数
        steps = 0
        while len(set(countries)) > 1:
            # 各市が属する国を統一することができる市を見つける
            for i, road in enumerate(roads):
                if countries[i] != countries[road]:
                    steps += 1
                    # 統一する市を見つけた場合はそれらを統一する
                    for j, c in enumerate(countries):
                        if c == countries[road]:
                            countries[j] = countries[i]
                    # 統一したのでbreakして次のステップに進む
                    break
        results.append(steps)
    return results

# test
t = 3
test_cases = [
    (4, [0, 1, 2]),
    (8, [0, 1, 2, 0, 0, 3, 3]),
    (9, [0, 1, 1, 1, 1, 0, 2, 2]),
]
print(minimum_steps_to_unify(t, test_cases))  # expect [2, 4, 5]
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese , Russian and Vietnamese as well.
 Akhil has many balls of white and black colors. One day, he was playing with them. During the play, he arranged the balls into two rows both consisting of N number of balls. These two rows of balls are given to you in the form of strings X, Y. Both these string consist of 'W' and 'B', where 'W' denotes a white colored ball and 'B' a black colored.
 
 Other than these two rows of balls, Akhil has an infinite supply of extra balls of each color. he wants to create another row of N balls, Z in such a way that the sum of hamming distance between X and Z, and hamming distance between Y and Z is maximized.
 Hamming Distance between two strings X and Y is defined as the number of positions where the color of balls in row X differs from the row Y ball at that position. e.g. hamming distance between ""WBB"", ""BWB"" is 2, as at position 1 and 2, corresponding colors in the two strings differ..
 
 As there can be multiple such arrangements of row Z, Akhil wants you to find the lexicographically smallest arrangement which will maximize the above value. 
 
 Input
 
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows:
 First line of each test case will contain a string X denoting the arrangement of balls in first row
 Second line will contain the string Y denoting the arrangement of balls in second row.
 
 Output
 
 For each test case, output a single line containing the string of length N denoting the arrangement of colors of the balls belonging to row Z.
 
 Constraints
 
 1 ≤ T ≤ 3
 
 Subtasks
 Subtask #1 (10 points) : 1 ≤ N ≤ 16
 Subtask #2 (20 points) : 1 ≤ N ≤ 103
 Subtask #3 (70 points) : 1 ≤ N ≤ 105
 Example
 Input:
 1
 WBWB
 WBBB
 
 Output:
 BWBW
 
 Explanation
 Example case 1. As we know, Hamming Distance(WBWB, BWBW) + Hamming Distance(WBBB, BWBW) = 4 + 3 = 7.
 You can try any other value for string Z, it will never exceed 6.",ACBALL,S10215347,PYTH,"def maximize_hamming_distance(x: str, y: str) -> str:
    n = len(x)
    z = [' '] * n
    for i in range(n):
        # If the characters at this position in x and y are different,
        # we can set the character at this position in z to be the one that is different from both x and y
        if x[i] != y[i]:
            z[i] = 'W' if x[i] == 'B' else 'B'
        # If the characters at this position in x and y are the same,
        # we can set the character at this position in z to be the one that is different from x
        else:
            z[i] = 'W' if x[i] == 'B' else 'B'
    return ''.join(z)

# Test the function with the example from the prompt
print(maximize_hamming_distance('WBWB', 'WBBB'))  # Expected output: ""BWBW""
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 Aditi recently discovered a new magic trick. First, she gives you an integer N and asks you to think an integer between 1 and N. Then she gives you a bundle of cards each having a sorted list (in ascending order) of some distinct integers written on it. The integers in all the lists are between 1 and N. Note that the same integer may appear in more than one card. Now, she shows you these cards one by one and asks whether the number you thought is written on the card or not. After that, she immediately tells you the integer you had thought of.
 Seeing you thoroughly puzzled, she explains that she can apply the trick so fast because she is just adding the first integer written on the cards that contain the integer you had thought of, and then gives the sum as the answer. She calls a bundle interesting if when the bundle is lexicographically sorted, no two consecutive cards have any number in common. Now she challenges you to find out the minimum number of cards she will need for making an interesting bundle such that the magic trick will work every time.
 Input
 
 The first line of the input contains an integer T denoting the number of test cases.
 Each test case contains a line with a single integer N.
 
 Output
 
 For each test case, output a line containing a single integer denoting the minimum number of cards required.
 
 Constraints
 
 1 ≤ T ≤ 105
 1 ≤ N ≤ 1018
 
 Sub tasks
 
 Subtask #1: 1 ≤ T ≤ 10, 1 ≤ N ≤ 10 (5 points)
 Subtask #2: 1 ≤ T ≤ 100, 1 ≤ N ≤ 1000 (10 points)
 Subtask #3: Original Constraints (85 points)
 
 Example
 Input:
 2
 1
 4
 
 Output:
 1
 3
 Explanation
 
 In example 1, only 1 card containing {1} will work.
 In example 2, make 3 cards containing {1,4}, {2} and {3,4}.
 
 Assume you thought of 1, then you will select the 1st card {1,4}, then she will correctly figure out the integer you thought being 1.
 Assume you thought of 2, then you will select the 2nd card {2}, then she will correctly figure out the integer you thought being 2.
 Assume you thought of 3, then you will select the 3rd card {3,4}, then she will correctly figure out the integer you thought being 3.
 Assume you thought of 4, then you will select 1st card {1,4} and 3rd card {3,4}, then she will calculate the sum of the first integers of the two card 1 + 3 = 4, and she will answer it.
 
 Thus her trick will work well in every case. And we can check it easily that the cards are sorted in lexicographical order and two consecutive cards have no common integers.",ADMAG,S11169224,PYTH,"def main():
  t = int(input())
  for _ in range(t):
    n = int(input())
    cards = 0
    while n > 0:
      cards += 1
      n //= 2
    print(cards)

main()
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 Today Chef wants to clean his garden. Chef has N columns of ground. Each column has it's height . Chef can choose any column and increase its height by 1 using 1 cube of ground. 
 Chef wants to spend exactly M cubes. Can he make this in such way that the heights of all columns will become equal? 
 Input
 
  First line of input contains an integer T denoting number of test cases.
 Then for each test case, The first line contains two integers N and M. 
 The second line contains N space-separated integers A1, A2, ..., AN denoting the initial heights of the columns"". 
 
 Output
 
 If Chef can spend all cubes and make the columns equal print Yes else print No. 
 
 Constraints
 
 1 ≤ T ≤ 10^2
 1 ≤ N ≤ 10^2
 1 ≤ Ai ≤ 10^2
 0 ≤ M ≤ 10^4
 
 Example
 Input:
 3
 5 7
 3 3 4 2 1
 5 6
 3 3 4 2 1
 5 8
 3 3 4 2 1
 
 Output:
 Yes
 No
 No
 Explanation
 In the first case we can put cubes on columns in such count: 1, 1, 0, 2, 3. The sum equals M.
 In the second case we can't make the columns equal as we will receive something like 44443.
 In the third case we can make all columns equal but we will still have one cube extra, By using that cube, our heights of columns will become 44445.",CHEFGR,S5147767,PYTH,"T = int(input())
for _ in range(T):
    n, m = map(int, input().split())
    heights = list(map(int, input().split()))
    mean = sum(heights) / n
    cubes_needed = 0
    for i in range(n):
        diff = int(heights[i]) - mean
        if diff > 0:
            cubes_needed += diff
    if cubes_needed <= m:
        print(""Yes"")
    else:
        print(""No"")
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
  Alexey is trying to develop a program for a very simple microcontroller. It makes readings from various sensors over time, and these readings must happen at specific regular times. Unfortunately, if two of these readings occur at the same time, the microcontroller freezes and must be reset. 
 
 There are N different sensors that read data on a regular basis. For each i from 1 to N, the reading from sensor i will occur every Ai milliseconds with the first reading occurring exactly Ai milliseconds after the microcontroller is powered up. Each reading takes precisely one millisecond on Alexey's microcontroller.
 
 
 Alexey wants to know when the microcontroller will freeze after he turns it on.
 
 Input
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
 The first line contains single integer N denoting the number of sensors.
 
 The second line contains N space-separated integers A1, A2, ..., AN denoting frequency of measurements. Namely, sensor i will be read every Ai milliseconds with the first reading occurring Ai milliseconds after the microcontroller is first turned on.
 
  
 Output
 For each test case, output a single line containing the number of milliseconds until the microcontroller freezes.
 
 Constraints
 
 1 ≤ T ≤ 10
 2 ≤ N ≤ 500
 1 ≤ Ai ≤ 109
 
 
 Subtasks
 Subtask #1 (10 points) 1 ≤ T ≤ 10, 2 ≤ N ≤ 9, 1 ≤ Ai ≤ 500
 Subtask #2 (20 points) 1 ≤ T ≤ 10, 2 ≤ N ≤ 500, 1 ≤ Ai ≤ 1000
 Subtask #3 (70 points) original constraints
  
 Example
 Input:
 3
 3
 2 3 5
 4
 1 8 7 11
 4
 4 4 5 6
 
 Output:
 6
 7
 4
 
 
 Explanation
 Case 1: in 6 milliseconds, the third reading will be attempted from the 1st sensor and the second reading will be attempted from the 2nd sensor.
 Case 2: in 7 milliseconds the seventh reading will be attempted from the 1st sensor and the first reading will be attempted from the 3rd sensor.
 Case 3: in 4 milliseconds, the first readings from the first two sensors will be attempted.",ALEXTASK,S12121952,PYTH,"def microcontroller_freeze(T, test_cases):
    # T: int, number of test cases
    # test_cases: list of tuples, each tuple containing two elements:
    #   - N: int, number of sensors
    #   - frequencies: list of ints, frequencies of measurements for each sensor
    # returns: list of ints, time in milliseconds until the microcontroller freezes for each test case
    
    # Initialize the result list
    result = []
    
    # Iterate over the test cases
    for case in test_cases:
        N, frequencies = case
        # Find the least common multiple of the frequencies
        lcm = frequencies[0]
        for i in range(1, N):
            lcm = lcm * frequencies[i] // math.gcd(lcm, frequencies[i])
        # Append the least common multiple to the result list
        result.append(lcm)
    
    return result
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 
 As a cryptologist, after working on numerous cryptographic protocols, Alice is now retired and living happily in Wonderland. However Alice is still obsessed with security, she even invented a new way to set passwords. Given a board of n rows and n columns with unitary size cells, Alice creates a password by drawing exactly n+1 lines with vertices of the integer points on the perimeter of the board. 
 
 
 
 One day Alice forgot her CodeChef password! She knew that she had set her password in the secure way. She remembers that no two lines were parallel, and that every cell of the board was cut by at least one of the lines. A cell is cut by a line when there exists a point strictly inside of the cell that belongs to the line.
 
 
 Please help Alice finding one password satisfying the information that she remembered.
 
 Input
 The first line of the input contains one integer T the number of test cases.
 Each test case is described by a line containing an integer n representing the size of the board.
 Output
 For each test case print n + 1 lines each of them containing four integers x1 y1 x2 y2 with x1 ≠ x2 and y1 ≠ y2, representing a line that goes from (x1,y1) to (x2,y2). 
 If there are multiple passwords that satisfies the information, print any of them.
 Constraints
 
 1 ≤ T ≤ 10 
 1 ≤ n ≤ 103 
 
 Example
 Input:
 1
 3
 
 Output:
 0 0 3 2
 3 0 0 2
 0 1 2 3
 0 3 3 2
 
 Explanation
 One of the possible passwords is depicted in the above figure.
 Every cell is cut by at least one line, for example the green cell is cut by the blue and purple lines, but not by the yellow one. The integer points on the perimeter of the board are drawn as small black circles.",ALICE,S11253155,PYTH,"def generate_password(n):
  # Initialize the password with n+1 empty lines
  password = [[] for _ in range(n+1)]

  # Draw the first line from (0, 0) to (n, 0)
  password[0] = [(0, 0), (n, 0)]

  # Loop through the remaining lines
  for i in range(1, n+1):
    # Draw the line from (i, 0) to (i, n)
    password[i] = [(i, 0), (i, n)]

  # Return the password
  return password

# Test the function with some examples
print(generate_password(3))
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 Not everyone probably knows that Chef has younder brother Jeff. Currently Jeff learns to read.
 He knows some subset of the letter of Latin alphabet. In order to help Jeff to study, Chef gave him a book with the text consisting of N words. Jeff can read a word iff it consists only of the letters he knows.
 Now Chef is curious about which words his brother will be able to read, and which are not. Please help him!
 Input
 The first line of the input contains a lowercase Latin letter string S, consisting of the letters Jeff can read. Every letter will appear in S no more than once.
 The second line of the input contains an integer N denoting the number of words in the book.
 Each of the following N lines contains a single lowecase Latin letter string Wi, denoting the ith word in the book.
 Output
 For each of the words, output ""Yes"" (without quotes) in case Jeff can read it, and ""No"" (without quotes) otherwise.
 Constraints
 
 1 ≤ |S| ≤ 26
 1 ≤ N ≤ 1000
 1 ≤ |Wi| ≤ 12
 Each letter will appear in S no more than once.
 S, Wi consist only of lowercase Latin letters.
 
 Subtasks
 
 Subtask #1 (31 point): |S| = 1, i.e. Jeff knows only one letter.
 Subtask #2 (69 point) : no additional constraints
 
 Example
 Input:
 act
 2
 cat
 dog
 
 Output:
 Yes
 No
 
 Explanation
 The first word can be read.
 The second word contains the letters d, o and g that aren't known by Jeff.",ALPHABET,S11268333,PYTH,"# Read the letters that Jeff knows
letters = input().strip()

# Read the number of words in the book
num_words = int(input().strip())

# Read each word in the book and check if Jeff can read it
for i in range(num_words):
  word = input().strip()
  can_read = True
  for letter in word:
    if letter not in letters:
      can_read = False
      break
  if can_read:
    print(""Yes"")
  else:
    print(""No"")
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 
 There's an array A consisting of N non-zero integers A1..N. A subarray of A is called alternating if any two adjacent elements in it have different signs (i.e. one of them should be negative and the other should be positive).
 
 For each x from 1 to N, compute the length of the longest alternating subarray that starts at x - that is, a subarray Ax..y for the maximum possible y ≥ x. The length of such a subarray is y-x+1.
 
 Input
 
 The first line of the input contains an integer T - the number of test cases.
 The first line of each test case contains N.
 The following line contains N space-separated integers A1..N.
 
 Output
 For each test case, output one line with N space-separated integers - the lengths of the longest alternating subarray starting at x, for each x from 1 to N.
 Constraints
 
 1 ≤ T ≤ 10
 1 ≤ N ≤ 105
 -109 ≤ Ai ≤ 109
 
 Example
 Input:
 3
 4
 1 2 3 4
 4
 1 -5 1 -5
 6
 -5 -1 -1 2 -2 -3
 
 Output:
 1 1 1 1
 4 3 2 1
 1 1 3 2 1 1
 Explanation
 Example case 1. No two elements have different signs, so any alternating subarray may only consist of a single number.
 Example case 2. Every subarray is alternating.
 Example case 3. The only alternating subarray of length 3 is A3..5.",ALTARAY,S10001454,PYTH,"def longest_alternating_subarray(n, arr):
  # Initialize the result array with 1s
  res = [1] * n

  # Loop through the array, starting from the second element
  for i in range(1, n):
    # If the current element has a different sign than the previous element,
    # update the result for the current position to be the result for the
    # previous position plus 1
    if (arr[i] > 0 and arr[i-1] < 0) or (arr[i] < 0 and arr[i-1] > 0):
      res[i] = res[i-1] + 1
  
  # Return the result array
  return res

# Test the function with some examples
print(longest_alternating_subarray(4, [1, 2, 3, 4]))  # Should print [1, 1, 1, 1]
print(longest_alternating_subarray(4, [1, -5, 1, -5]))  # Should print [4, 3, 2, 1]
print(longest_alternating_subarray(6, [-5, -1, -1, 2, -2, -3]))  # Should print [1, 1, 3, 2, 1, 1]
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Russian here
 The Head Chef has been playing with Fibonacci numbers for long . He has learnt several tricks related to Fibonacci numbers . Now he wants to test his chefs in the skills . 
 A fibonacci number is defined by the recurrence :
 f(n) = f(n-1) + f(n-2) for n > 2 and f(1) = 0 and f(2) = 1 . 
 Given a number A , determine if it is a fibonacci number.
 Input
 
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
 The only line of each test case contains a single integer A denoting the number to be checked .
 
 Output
 
 For each test case, output a single line containing ""YES"" if the given number is a fibonacci number , otherwise output a single line containing ""NO"" . 
 
 Constraints
 
 1 ≤ T ≤ 1000
 1 ≤ number of digits in A ≤ 1000
  The sum of number of digits in A in all test cases <= 10000. 
 
 Example
 Input:
 3
 3
 4
 5
 
 Output:
 YES
 NO
 YES
 Explanation
 Example case 1. The first few fibonacci numbers are 0 , 1 , 1 , 2 , 3 ,5 , 8 , 13 and so on and the series is increasing . Only 3 and 5 appear in this series while 4 does not appear in the series .",AMIFIB,S10039114,PYTH,"def is_fibonacci(n):
  # Initialize the first two Fibonacci numbers
  a, b = 0, 1

  # Loop until we find a Fibonacci number greater than n
  while b <= n:
    # If we find a match, return ""YES""
    if b == n:
      return ""YES""
    
    # Otherwise, calculate the next Fibonacci number
    a, b = b, a + b

  # If we reach here, it means we have not found a Fibonacci number
  # that is equal to n, so return ""NO""
  return ""NO""

# Test the function with some examples
print(is_fibonacci(3))  # Should print ""YES""
print(is_fibonacci(4))  # Should print ""NO""
print(is_fibonacci(5))  # Should print ""YES""
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.Kattapa, as you all know was one of the greatest warriors of his time. The kingdom of Maahishmati had never lost a battle under him (as army-chief), and the reason for that was their really powerful army, also called as Mahasena.
 Kattapa was known to be a very superstitious person. He believed that a soldier is ""lucky"" if the soldier is holding an even number of weapons, and ""unlucky"" otherwise. He considered the army as ""READY FOR BATTLE"" if the count of ""lucky"" soldiers is strictly greater than the count of ""unlucky"" soldiers, and ""NOT READY"" otherwise.
 Given the number of weapons each soldier is holding, your task is to determine whether the army formed by all these soldiers is ""READY FOR BATTLE"" or ""NOT READY"".
 Note: You can find the definition of an even number here.
 Input
 
 The first line of input consists of a single integer N denoting the number of soldiers. The second line of input consists of N space separated integers A1, A2, ..., AN, where Ai denotes the number of weapons that the ith soldier is holding.
 Output
 Generate one line output saying ""READY FOR BATTLE"", if the army satisfies the conditions that Kattapa requires or ""NOT READY"" otherwise (quotes for clarity).
 Constraints
 
 1 ≤ N ≤ 100
 1 ≤ Ai ≤ 100
 
 Example 1
 Input:
 1
 1
 
 Output:
 NOT READY
 
 Example 2
 Input:
 1
 2
 
 Output:
 READY FOR BATTLE
 
 Example 3
 Input:
 4
 11 12 13 14
 
 Output:
 NOT READY
 
 Example 4
 Input:
 3
 2 3 4
 
 Output:
 READY FOR BATTLE
 
 Example 5
 Input:
 5
 1 2 3 4 5
 
 Output:
 NOT READY
 
 Explanation
 
 Example 1: For the first example, N = 1 and the array A = [1]. There is only 1 soldier and he is holding 1 weapon, which is odd. The number of soldiers holding an even number of weapons = 0, and number of soldiers holding an odd number of weapons = 1. Hence, the answer is ""NOT READY"" since the number of soldiers holding an even number of weapons is not greater than the number of soldiers holding an odd number of weapons.
 
 Example 2: For the second example, N = 1 and the array A = [2]. There is only 1 soldier and he is holding 2 weapons, which is even. The number of soldiers holding an even number of weapons = 1, and number of soldiers holding an odd number of weapons = 0. Hence, the answer is ""READY FOR BATTLE"" since the number of soldiers holding an even number of weapons is greater than the number of soldiers holding an odd number of weapons.
 
 Example 3: For the third example, N = 4 and the array A = [11, 12, 13, 14]. The 1st soldier is holding 11 weapons (which is odd), the 2nd soldier is holding 12 weapons (which is even), the 3rd soldier is holding 13 weapons (which is odd), and the 4th soldier is holding 14 weapons (which is even). The number of soldiers holding an even number of weapons = 2, and number of soldiers holding an odd number of weapons = 2. Notice that we have an equal number of people holding even number of weapons and odd number of weapons. The answer here is ""NOT READY"" since the number of soldiers holding an even number of weapons is not strictly greater than the number of soldiers holding an odd number of weapons.
 
 Example 4: For the fourth example, N = 3 and the array A = [2, 3, 4]. The 1st soldier is holding 2 weapons (which is even), the 2nd soldier is holding 3 weapons (which is odd), and the 3rd soldier is holding 4 weapons (which is even). The number of soldiers holding an even number of weapons = 2, and number of soldiers holding an odd number of weapons = 1. Hence, the answer is ""READY FOR BATTLE"" since the number of soldiers holding an even number of weapons is greater than the number of soldiers holding an odd number of weapons.
 
 Example 5: For the fifth example, N = 5 and the array A = [1, 2, 3, 4, 5]. The 1st soldier is holding 1 weapon (which is odd), the 2nd soldier is holding 2 weapons (which is even), the 3rd soldier is holding 3 weapons (which is odd), the 4th soldier is holding 4 weapons (which is even), and the 5th soldier is holding 5 weapons (which is odd). The number of soldiers holding an even number of weapons = 2, and number of soldiers holding an odd number of weapons = 3. Hence, the answer is ""NOT READY"" since the number of soldiers holding an even number of weapons is not greater than the number of soldiers holding an odd number of weapons.",AMR15A,S10032869,PYTH,"# Read the number of test cases
t = int(input())

# Iterate over the test cases
for _ in range(t):
  # Read the number of soldiers and the weapons they are holding
  n = int(input())
  weapons = list(map(int, input().split()))

  # Count the number of soldiers holding even and odd number of weapons
  even_count = sum([1 for w in weapons if w % 2 == 0])
  odd_count = sum([1 for w in weapons if w % 2 == 1])

  # Check if the number of soldiers holding even number of weapons is greater than the number of soldiers holding odd number of weapons
  if even_count > odd_count:
    print(""READY FOR BATTLE"")
  else:
    print(""NOT READY"")
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.Devasena was the princess of an unknown kingdom (we'll all know which one, in Baahubali 2 ;) ), and her father arranged for a Swayamvara to get her married. He gave all of them a question, and the question was so hard that nobody was able to answer it (Yes you guessed it right, both Baahubali and Bhallaladeva were not present there for the Swayamvara). We all know that Amarendra Baahubali married her later and as a consequence of so many things, she was imprisoned for 25 years. Who knows, if someone else had answered the question that day, then she would have got married to him and things could have been different. Phew! But the bad part, we wouldn't have had the story of Baahubali. :) 
 Although everything is history now, recently archaeologists discovered the secret question that was asked at the Swayamvara, and you think - ""Well, it's such a simple question. I could use a computer to solve it!"". The question goes as follows: 
 
 You are given N integers (not necessarily distinct) => A1, A2, A3, ..., AN. There are 2N possible subsets (including the empty subset). The GCD of a subset is defined as the greatest common divisor of all the integers in that subset. You need to find the product of the GCDs of all the 2N possible subsets you can construct from A. Since the answer can be large, you need to output the answer modulo 1000000007. Do you think you can solve this question?
 
 Note: The greatest common divisor of an empty subset is 1. To know more about the definition of greatest common divisor, check here.
 
 Input
 The first line of input consists of a single integer T denoting the number of test cases. The description of T test cases follow. The first line of each test case consists of a single integer N. The second line of each test case consists of N space separated integers A1, A2, ..., AN
 Output
 For each test case, output an single integer on a separate line denoting the answer for that test case. Note that you need to output all the values modulo 1000000007 (109 + 7).
 Constraints
 
 1 ≤ T ≤ 30
 1 ≤ N ≤ 105
 1 ≤ Ai ≤ 105
 
 Example
 Input:
 3
 1
 1
 2
 1 2
 3
 1 2 2
 
 Output:
 1
 2
 8
 
 Explanation
 For the first test case, N = 1, and A = [1]. There are 2 possible subsets => {}, {1} and both have a gcd of 1. Hence, the answer is 1 * 1 = 1.
 For the second test case, N = 2, and A = [1, 2]. There are 4 possible subsets => {}, {1}, {2}, {1, 2}, having a gcd of 1, 1, 2 and 1 respectively. Hence, the answer is 1 * 1 * 2 * 1 = 2.
 For the third test case, N = 3, and A = [1, 2, 2]. There are 8 possible subsets => {}, {1}, {2}, {2}, {1, 2}, {2, 2}, {1, 2}, {1, 2, 2}, having a gcd of 1, 1, 2, 2, 1, 2, 1, 1. Hence, the answer is 1 * 1 * 2 * 2 * 1 * 2 * 1 * 1 = 8.",AMR15B,S11899086,PYTH,"MOD = 1000000007

def solve(n, a):
  # Find the gcd of all elements in a
  g = a[0]
  for i in range(1, n):
    g = gcd(g, a[i])

  # Calculate the product of all gcd of all possible subsets of a
  ans = 1
  for i in range(n + 1):
    ans = (ans * g) % MOD

  return ans

# Function to calculate gcd of two numbers
def gcd(a, b):
  if b == 0:
    return a
  return gcd(b, a % b)

# Test cases
test_cases = [
  [1, [1]],
  [2, [1, 2]],
  [3, [1, 2, 2]],
]

for test_case in test_cases:
  n = test_case[0]
  a = test_case[1]
  print(solve(n, a))
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.The Kalakeyas were a powerful, ferocious and cruel clan of Danavas. They were known to be really strong and they did not have any war strategy. They would just attack the enemy randomly and overpower them with sheer number of soldiers. However, we all know that Baahubali and Bhallaladeva defeated the Kalakeyas by following the Thrishul strategy, and successfully defended their kingdom Maahishmati. We also know that Baahubali was very smart, and the truth is that he predicted how the Kalakeyas would attack and devised a counter strategy for the same, the night before the war. This is what he found:
 The Kalakeyas had N forts, numbered 1 to N and Baahubali had N soldiers, numbered 1 to N. Baahubali discovered that he can permute his soldiers in any way to get a permutation of 1 to N => P1, P2, ..., PN. He would then send his soldiers to attack the forts in the following way: soldier P1 attacks fort 1, soldier P2 attacks fort 2, ..., soldier PN attacks fort N. It is easy to note that each soldier attacks exactly one fort and no two soldiers attack the same fort. Baahubali also got to know about a secret key of the Kalakeyas, which is an integer K. A soldier X can destroy a fort Y, iff abs(X - Y) >= K. For more details on the abs() function, check here.
 
 Your task is to determine whether Baahubali's soldiers can be permuted in some way, such that all forts can be destroyed. In other words, for a permutation P1, P2, ..., PN, Baahubali's soldiers can destroy all the forts iff abs(Pi - i) >= K, for all 1 <= i <= N. If this is possible, you are also required to output the lexicographically smallest such permutation. If it is not possible, output -1.
 
 Note: A permutation A1, A2, ..., AN is said to be lexicographically smaller than a permutation B1, B2, ..., BN, if and only if at the first i where Ai and Bi differ, Ai comes before Bi. You can refer here for a more detailed definition of lexicographic ordering.
 
 Input
 The first line of input consists of a single integer T denoting the number of test cases. Each of the following T lines contain two space separated integers N and K denoting the values mentioned in the statement above.
 Output
 For each test case, output a single line containing N space separated integers (which should be a permutation of [1..N], if Baahubali's soldiers can break all the forts. If it is not possible to break all the forts, output ""-1"" (quotes for clarity).
 Constraints
 
 1 ≤ T ≤ 1000
 1 ≤ N ≤ 105
 0 ≤ K ≤ N
 The sum of N over all test cases in a single test file will not exceed 105
 
 Example
 Input:
 3
 2 2
 3 0
 3 1
 
 Output:
 -1
 1 2 3
 2 3 1
 Explanation
 For the first test case, N = 2 and K = 2. It is impossible to permute [1, 2] in any way such that abs(P[1]-1) >= 2 and abs(P[2]-2) >= 2. Hence, output is -1.
 For the second test case, N = 3 and K = 0. We can just set P[i] = i, and hence the answer is 1 2 3
 For the third case, the valid permutations are [2, 3, 1] and [3, 1, 2]. The answer is [2, 3, 1] since it is lexicographically smaller than [3, 1, 2].",AMR15C,S10136063,PYTH,"def solve(n, k):
  # If k is 0, then we can simply permute the soldiers in increasing order
  # to attack the forts.
  if k == 0:
    return [i for i in range(1, n+1)]
  
  # If k is greater than n, then we cannot destroy any fort.
  if k > n:
    return -1
  
  # Otherwise, we can permute the soldiers in the following way:
  # [k+1, k+2, ..., n, 1, 2, ..., k]
  permutation = [i for i in range(k+1, n+1)] + [i for i in range(1, k+1)]
  return permutation

# Test the solution
assert solve(2, 2) == -1
assert solve(3, 0) == [1, 2, 3]
assert solve(3, 1) == [2, 3, 1]
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 Chef is playing a game on a sequence of N positive integers, say A1, A2, ... AN. The game is played as follows.
 
 If all the numbers are equal, the game ends.
 Otherwise
 
 Select two numbers which are unequal
 Subtract the smaller number from the larger number
 Replace the larger number with the result from above (see the explanation section for clarity)
 
 
 
 Chef has already figured out that the game always terminates. He also knows, for a given sequence of integers, the game will always terminate on the same value, no matter how the game is played. Chef wants you to simulate the game for him and tell him on which value will the game terminate for a given sequence of integers.
 Input
 The first line of the input contains an integer T, the number of test cases. Then follow the description of T test cases. The first line of each test case contains a single integer N, the length of the sequence. The second line contains N positive integers, each separated by a single space.
 Output
 For each test case, output a single integer - the value of all the numbers when they are equal (and the game terminates), on a line by itself.
 Constraints
 
 1 ≤ T ≤ 100
 1 ≤ N ≤ 1000
 1 ≤ Ai ≤ 109
 
 Sample
 
 Input
 3
 2
 10 12
 2
 5 9
 3
 6 10 15
 
 Output
 2
 1
 1
 
 Explanation
 Test Case 1: Since there are only two numbers, the operations are forced.
 
 { 10, 12 } => Replace 12 with ( 12 - 10 = 2 ) => { 10, 2 }
 { 10, 2 } => Replace 10 with ( 10 - 2 = 8 ) => { 8, 2 }
 { 8, 2 } => Replace 8 with ( 8 - 2 = 6 ) => { 6, 2 }
 { 6, 2 } => Replace 6 with ( 6 - 2 = 4 ) => { 4, 2 }
 { 4, 2 } => Replace 4 with ( 4 - 2 = 2 ) => { 2, 2 }
 
 The value of all the numbers when the game ends is 2.
 Test Case 2: Since there are only two numbers, the operations are forced.
 
 { 5, 9 } => Replace 9 with ( 9 - 5 = 4 ) => { 5, 4 }
 { 5, 4 } => Replace 5 with ( 5 - 4 = 1 ) => { 1, 4 }
 { 1, 4 } => Replace 4 with ( 4 - 1 = 3 ) => { 1, 3 }
 { 1, 3 } => Replace 3 with ( 3 - 1 = 2 ) => { 1, 2 }
 { 1, 2 } => Replace 2 with ( 2 - 1 = 1 ) => { 1, 1 }
 
 The value of all the numbers when the game ends is 1.
 Test Case 3: One way to play the game is
 
 { 6, 10, 15 } => Replace 15 with ( 15 - 6 = 9 ) => { 6, 10, 9 }
 { 6, 10, 9 } => Replace 10 with ( 10 - 6 = 4 ) => { 6, 4, 9 }
 { 6, 4, 9 } => Replace 9 with ( 9 - 6 = 3 ) => { 6, 4, 3 }
 { 6, 4, 3 } => Replace 6 with ( 6 - 4 = 2 ) => { 2, 4, 3 }
 { 2, 4, 3 } => Replace 3 with ( 3 - 2 = 1 ) => { 2, 4, 1 }
 { 2, 4, 1 } => Replace 4 with ( 4 - 2 = 2 ) => { 2, 2, 1 }
 { 2, 2, 1 } => Replace first 2 with ( 2 - 1 = 1 ) => { 1, 2, 1 }
 { 1, 2, 1 } => Replace 2 with ( 2 - 1 = 1 ) => { 1, 1, 1 }
 
 The value of all the numbers when the game ends is 1. You may try to play the game differently and observe that the game will always end when all the values are 1.",AMSGAME1,S10128943,PYTH,"def gcd(a, b):
  # Returns the greatest common divisor of a and b
  if a == 0:
    return b
  return gcd(b % a, a)

t = int(input())

for _ in range(t):
  n = int(input())
  # Read the array of numbers
  a = list(map(int, input().split()))
  # Initialize the gcd to be the first number in the array
  g = a[0]
  # Find the gcd of all the numbers in the array
  for i in range(1, n):
    g = gcd(g, a[i])
  # If the gcd is 1, then all the numbers will be 1 after the operations
  # Otherwise, the gcd will be the final value
  if g == 1:
    print(1)
  else:
    print(g)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 A pair of non-negative integers (A,B) is called and-pair if A & B = B, i.e., bitwise-and of A and B is equal to B. Similarly, a tuple of K non-negative integers (A1,A2,A3 .. AK) is called and-tuple if Ai & Ai+1 = Ai+1 for 1≤i≤K-1.
 Given two integers N and K, how many and-tuples of size K exist such that the sum of the elements of the tuple is N?
 Input
 First line contains T, the number of testcases, then T lines follow. Each of the following lines contain two space-separated integers K and N.
 Output
 For each testcase, print a single line containing the answer. Since the number can be quite large, print the answer modulo 1000000009.
 Constraints
 
 For 20 points: 1 ≤ T ≤ 10000, K = 3, 1 ≤ N ≤ 1018For 80 points: 1 ≤ T ≤ 10000, 3 ≤ K ≤ 4, 1 ≤ N ≤ 1018
 Example
 Input:
 23 24 2Output:
 22Explanation:
 
 In the first case, the two and-tuples are (2,0,0) and (1,1,0).
 In the second case they are (2,0,0,0) and (1,1,0,0).",ANDTUPLE,S5225340,PYTH,"MOD = 1000000009

def count_and_tuples(k, n):
  # Base case: if k = 1, there is only one and-tuple
  if k == 1:
    return 1
  # Initialize the count to zero
  count = 0
  # Iterate over all possible values of the last element in the and-tuple
  for i in range(n+1):
    # Calculate the count of and-tuples of size k-1 with sum n-i
    count += count_and_tuples(k-1, n-i)
    # Take the modulo of the count
    count %= MOD
  # Return the count of and-tuples
  return count

# Read the number of test cases
t = int(input())
# Iterate over the test cases
for _ in range(t):
  # Read the values of k and n
  k, n = map(int, input().split())
  # Calculate the count of and-tuples
  count = count_and_tuples(k, n)
  # Print the count of and-tuples
  print(count)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese , Russian and Vietnamese
 Mark has recently started studying string algorithms. So, as to gauge his knowledge, Lucy challenges him to a task.
 ""Given a string s, answer several times a query to determine whether a substring s[i, j] (inclusive) is palindromic or not."", said Lucy in a confident tone!
 As smart as Mark is, he was able to instantly find the solution!
 Now, Mark has challenged little Lucy to do the same task by reversing a specific substring beforehand. As Lucy is still just a novice, she asks for your help.
 You have to write a program that answers Q queries on a string S.
 Each query contains four integers (i, j, k, l).
 For every query, first reverse the substring s[i, j] (inclusive) and then report if substring s[k, l] (inclusive) is a palindrome.
 Note that the reversal operations are only for the specific query and should not persist for further queries. Please check the explanation section for better understanding.
 Input:
 The first line of input file contains string S. The next line contains an integer Q.
 Each of the following Q lines each contain 4 space separated integers i, j, k and l.
 Output:
 Output exactly Q lines, each containing the result of corresponding query as ""Yes"" or ""No"".
 Constraints:
 
 
 1 ≤ |S| ≤ 105
 
 1 ≤ Q ≤ 333333
 
 1 ≤ i ≤ j ≤ |S| 
 
 1 ≤ k ≤ l ≤ |S|
 S contains only the characters 'a' to 'z'
 
 
 Example:
 Sample Input:
 
 ababa
 4
 2 3 3 4
 1 2 3 4
 1 3 3 5
 2 4 1 5
 
 
 Sample Output:
 
 Yes
 No
 Yes
 Yes
 
 Explanation:
 Query 1:
 The string becomes aabba. The queried substring is bb, which is a palindrome.
 Query 2:
 The string becomes baaba. The queried substring is ab, which is not a palindrome.
 Query 3:
 The string becomes ababa. The queried substring is aba, which is a palindrome.
 Query 4:
 The string becomes ababa. The queried substring is ababa, which is a palindrome.
 Notes:
 
 Here, a substring [i, j] is defined as the string formed by characters s[i], s[i+1],..., s[j].
 A palindrome is a sequence of characters which reads the same backward or forward. For example, aba, abba are palindromes, while abab and abcd are not palindromes.",ANKPAL,S7208761,PYTH,"# Get the input string S and the number of queries Q
S = input()
Q = int(input())

# Process the queries
for i in range(Q):
  # Get the indices for the reversal and the palindrome check
  i, j, k, l = map(int, input().split())
  
  # Reverse the substring s[i:j+1]
  S = S[:i-1] + S[i-1:j+1][::-1] + S[j+1:]
  
  # Check if the substring s[k:l+1] is a palindrome
  if S[k-1:l+1] == S[k-1:l+1][::-1]:
    print(""Yes"")
  else:
    print(""No"")
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
 Chef has recently learnt about sequences of parentheses. These are special sequences that contain only the characters '(' and ')'.
 A regular parentheses sequence follows the following definition: 
 
 
 An empty sequence is regular
 If S is a regular sequence, then (S) is also regular
 If A and B represent two regular sequences, then their concatenation AB is also regular.
 
 Therefore, the sequences (), ()() and (())() are regular, while ()(, ) and ))() are non-regular.
 Now, you need to find the longest subsequence of the given sequence which is non-regular. Amongst all such distinct answers, output the lexicographically Kth amongst them. If the number of distinct subsequences with maximum length is less than K, please output -1 instead.
 Input:
 The first line contains a single integer T, denoting the number of test cases to follow.
 Each of the test cases have exactly two lines, the first contains the parentheses sequence and the second contains the value of K.
 Output:
 Output exactly T lines, each containing answer to the corresponding query.
 Constraints:
 
 1 ≤ T ≤ 10
 1 ≤ |S| ≤ 105
 1 ≤ K ≤ 109
 
 Example:
 Sample Input:
 
 5
 ()
 2
 (()
 1
 (()
 2
 (())
 2
 (())
 3
 
 
 Sample Output:
 
 )
 (()
 -1
 ())
 -1
 
 
 Explanation:
 Case 1:
 Following are the subsequences: 
 
 
 Length Subsequence Regular/Non-Regular
 
  1 ( Non-regular
  1 ) Non-regular
  2 () Regular
 
 
 There are two non-regular subsequences of equal length:'(' and ')'.
 We are asked for the lexicographically 2nd, so output should be ')'.
 Case 2:
 Following are the subsequences: 
 
 
 Length Subsequence Regular/Non-Regular
  1 ( Non-Regular
  1 ) Non-Regular
  2 (( Non-Regular
  2 () Regular
  3 (() Non-Regular
 
 
 In this case, there are non-regular subsequences of lengths 1, 2, and 3. But, as 3 is the maximum among these, we choose, (().
 Case 3:
 The string is same as Case 2, and we realize that there is only one subsequence of the maximum length 3, thus we must output -1.
 Case 4:
 We can find that following subsequences have maximum length and are non-regular.
 
 Length Subsequence
  3 ()) 
  3 (()
 
 
 In lexicographical order, we have following subsequences: [ ((), ()) ]
 The query asks for 2nd subsequence, thus the required output is ()).
 Case 5:
 This is the same sequence as last case, and we know that there are exactly 2 distinct subsequences of maximum length. Thus, answer should be -1.
 Notes:
 
 A subsequence of a given sequence A is a non-empty sequence obtained by removing zero or more characters from A. It does not need to be contiguous.
 A sequence A is called different from another sequence B, if there exists an integer k, such that 1 ≤ k ≤ N (N is the length of both sequences), and Ak != Bk.
 Consider two different N-length sequences, A and B. Let k be the smallest integer such that A[k] != B[k] and 1 ≤ k ≤ N. If A[k] < B[k], then A is said to be lexicographically smaller than B, and vice-versa.",ANKPAREN,S7265376,PYTH,"from collections import Counter

def find_longest_non_regular_subsequence(s, k):
  # Count the number of '(' and ')' characters in the sequence
  c = Counter(s)
  # Calculate the number of pairs of '(' and ')' characters
  pairs = min(c['('], c[')'])
  # Calculate the maximum length of a non-regular subsequence
  max_len = pairs * 2
  # Find all the non-regular subsequences of maximum length
  subsequences = []
  for i in range(len(s)-max_len+1):
    # Check if the subsequence is non-regular
    if s[i:i+max_len].count('(') != pairs or s[i:i+max_len].count(')') != pairs:
      continue
    # Add the subsequence to the list if it is non-regular
    subsequences.append(s[i:i+max_len])
  # Sort the list of non-regular subsequences in lexicographical order
  subsequences.sort()
 
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
 Problem description
 Abhijeet loves to play with rectangles. Today he has N rectangles of various sizes with him. He started to arrange them on the coordinate plane such that the area of intersection is maximized. However, he never rotated the rectangles he had, he only moved them here and there.
 Abhijeet soon realized that the game was boring and decided to introduce a modification. He decided to remove atmost M of those rectangles and arrange others on coordinate plane such that the area of intersection is maximized.
 Given the dimensions of N rectangles and M, can you answer maximum possible area of intersection with above rules?
 Note: If all the rectangles are removed, the area of intersection is considered as 0.
 Input
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.First line of each test case has two integer N and M. N lines follow, each has two integers representing the length and breadth of the rectangle.
 Output
 For each test case, output a single line containing the required answer.
 Constraints
 
 1 ≤ T ≤ 105
 1 ≤ N ≤ 105
 0 ≤ M ≤ N
 1 ≤ Rectangle Dimensions ≤ 109
 1 ≤ Sum of N over all test cases ≤ 106
 
 Example
 Input:
 3
 1 1
 10 10
 2 0
 5 10
 5 5
 2 1
 1 1
 2 2
 
 Output:
 100
 25
 4
 Explanation
 Example case 1
 Abhijeet has only one rectangle. He can remove it, but then the area will be 0. Optimal way is not to remove it. Area = 10 * 10 = 100
 Example case 2
 Abhijeet cannot remove any rectangles in this case. He can however, place them such that the smaller 5 by 5 rectangle is completely inside the larger 5 by 10 rectangle. Then the area of intersection is 5 * 5 = 25
 Example case 3
 Abhijeet can remove atmost 1 rectangles in this case. He can remove the smaller rectangle of size 1 by 1. He is then left with 2 by 2 rectangle of area 4.",ANUAHR,S5935818,PYTH,"# Read in the number of test cases
T = int(input())

# Loop through each test case
for t in range(T):
    # Read in the number of rectangles and the maximum number of rectangles that can be removed
    N, M = map(int, input().split())

    # Initialize a list to store the rectangles
    rectangles = []

    # Read in the dimensions of each rectangle
    for n in range(N):
        l, b = map(int, input().split())
        rectangles.append((l, b))

    # Sort the rectangles by area in descending order
    rectangles.sort(key=lambda x: x[0] * x[1], reverse=True)

    # Initialize the total area to be the area of the first rectangle
    total_area = rectangles[0][0] * rectangles[0][1]

    # Loop through the remaining rectangles
    for i in range(1, N):
        # If we can remove the current rectangle, do so and subtract its area from the total
        if M > 0:
            total_area -= rectangles[i][0] * rectangles[i][1]
            M -= 1
        # Otherwise, break out of the loop since we can't remove any more rectangles
        else:
            break

    # Print the total area
    print(total_area)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
 
 N Soldiers are lined up for a memory test. They are numbered from 0 to N-1 from left to right.
 
 
 In the test, there are M rounds. In each round, Captain selects one position. Soldier at that position will be numbered 0. All the soldiers to the right of selected position will be numbered one greater than the soldier to his left. All the soldiers to the left of selected position will be numbered one greater than the soldier to his right. 
 eg. if N = 6 and selected position is 3, then the numbering will be [3, 2, 1, 0, 1, 2].
 
 
  After M rounds, Captain asked each soldier to shout out the greatest number he was assigned during the M rounds. In order to check the correctness, Captain asked you to produce the correct values for each soldier (That is the correct value each soldier should shout out).
 
 Input
 The first line of the input contains an integer T denoting the number of test cases.
 First line of each test case contains two integers, N and M.
 Second line of each test case contains M integers, the positions selected by Captain, in that order.
 Output
 For each test case, output one line with N space separated integers.
 Constraints
 
 1 ≤ T ≤ 10^4
 1 ≤ N ≤ 10^5
 1 ≤ M ≤ 10^5
 1 ≤ Sum of N over all testcases ≤ 10^5
 1 ≤ Sum of M over all testcases ≤ 10^5
 0 ≤ Positions selected by captain ≤ N-1
 
 Example
 Input
 2
 4 1
 1
 6 2
 2 3
 
 Output
 1 0 1 2
 3 2 1 1 2 3",ANUARM,S10012637,PYTH,"t = int(input())
for _ in range(t):
  # Read the number of soldiers and rounds
  n, m = map(int, input().split())
  # Initialize the list of numbers shouted by each soldier
  numbers = [0] * n
  # Read the positions selected in each round
  positions = list(map(int, input().split()))
  # Iterate over the rounds in reverse order
  for i in range(m-1, -1, -1):
    # Select the position for this round
    p = positions[i]
    # Calculate the numbers shouted by each soldier
    for j in range(p-1, -1, -1):
      numbers[j] = numbers[j+1] + 1
    for j in range(p+1, n):
      numbers[j] = numbers[j-1] + 1
  # Print the numbers shouted by each soldier
  print("" "".join(str(x) for x in numbers))
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
 Statement
 Chef gives you a book with N pages. The pages are numbered from 1 to N.
 Chef randomly selects a Secret Digit from 0 to 9. Now he asks you to open one page of the book without looking at the book. You win the game if that page number contains the Secret Digit. For example if the Secret Digit is 8, then 8, 80, 1238213, 98 are all winning pages and 9, 90, 1239123 are loosing pages.
 What is the probability of winning, if both Chef's choice and your choice has uniform distribution?
 Input
 The first line of input contains integer T, denoting the number of test cases.
 Each test case consists of a single line with integer N.
 Output
 For each test case, output the required probability P/Q. P/Q is an irreducible fraction.
 Constraints
 
 1 ≤ T ≤ 10000
 1 ≤ N ≤ 1017
 
 
 Example
 Input:
 2
 1
 5
 
 Output:
 1/10
 1/10
 
 Explanation
 Chef can choose any Secret Digit from 0 to 9. But you can only open page with number 1. Probability that the Secret Digit is 1 after you opened the page with number 1 is 1/10.",ANUBGC,S3923049,PYTH,"def gcd(a, b):
  # Calculate the greatest common divisor of a and b using the Euclidean algorithm
  while b != 0:
    a, b = b, a % b
  return a

t = int(input())
for _ in range(t):
  # Read the number of pages
  n = int(input())
  # Calculate the probability of winning
  p = gcd(n, 10)
  # Print the probability as a reduced fraction
  print(f""{p}/10"")
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
 Problem description
 It is winter super sale and all the shops have various offers. Suraj selected N items to buy and he is standing in the billing queue. It was then he noticed the offer ""Buy two, get two"". That means for every two items you buy, they give you two items for free. However, items can be of varying price, they always charge for 2 most costly items and give other 2 as free. For example, if the items cost 1, 1, 2, 2, then you have to pay 4 and take all 4 items.
 Suraj is busy reordering his items to reduce the total price he has to pay. He can separate the items and get them on different bills if needed. Can you tell me what is the least price Suraj has to pay to buy all the N items?
 Input
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. First line of each test case has single integer N. Second line of each test case has N space separated integers, which are the costs of items Suraj want to buy.
 Output
 For each test case, output a single line containing the required answer.
 Constraints
 
 1 ≤ T ≤ 1000
 1 ≤ N ≤ 1000
 1 ≤ Cost of items ≤ 1000
 
 Example
 Input:
 3
 4
 1 1 2 2
 2
 10 200
 7
 1 1 10 2 2 2 1
 
 Output:
 4
 210
 14
 Explanation
 Example case 1
 Suraj pays for 2 costly items and gets other 2 for free.
 Example case 2
 Suraj has to pay for both the items, he wont get anything for free.
 Example case 3
 Suraj separates the items into 2 bills. In one bill he pays 12. And in another bill he pays 2.",ANUBTG,S10078490,PYTH,"# Test case input comes from the console
def read_input():
  t = int(input())
  test_cases = []
  for i in range(t):
    n = int(input())
    costs = list(map(int, input().split()))
    test_cases.append((n, costs))
  return test_cases

# Test case output goes to the console
def write_output(output):
  for item in output:
    print(item)

def minimum_cost(test_case):
  n, costs = test_case
  costs.sort(reverse=True)
  total_cost = 0
  for i in range(0, n, 4):
    total_cost += costs[i] + costs[i+1]
  return total_cost

test_cases = read_input()
output = [minimum_cost(test_case) for test_case in test_cases]
write_output(output)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
 Problem description.
 Given a rooted tree with N nodes. Nodes of the tree are numbered from 1 to N. Node 1 is the root. You need to add M nodes to it in the given order. All the nodes have values. Cost for adding a node A with value va to another node B with value vb is va*vb. There is an additional cost of y (so total cost of va*vb+y) if B has atleast x child nodes. After node A has been added to another node B it becomes a child of B.
 After adding a node A to the tree, nodes next in list can be added to A also. You need to calculate the total minimal cost to add all M nodes in given order.
 Input
 The first line of input contains N. The second line of input contains N integers representing the values of nodes in order from node 1 to node N. N-1 lines follow, each line defines an edge. Each line has 2 integers, which says that those 2 nodes are connected.
 Next line of input contains an integer Q, denoting the number of queries you need to answer. Each query consists of 2 lines. The first line of each query has 3 integers, M x y. The second line of each query has M integers representing the values of the nodes to be added in order.
 Note that in each query, M nodes are added to the initial tree, and hence changes made in previous query should not be considered in later queries
 Output
 For each query, output a single line containing the minimal total cost to add all the nodes in given order.
 Constraints
 
 1 ≤ N ≤ 100000
 1 ≤ x ≤ 1000
 1 ≤ y ≤ 1000
 1 ≤ Q ≤ 100
 1 ≤ M ≤ 100
 1 ≤ Values of all nodes in input ≤ 1000
 
 Example
 Input:
 3
 2 2 3
 1 2
 2 3
 2
 2 2 10
 10 10
 3 2 10
 1 2 2
 
 Output:
 40
 6
 
 Explanation
 Query 1.
 Optimal solution is to add the first node from the query to node 1 of the tree and the second node from the query to node 2 of the tree. Cost is 10*2 + 10*2.
 Query 2.
 Optimal solution is to add the first node from the query to node 1 of the tree for a cost 2. Then add next two nodes from the query to newly added node.
 Total cost is 2 + 2 + 2 = 6.",ANUBTT,S3970119,PYTH,"# Store the values of the nodes in the initial tree
values = list(map(int, input().split()))

# Build the initial tree as a dictionary mapping each node to its children
tree = {}
for i in range(1, len(values)):
  a, b = map(int, input().split())
  if a not in tree:
    tree[a] = []
  if b not in tree:
    tree[b] = []
  tree[a].append(b)
  tree[b].append(a)

# Process the queries
q = int(input())
for _ in range(q):
  # Read the parameters of the query
  m, x, y = map(int, input().split())
  # Read the values of the nodes to be added
  new_values = list(map(int, input().split()))

  # Initialize the cost to zero
  cost = 0

  # For each node to be added, find the minimum cost to add it to the tree
  for v in new_values:
    # Initialize the minimum cost to add the node to the root
    min_cost = v * values[0] + y
    # Check if adding the node to the root has an additional cost
    if len(tree[1]) + 1 >= x:
      min_cost += y
    # Check the other nodes in the tree
    for i in range(2, len(values) + 1):
      # Calculate the cost of adding the node to this node
      c = v * values[i-1] + y
      # Check if adding the node to this node has an additional cost
      if len(tree[i]) + 1 >= x:
        c += y
      # Update the minimum cost if necessary
      min_cost = min(min_cost, c)
    # Add the minimum cost to the total cost
    cost += min_cost
    # Add the node to the tree as a child of the node with minimum cost
    tree[min_cost % (len(values)+1)].append(len(values)+1)
    # Add the value of the node to the list of values
    values.append(v)
  # Print the total cost
  print(cost)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
 Problem description
 Chef loves circular cakes. He divides them into smaller pieces and sells them. You are to help him in this work.
 Today Chef has cooked the brand new circular cake. To split the cake Chef can make several (possibly, zero) cuts. Each cut should be a straight line going from the center of the cake to its border. Also, the angle between any two cuts should have positive integer value (Chef measure all the angles in degrees). Chef consider two pieces of cake equal if the appropriate angles are equal.
 
 The picture contains two distinct pieces, and two cuts. Red part on the image shows one piece. The appropriate angle is AOB.
 Chef gives to you an integer N, denoting the number of pieces Chef wants to make. You need to answer the following questions:
 
 Is it possible to make exactly N equal pieces from the whole cake?
 Is it possible to make exactly N pieces from the whole cake?
 Is it possible to make exactly N pieces from the whole cake, in such a way that no two of them are equal?
 
 
 Input
 First line contains a single integer T denoting the number of test cases. Each of the following T lines contain a single integer N denoting the number of pieces Chef wants to make.
 Output
 For each test case, output one line containing 3 space separated characters.
 Above, we defined the 3 questions that Chef will ask. Output 'y' for yes or 'n' for no (quotes for clarity) for each of those questions.
 Answers for 3 questions (in the order above) must be space separated on the same line.
 Constraints
 
 1 ≤ T ≤ 10000
 1 ≤ N ≤ 10000
 
 Example
 Input:
 2
 4
 7
 
 Output:
 y y y
 n y y
 
 Explanation
 Example case 1.
 Is it possible to make N equal pieces?
 Yes, you can cut 4 pieces each with 90 degrees angle.
 Is it possible to make N pieces?
 Yes, you can cut 4 pieces each with 90 degrees angle.
 Is it possible to make N pieces, such that no two of them are equal?
 Yes, you can cut 4 pieces with angles 88, 89, 91, 92.",ANUDTC,S10161211,PYTH,"def can_make_equal_pieces(n: int) -> bool:
    return n % 360 == 0

def can_make_pieces(n: int) -> bool:
    return n <= 360

def can_make_unequal_pieces(n: int) -> bool:
    return n != 360

def main():
    t = int(input())
    for _ in range(t):
        n = int(input())
        print(""y"" if can_make_equal_pieces(n) else ""n"", end="" "")
        print(""y"" if can_make_pieces(n) else ""n"", end="" "")
        print(""y"" if can_make_unequal_pieces(n) else ""n"")

main()
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 Chef has a box full of infinite number of identical coins. One day while playing, he made N piles each containing equal number of coins. Chef suddenly remembered an important task and left the room for sometime. While he was away, his newly hired assistant came across the piles and mixed them up while playing.
 When Chef returned home, he was angry to see that all of his piles didn't contain equal number of coins as he very strongly believes in the policy of equality for all, may it be people or piles of coins. 
  In order to calm down the Chef, the assistant proposes to make all the piles equal. Chef agrees to give this task to him, but as a punishment gives him only two type of operations that he can perform.
 
 Pick some coins from any pile and put them back in Chef's coin box.
 Pick some coins from the Chef's coin box and put them on any one pile.
 
 The assistant wants to do this task as fast as possible. So he wants to know the minimum number of operations needed to make all the piles equal.
 Input
 
 The first line of the input contains an integer T denoting the number of test cases.
 The first line of each test case contains a single integer N denoting the number of piles.
 The second line contains N space-separated integers A1, A2, ..., AN denoting the number of coins in each pile.
 
 Output
 
 
 For each test case, output a single line containing an integer corresponding to the minimum number of operations assistant needs to do.
 
 
 Constraints
 
 1 ≤ T ≤ 10
 1 ≤ N ≤ 105
 1 ≤ Ai ≤ 105
 
 Sub tasks
 
 Subtask #1: 1 ≤ N ≤ 1000 (30 points)
 Subtask #2: original constraints (70 points)
 
 Example
 Input:
 1
 4
 1 2 3 4
 
 Output:
 3
 Explanation
 
 In test case 1, if you decide to convert all the piles to contain either of 1, 2, 3, or 4 coins you will have to change the other 3 piles. For any other choice you will have to alter more than 3 (i.e. 4) piles.",CHEFEQ,S11181315,PYTH,"a = int(raw_input())
  result=[]
  for k in range(a):
  input = map(int, raw_input().split(' '))
  
  input_set = set(input)
  input_dict = dict([(i, len(filter(lambda x: (x == i), input))) for i in input_set])
  result.append( sum(sorted(input_dict.values(), reverse=True)[1:]) )
  
  for k in result:
  print k",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
 Problem description
 Rudreshwar likes random numbers and random arrays. Today Rudreshwar started playing with a couple of Arrays A and B, each of size N.
 Initially A is filled with zeros. Rudreshwar filled B with random numbers.
 Rudreshwar visits each index i (1 <= i <= N) in random order. When at i, he selects another random index j such that j is greater or equal to i. He then increments A[i], A[i+1], A[i+2] ... A[j] by 1.
 Finally if for any index i, A[i] is greater than B[i], he then throws away that array A
 For a given B, calculate the number of different arrays A, that Rudreshwar can end up with. Two arrays are called different if there exists an index where the arrays have different values
 Input
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. First line of each test case contains an integer N. Second line contains N space separated integers representing the array B
 Output
 For each test case, output a single line containing the required answer modulo 1000000007.
 Constraints
 
 1 ≤ T ≤ 100
 1 ≤ N ≤ 1000
 1 ≤ B[i] ≤ N
 
 Example
 Input:
 2
 2
 2 2
 3
 1 1 1
 
 Output:
 2
 1
 Explanation
 Test case 1
 {1, 1} and {1, 2} are valid.
 Test case 2
 {1, 1, 1} is the only possible final array A.",ANURRZ,S5936731,PYTH,"# Initialize the list of balls on each pan to empty
pan1 = []
pan2 = []

# Weigh the balls with colour 1 and 2 on both pans
print(""1"")
print(""1 1"")
print(""1 2"")
diff = int(input())

# Check the difference in weights
if diff == 0:
    # Both balls have the same weight, so we need to weigh the remaining balls
    pan1.extend([3, 4, 5])
    pan2.extend([3, 4, 5])
elif diff > 0:
    # Ball on pan1 is heavier, so it is one of the heavier balls
    heavier_colour = 1
elif diff < 0:
    # Ball on pan2 is heavier, so it is one of the heavier balls
    heavier_colour = 2

# Weigh the remaining balls
while pan1:
    print(""1"")
    print(len(pan1), *pan1)
    print(len(pan2), *pan2)
    diff = int(input())

    # Check the difference in weights
    if diff == 0:
        # Both balls have the same weight, so remove them from the list
        pan1.pop(0)
        pan2.pop(0)
    elif diff > 0:
        # Ball on pan1 is heavier, so it is the heavier colour
        heavier_colour = pan1.pop(0)
    elif diff < 0:
        # Ball on pan2 is heavier, so it is the heavier colour
        heavier_colour = pan2.pop(0)

# Output the heavier colour
print(""2"")
print(heavier_colour)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
 Problem description
 As a holiday gift, Tojo received a probability problem. The problem read as follows
 Consider an N by M grid. Rows are numbered 1 to N, from top to bottom. Columns are numbered 1 to M, from left to right. You are initially at cell (1, 1) and want to go to cell (N, M). From any cell you can move to the cell below it or to the cell right to it. You should never go out of the grid. At any point you should consider all the possibilities of movement with equal probability
 Let P[i][j] be the probability of visiting cell (i, j). You need to calculate the sum of P[i][j] for 1 ≤ i ≤ N, 1 ≤ i ≤ M.
 As we all know, Tojo really hates probability related problems. He wants you to solve this task
 Input
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.Only line of each test case has two integer N and M.
 Output
 For each test case, output a single line containing the required answer. Answers within an absolute or relative error of 10-6 will be accepted.
 Constraints
 
 1 ≤ T ≤ 1000
 1 ≤ N ≤ 1000
 1 ≤ M ≤ 1000
 
 Example
 Input:
 2
 2 2
 1 6
 
 Output:
 3.000000
 6.000000
 Explanation
 Example case 1
 Probability matrix P for N=2, M=2 is
 1.0 0.5
 0.5 1.0
 You are at (1, 1) initially. So the probablity of visiting (1, 1) is 1. At (1, 1) you have 2 options, move below to (2, 1) or to right cell (1, 2). Probablity of going to (1, 2) is 0.5. Probability of going to (2, 1) is 0.5. You always end up at (2, 2), so P[2][2] is 1. Required sum = 1.0 + 0.5 + 0.5 + 1.0 = 3.0
 Example case 2
 Probability matrix P for N=1, M=6 is
 1.0 1.0 1.0 1.0 1.0 1.0
 Because at any position there is only one possible next position.",ANUTHM,S10373217,PYTH,"def solve_probability_problem(N, M):
    # Initialize the 2D array P to store the probabilities
    P = [[0] * M for _ in range(N)]

    # Initialize the starting cell
    P[0][0] = 1

    # Iterate over the rows and columns of the grid
    for i in range(N):
        for j in range(M):
            # Calculate the probability of visiting cell (i, j)
            P[i][j] = P[i-1][j] + P[i][j-1]

    # Sum up the values in the array P and return the result
    return sum(P[i][j] for i in range(N) for j in range(M))
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
 
 There are N+1 lights. Lights are placed at (0, 0), (1, 0), (2, 0) ... (N, 0). Initially all the lights are on. You want to turn off all of them one after one. You want to follow a special pattern in turning off the lights.
 
 
 You will start at (0, 0). First, you walk to the right most light that is on, turn it off. Then you walk to the left most light that is on, turn it off. Then again to the right most light that is on and so on. You will stop after turning off all lights. You want to know how much distance you walked in the process. Note that distance between (a,0) and (b,0) is |a-b|.
 
 Input
 The first line of the input contains an integer T denoting the number of test cases. Each test case has a single integer N on separate line.
 
 Output
 For each test case, output the distance you walked.
 Constraints
 
 1 ≤ T ≤ 10^5
 1 ≤ N ≤ 10^5
 
 Example
 Input
 2
 1
 2
 
 Output
 2
 5
 Explanation
 Testcase #2
 You are initially at (0, 0)
 Right most on-light is (2, 0). Distance = 2.
 Now you are at (2, 0).
 Left most on-light is (0, 0). Distance = 2.
 Now you are at (0, 0)
 Right most on-light is (1, 0). Distance = 1.
 Now you are at (1, 0) and all lights are turned off.
 Total distance walked = 5.",ANUWTA,S10512902,PYTH,"def solve_lights_problem(N):
    # Initialize the distance to 0
    distance = 0

    # Initialize the left and right pointers
    left = 0
    right = N

    # Keep alternating between going to the rightmost and leftmost lights
    # until all lights are turned off
    while left <= right:
        # Find the rightmost light that is on
        while right >= left and (right not in (left, right)):
            right -= 1

        # Turn off the rightmost light and add the distance traveled
        distance += right

        # Find the leftmost light that is on
        while left <= right and (left not in (left, right)):
            left += 1

        # Turn off the leftmost light and add the distance traveled
        distance += left

    # Return the total distance traveled
    return distance
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 Chef likes problems related to numbers a lot. He is generally quite good at solving these kinds of problems, but today he got stuck at one number theory problem, and so he asks your help to solve it.
 
 Given a positive integer N, find out how many positive integers X satisfy the equation X + S(X) + S(S(X)) = N, where S(X) denoting sum of digits of X in decimal (base 10) representation.
 
 Input
 
 The only line of the input contains one integer number - N.
 Output
 Output single integer in a line denoting the count of number of positive integers X satisfying the above given equation.
 Constraints
 
 1 ≤ N ≤ 109
 
 Example 1
 Input:
 6
 
 Output:
 1
 Example 2
 Input:
 9939
 
 Output:
 4
 Explanation
 Example 1. Only one positive integer X = 2 satisfies the equation X + S(X) + S(S(X)) = 6, as X + S(X) + S(S(X)) = 2 + 2 + 2 = 6.
 Example 2.X can be 9898, 9907, 9910 and 9913. 
 9898 + S(9898) + S(S(9898)) = 9898 + 34 + 7 = 9939
 9907 + S(9907) + S(S(9907)) = 9907 + 25 + 7 = 9939
 9910 + S(9910) + S(S(9910)) = 9910 + 19 + 10 = 9939
 9913 + S(9913) + S(S(9913)) = 9913 + 22 + 4 = 9939
 You can verify that there is not other positive value of X satisfying the given equation.",CHEFFED,S10900595,PYTH,"number = input()
  possibilities = 0
  
  def s(x):
  _sum = 0;
  while x > 0:
  _sum += x%10
  x = x/10
  
  return _sum
  
  a = min([90, number])
  for i in range(1, a):
  temp = s(i) + i
  if i == (s(number-temp)):
  possibilities += 1
  
  print possibilities",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 You are given an array of N integers a1, a2, ..., aN and an integer K. Find the number of such unordered pairs {i, j} that 
 
 i ≠ j
 |ai + aj - K| is minimal possible
 
 Output the minimal possible value of |ai + aj - K| (where i ≠ j) and the number of such pairs for the given array and the integer K.
 Input
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
 The first line of each test case consists of two space separated integers - N and K respectively.
 The second line contains N single space separated integers - a1, a2, ..., aN respectively.
 
 Output
 For each test case, output a single line containing two single space separated integers - the minimal possible value of |ai + aj - K| and the number of unordered pairs {i, j} for which this minimal difference is reached.
 Constraints
 
 1 ≤ T ≤ 50
 1 ≤ ai, K ≤ 109
 N = 2 - 31 point.
 2 ≤ N ≤ 1000 - 69 points.
 
 
 Example
 Input:
 1 
 4 9
 4 4 2 6
 
 Output:
 1 4
 Explanation:
 The minimal possible absolute difference of 1 can be obtained by taking the pairs of a1 and a2, a1 and a4, a2 and a4, a3 and a4.",APPROX2,S10830836,PYTH,"# Read the input
M = int(input())
B = list(map(int, input().split()))

# Sort the list B in ascending order
B.sort()

# Initialize the list of numbers
numbers = []

# Iterate through the elements of B
for b in B:
    # Check if b is already in numbers or if there are already two other elements x and y in numbers such that b is the average of x and y
    if b not in numbers and not any(abs(b - x - y) < 1e-9 for x in numbers for y in numbers):
        # Add b to the list of numbers
        numbers.append(b)

# Output the length of numbers and the elements of numbers
print(len(numbers))
print(*numbers)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 Everyone knows that ChefLand is the best country in the world and all of its people are the happiest. However, nobody knows their secret of being happy.
 Suraj is an Indian scientist and his goal is to research the life of ChefLandian people. He has already arrived in ChefTown, the capital of ChefLand, and met Chef. He promised to reveal their secret to Suraj if he gets maximal score in a special ChefLandian game. The game has following rules:
 
 In D-dimensional Euclidean space, N lattice points are given. Every pair of points are not connected initially. The points are not guaranteed to be distinct.
 
 Let (A1, A2, ..., AD) and (B1, B2, ..., BD) be the coordinates of the points A and B respectively, then the distance between A and B is defined as ( (A1−B1)2 + (A2−B2)2 + ... + (AD−BD)2 )1/2.
 
 The initial Suraj's score is 1.
 
 Suraj is allowed to take as many turns as he wants.
 
 In every turn, Suraj can connect an unconnected pair of two given points, if this new connection does not form a cycle. That is, Suraj cannot connect the pair of points A and B, if there exist points X1, X2, ..., Xk such that A connected to X1, X1 connected to X2, X2 connected to X3,..., and Xk connected to B.
 
 In every time Suraj connects some points, his score is multiplied by the square of the distance between them.
 
 
 Now Suraj wonders what is the maximal score he can get. Write a program that will find this score. Since this number can be huge you should output it modulo 747474747.
 Input
 The first line of input contains T, denoting the number of test cases. Then T test cases follow.
 The first line of each test case contains two space-separated-integers N and D. The next N lines contain D space-separated integers, denoting the coordinates of the given lattice points.
 Output
 For each test case, output the maximal score modulo 747474747.
 Constrains
 
 1 ≤ T ≤ 6666
 1 ≤ N ≤ 6666
 1 ≤ D ≤ 5
 The absolute value of any integer given in the input does not exceed 100000000 (108).
 The sum of N in one input file does not exceed 6666.
 
 Example
 
 Input:
 1
 3 2
 0 0
 -1 -1
 1 -1
 
 Output:
 8
 Explanation
 The distance between the first point and the second point is ((0−(−1))2+(0−(−1))2)1/2 = 21/2.The distance between the first point and the third point is ((0−1)2+(0−(−1))2)1/2 = 21/2.The distance between the second point and the third point is (((−1)−1)2+((−1)−(−1))2)1/2 = 2.
 One of the optimal ways is that Suraj connects the third and the second points, and then connects the first and the second points. The maximum score is 22 * (21/2)2 = 8.",CHEFGAME,S2054511,PYTH,"__author__ = 'robert'
  
  
  def distance(p1, p2):
  return -sum([(a - b)**2 for a, b in zip(p1, p2)])
  
  def index_iter(x, ranked):
  for xx, ii in ranked:
  if xx >= x:
  break
  yield ii
  
  def back_index_iter(x, ranked):
  for xx, ii in reversed(ranked):
  if xx <= x:
  break
  yield ii
  
  
  def yielder(i, points, sp):
  x = points[i]
  dim = len(x)
  while True:
  iters = []
  for j in range(dim):
  iters.append(index_iter(x[j], sp[j]))
  iters.append(back_index_iter(x[j], sp[j]))
  indicies = []
  for j, it in enumerate(iters):
  cc = 0
  for ni in it:
  indicies.append((ni, j))
  cc += 1
  if cc > 5:
  break
  best_spot = {}
  worst_spot = {}
  distances = {}
  for ii, j in indicies:
  d = distances.get(ii, None) or distance(x, points[ii])
  distances[ii] = d
  best_spot[j] = min(best_spot.get(j, 99999), d)
  worst_spot[j] = max(worst_spot.get(j, -99999999), d)
  best_j = min(best_spot, key=best_spot.get)
  while worst_spot[best_j] == best_spot[best_j]:
  try:
  ii = next(iters[best_j])
  except StopIteration:
  break
  d = distance(x, points[ii])
  distances[ii] = d
  worst_spot[best_j] = d
  
  result = []
  for ii, d in distances.iteritems():
  result.append((d, ii))
  result.sort()
  for d, ii in result:
  yield ii, d
  else:
  break
  
  def get_graph(points, N):
  dimension_points = zip(*points)
  point_places = [[(x, i) for i, x in enumerate(xs)] for xs in dimension_points]
  sp = map(sorted, point_places)
  
  G = [[] for i in range(N)]
  for i in range(N):
  G[i] = yielder(i, points, sp)
  return G
  
  
  def solve(G, N, heappush, heappop):
  score = 1
  u = 0
  frontier = []
  visited = set([u])
  v, d = next(G[u])
  heappush(frontier, (d, u, v))
  extras = []
  while frontier:
  while extras:
  if extras[0][0] > frontier[0][0]:
  break
  d2, v, g = heappop(extras)
  tc = 0
  for w, d2 in g:
  if not w in visited:
  tc += 1
  heappush(frontier, (d2, v, w))
  if tc > 10:
  heappush(extras, (d2, v, g))
  break
  W, u, v = heappop(frontier)
  if v in visited:
  continue
  visited.add(v)
  taken_count = 0
  for w, d2 in G[v]:
  if not w in visited:
  taken_count += 1
  heappush(frontier, (d2, v, w))
  if taken_count > 10:
  heappush(extras, (d2, v, G[v]))
  score *= W
  return score % 747474747
  
  
  def main():
  from sys import stdin
  from heapq import heappush, heappop
  data = (line for line in stdin.read().splitlines())
  cases = int(next(data))
  for case in range(1, cases + 1):
  N, D = map(int, next(data).split())
  points = [map(int, next(data).split()) for i in range(N)]
  G = get_graph(points, N)
  ans = solve(G, N, heappush, heappop)
  print ans
  
  main()",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 Chef Ciel is playing a game with one of her colleagues.
  In this game, there are k piles of numbers. There are ni numbers in ith pile. In each move, player has to select a pile and finally a number from that pile. After that, all the numbers which are greater than or equal to chosen number will be removed from that pile. Players take turn alternatively. Player who is unable to move loses the game. 
 Chef Ciel always make first move. But before making her move, she must choose either EVEN or ODD. If she chooses even then each time she selects a number it must be even and her opponent must select odd number in his/her turn. And vice versa for the other case. 
 Please help Chef Ciel to make her choice. If neither choice can make her win game, print DON'T PLAY otherwise EVEN or ODD depending on which choice she should make to win game. If you think then you will understand BOTH can not be answer.
 Assume that both players play intelligently, if they can force win they will. 
  Input : First line of test case contains t, number of test cases. Then t test cases follow. First line of each test case contains k, number of piles. Then description of k piles follow. ith pile description contains number ni, then ni numbers follow in the same line.
 Output : Print ""EVEN"", ""ODD"" or ""DON'T PLAY"" accordingly.
 Constraints : t <= 1000, k <=100, ni <= 45. Numbers in pile will be non-negative and less than 2^31.
 Sample Input :
 2
 2 
 2 3 4
 2 4 5
 1
 3 1 2 3
 Sample Output :
 DON'T PLAYODD
 Explanation: 
 In the first test case, if you have chosen ODD to play with, it means you will select only ODD numbers and your opponent may choose only EVEN numbers. So you have two options. Either select 3 from first pile or 5 from second pile. If 3 is selected, 3 and 4 are removed from first pile and in next move your opponent's only move will be 4 from second pile removing every numbers thus you lose. If you had selected 5, then your opponent's optimal move would be selecting 4 from first pile. Next you will select 3 and your opponent 4 leaving nothing for you. So if you choose ODD you will lose. Similarly if you choose EVEN you will lose as well. So the answer is DON'T Play.
 In the second case, if you choose ODD just select 1 and you will win. If you choose EVEN you have only one move that is 2, and in response your opponent will choose 1 and leave you nothing. Thus answer is ODD.",CHEFGM,S2980171,PYTH,"from __future__ import division
  from sys import stdin
  from cStringIO import StringIO
  inp = iter(StringIO(stdin.read())).next
  
  t = int(inp())
  
  def tell(l):
  ans = 1
  odd = l[0]%2
  for i in xrange(len(l)):
  if l[i]%2 == odd:
  ans+=1
  else:
  if odd == 1:
  return -1*ans
  else:
  return ans
  
  return ans
  
  for _ in xrange(t):
  n = int(inp())
  game_value=0
  for i in xrange(n):
  l = map(int, inp().split())[1:]
  l.sort()
  value = tell(l)
  count=0
  ini=value
  for j in xrange(ini, len(l)):
  if l[j]%2:
  value -= 1/(2<<count)
  else:
  value += 1/(2<<count)
  game_value+=value
  if game_value > 0:
  print ""EVEN""
  elif game_value < 0:
  print ""ODD""
  else:
  print ""DON'T PLAY""",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 
 The Chef has prepared the appetizers in the shapes of letters to spell a special message for the guests. There are n appetizers numbered from 0 to n-1 such that if the appetizers are arrayed in this order, they will display the message. The Chef plans to display them in this order on a table that can be viewed by all guests as they enter. The appetizers will only be served once all guests are seated.
 
 The appetizers are not necessarily finished in the same order as they are numbered. So, when an appetizer is finished the Chef will write the number on a piece of paper and place it beside the appetizer on a counter between the kitchen and the restaurant. A server will retrieve this appetizer and place it in the proper location according to the number written beside it.
 
 The Chef has a penchant for binary numbers. The number of appetizers created is a power of 2, say n = 2k. Furthermore, he has written the number of the appetizer in binary with exactly k bits. That is, binary numbers with fewer than k bits are padded on the left with zeros so they are written with exactly k bits.
 
 Unfortunately, this has unforseen complications. A binary number still ""looks"" binary when it is written upside down. For example, the binary number ""0101"" looks like ""1010"" when read upside down and the binary number ""110"" looks like ""011"" (the Chef uses simple vertical lines to denote a 1 bit). The Chef didn't realize that the servers would read the numbers upside down so he doesn't rotate the paper when he places it on the counter. Thus, when the server picks up an appetizer they place it the location indexed by the binary number when it is read upside down.
 
 You are given the message the chef intended to display and you are to display the message that will be displayed after the servers move all appetizers to their locations based on the binary numbers they read.
 Input
 
 The first line consists of a single integer T ≤ 25 indicating the number of test cases to follow. Each test case consists of a single line beginning with an integer 1 ≤ k ≤ 16 followed by a string of precisely 2k characters. The integer and the string are separated by a single space. The string has no spaces and is composed only of lower case letters from `a` to `z`.
 Output
 
 For each test case you are to output the scrambled message on a single line.
 Example
 
 Input:
 2
 2 chef
 4 enjoyourapplepie
 
 Output:
 cehf
 eayejpuinpopolre",ARRANGE,S10017776,PYTH,"# Read the number of test cases
t = int(input())

# Define a function to check if a number is a prime power
def is_prime_power(n):
    # Check if n is a prime number
    if n in (2, 3):
        return True
    if n == 1 or n % 2 == 0:
        return False
    for i in range(3, int(n ** 0.5) + 1, 2):
        if n % i == 0:
            return False

    # If n is prime, check if it is a power of 2 or 3
    if n % 2 == 1:
        return False
    while n % 2 == 0:
        n //= 2
    return n == 1 or n == 3

# Process each test case
for _ in range(t):
    # Read the input for this test case
    n = int(input())

    # If n is a prime power, Chef will win
    if is_prime_power(n):
        print(""Chef"")
    # Otherwise, Misha will win
    else:
        print(""Misha"")
",×,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 
 Given n numbers, you can perform the following operation any number of times : Choose any subset of the numbers (possibly empty), none of which are 0. Decrement the numbers in the subset by 1, and increment the numbers not in the subset by K.
 
 
 Is it possible to perform operations such that exactly n - 1 numbers become 0 ?
 
 
 Input :
 
 
 The first line contains the number of test cases T. 2*T lines follow, 2 for each case. The first line of a test case contains the numbers n and K. The next line contains n numbers, a_1...a_n.
 
 
 Output :
 
 
 Output T lines, one corresponding to each test case. For a test case, output ""YES"" if there is a sequence of operations as described, and ""NO"" otherwise.
 
 
 Sample Input :
 3
 2 1
 10 10
 3 2
 1 2 2
 3 2
 1 2 3
 
 
 Sample Output :
 YES
 YES
 NO
 
 
 Constraints :
 1 <= T <= 1000
 2 <= n <= 100
 1 <= K <= 10
 0 <= a_i <= 1000",ARRAYTRM,S11192882,PYTH,"# Read the number of test cases
t = int(input())

# Process each test case
for _ in range(t):
    # Read the input for this test case
    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    # Check if it is possible to perform operations such that exactly n - 1 numbers become 0
    if all(a[i] % (k+1) == 0 for i in range(n)):
        print(""YES"")
    else:
        print(""NO"")
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese here
 Problem Statement
 Little Chef doesn't love math anymore. He loves Aleksandra.
 
 
 Sashen'ka is nice. They spend all the time together. Even their birthdays they are celebrating together, because they were born on the same day :)
 
 
 And now, this day is coming...
 
 
 Chef know that most of all Sasha loves numbers, that's why he bought N positive numbers to a girl.
 From her side, Sasha as all girls, thought that if she likes something, then all people like that too. And bought to a boy N numbers too. xD
 After all greeting young people decide to play a game with their gifts. The game will be continued for N turns, in each turn the following will be done:
 Chef randomly choose some number x from his gift.
 Sasha randomly choose some number y form her gift.
 If xy > yx then girl will kiss fellow.
 Numbers x,y will be discarded from gifts.
 Now chef is wondering what is the expected number of times he will be kissed by Sasha ?
 
 
 Input
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
 The first line of each test case contains a single integer N denoting the number of numbers in each gift. The second line contains N space-separated integers A1, A2, ..., AN denoting the numbers Sasha gave to Chef. Next line describe B1, B2, ..., BN numbers boy gave to girl in the same way. 
 
 Output
 For each test case, output a single line containing answer for corresponding test. Your answer will be considered as correct if it will have absolute error not more then 10-6.
 
 Constraints
 1 ≤ T ≤ 5
 1 ≤ N ≤ 105
 1 ≤ Ai ≤ 109
 1 ≤ Bi ≤ 109
 
 Example
 
 Input
 3
 1
 3
 4
 2
 2 3
 1 4
 2
 2 4
 2 2
 
 Output:
 1.000000
 1.500000
 0.000000
 
 
 
 Explanation
 Example case 1. Game will have only 1 turn. Chef will choose 3, while Sasha will choose 4. Since 34>43 girl will kiss boy. Hence answer is 1.",ARRGAME2,S10060126,PYTH,"# Read the number of test cases
T = int(input())

# Iterate through each test case
for _ in range(T):
  # Read the number of numbers in each gift
  N = int(input())

  # Read the numbers given by Sasha to Chef
  A = list(map(int, input().split()))

  # Read the numbers given by Chef to Sasha
  B = list(map(int, input().split()))

  # Sort the numbers in ascending order
  A.sort()
  B.sort()

  # Initialize the expected number of kisses to 0
  kisses = 0

  # Iterate through the numbers in Chef's gift
  for a in A:
    # Find the number of numbers in Sasha's gift that are greater than a
    greater_than_a = len([b for b in B if b > a])

    # Add the probability of kissing Chef to the expected number of kisses
    kisses += greater_than_a / len(B)

  # Print the expected number of kisses
  print(kisses)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 Suraj, the Chief Prankster is back in action now and this time he has stolen the valentine's day gift given by Ashi (the love of Chef) to the Chef and ran away with it to Byteland.
 Byteland is a not a regular place like Chef's town. The safest way from Chef's town to Byteland is through the path of tasty dishes. The path is named so because there are magical tasty dishes which appear to the traveler that no one can resist eating. Also, Suraj has added a strong sleep potion to each of the dish on this path to stop anyone from following him.
 Knowing the devilish nature of Suraj, Ashi is concerned about the Chef and has asked all of Chef's town people to help. The distance from Chef's town to Byteland through the the path of tasty dishes is X units. They have the location where the magic dishes are and how many people are required to eat it completely. Anyone who eats a dish would go to a long sleep and won't be able to continue. They have the information about the tribal clans that live along the the path of tasty dishes who can be of real help in this journey. 
 The journey Chef and his friends can be described as follows: There is a total of B dishes on the path of tasty dishes. Each dish is located at some distance from Chef's town denoted by xi for the ith dish ( xi-1 < xi). To minimize the number of friends Chef has to leave behind, all of them have decided that exactly yi of them will eat the ith dish, which is the required number of people needed to finish it completely. Also, there are a total of C tribal chef clans, each with their own population and location on the path that Chef and his friends will meet on their way to Byteland. They know that for some clan (say i), they are located at a distance of pi ( pi-1 < pi) from Chef's town with a population of ri. And if a group of at least qi men approaches them, they would be able to convince them to join their forces against Suraj.
 Given the information about all this, help the Chef to find out the minimum size of the group (including him and his friends) he should start with to reach Byteland and get back Ashi's gift from Suraj.
 Input
 The first line of the input contains an integer T denoting the number of test cases. Each test case contains three lines which are as follows:
 First line of each test case contains X, the distance of Byteland from Chef's town.
 Next line contains an integer B, the number of dishes on the path of tasty dishes. Then follows B pairs of space separated integers of the form xi yi, where xi yi are as defined above for the ith dish.
 Next line contains an integer C, followed C space separated triplets of integers pi qi ri as defined above.
 Output
 For each test case, print the minimum size of the group (including Chef) that is needed to reach Byteland.
 Constraints
 
 1 ≤ T ≤ 10
 1 ≤ X ≤ 109
 1 ≤ B ≤ 10000
  Constraints on C
 
 Subproblem 1 (25 points): C = 0
 Subproblem 2 (75 points): 1 ≤ C ≤ 10000
 
 
 1 ≤ xi < X, xi < xi+1
 1 ≤ pi < X, pi < pi+1
 1 ≤ yi ≤ 1014
 1 ≤ qi ≤ 1014
 1 ≤ ri ≤ 1014
 All the positions, of the tasty dishes and tribal clans are distinct.
 
 Example
 Input:
 3
 10
 2 1 3 8 1
 0
 10
 2 1 3 8 5
 0
 10
 2 2 3 8 5
 3 1 2 1 4 3 2 9 1 1 
 
 Output:
 5
 9
 6
 
 Explanation
 Example case 1. In the first case, there are no tribal clans, and two dishes, one which needs to be eaten by 3 chefs on their way and one to be eaten by 1 chef. Hence, we have to start with atleast 5 people in total to pass the path of tasty dishes.
 Example case 2. Similar as Example Case 1.
 Example case 3. In this case, if we start with 5 Chefs. At point 1, we have more than or equal to 2 chefs, hence the tribal clan of size 1 adds to the Chef's party and now they have size of 6. At position 2, three of them would be left behind eating a dish, leaving 3 of them to go ahead. At position 4, since the size is exactly 3, the tribal clan joins the chef's party making it of size 5. At position 8, all 5 of them will stop to eat the dish and none would go ahead. Similarly, if we start with 6, one of them would be able to pass position 8 and reach position 9, where it will also add one of the tribal clans to its party and reach Byteland.",ASHIGIFT,S6595612,PYTH,"# Read the number of test cases
t = int(input())

# Process each test case
for _ in range(t):
    # Read the input for this test case
    x = int(input())
    b = int(input())
    dishes = []
    for _ in range(b):
        dishes.append(tuple(map(int, input().split())))
    c = int(input())
    clans = []
    for _ in range(c):
        clans.append(tuple(map(int, input().split())))

    # Sort the dishes and clans by their distance from Chef's town
    dishes = sorted(dishes, key=lambda x: x[0])
    clans = sorted(clans, key=lambda x: x[0])

    # Initialize the current size of the group to 1 (for Chef)
    size = 1

    # Keep track of the current position in the list of dishes and clans
    dish_index = 0
    clan_index = 0

    # Keep track of the number of chefs left at each position
    left = 0

    # Process each position on the path
    for pos in range(1, x):
        # If we have reached a dish, eat it and update the number of chefs left
        if dish_index < b and dishes[dish_index][0] == pos:
            size -= left
            left = dishes[dish_index][1]
            dish_index += 1
        # If we have reached a clan, join it if we have enough chefs
        elif clan_index < c and clans[clan_index][0] == pos:
            size = max(size, clans[clan_index][1])
            clan_index += 1
        # Otherwise, update the number of chefs left
        else:
            size -= left
            left = 0

    # Print the final size of the group
    print(size)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 Teddy and Tracy like to play a game based on strings. The game is as follows. Initially, Tracy writes a long random string on a whiteboard. Then, each player starting with Teddy makes turn alternately. Each turn, the player must erase a contiguous substring that exists in the dictionary. The dictionary consists of N words.
 Of course, the player that can't erase any substring in his turn loses the game, and the other player is declared the winner.
 Note that after a substring R is erased, the remaining substring becomes separated, i.e. they cannot erase a word that occurs partially to the left of R and partially to the right of R.
 Determine the winner of the game, assuming that both players play optimally.
 Input
 The first line contains a single integer T, the number of test cases. T test cases follow. The first line of each testcase contains a string S, the string Tracy writes on the whiteboard. The next line contains a single integer N. N lines follow. The i-th line contains a single string wi, the i-th word in the dictionary.
 Output
 For each test case, output a single line containing the name of the winner of the game.
 Example
 
 Input:
 3
 codechef
 2
 code
 chef
 foo
 1
 bar
 mississippi
 4
 ssissi
 mippi
 mi
 ppi
 
 Output:
 Tracy
 Tracy
 Teddy
 Constraints
 
 1 <= T <= 5
 1 <= N <= 30
 1 <= |S| <= 30
 1 <= |wi| <= 30
 S and wi contain only characters 'a'-'z'",ASTRGAME,S10867784,PYTH,"# Read the number of test cases
t = int(input())

# Process each test case
for _ in range(t):
    # Read the input for this test case
    s = input()
    n = int(input())
    words = set()
    for _ in range(n):
        words.add(input())

    # Check if Teddy can win by checking if there is a word in the dictionary that is a substring of the string on the whiteboard
    if any(word in s for word in words):
        print(""Teddy"")
    else:
        print(""Tracy"")
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese , Russian and Vietnamese as well.
 Akhil comes across a string S of length N. He started wondering about the smallest lexicographical subsequence of string S of length K.
 A subsequence of a string is formed by deleting some characters (possibly none) from it's original string.
 A string A is said to be lexicographically smaller than the string B of the same length if at the first position where A and B differ, A contains a letter which appears earlier in the dictionary than the corresponding letter in B.
 Input
 
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows:
 First line of each test case will contain string S
 Second line of each test case will contain an integer K.
 
 Output
 
 For each test case, output a single line containing the lexicographically smallest subsequence of S of length K.
 
 Constraints
 
 1 ≤ T ≤ 5
 1 ≤ K ≤ N
 S consists of lowercase English alphabet characters, i.e. from 'a' to 'z'.
 
 Subtasks
 Subtask #1 (10 points) : 1 ≤ |S| ≤ 100
 Subtask #2 (20 points) : 1 ≤ |S| ≤ 103
 Subtask #3 (70 points) : 1 ≤ |S| ≤ 105
 Example
 Input:
 2
 abdc
 3
 bacb
 2
 
 Output:
 abc
 ab
 Explanation
 Example case 1. ""abc"" is the smallest lexicographical subsequence out of [""abd"", ""bdc"", ""abc"", ""adc""].
 Example case 2. ""ab"" is the smallest lexicographical subsequence of length 2.",ASTRING,S10211218,PYTH,"def smallest_subsequence(S, K):
  res = ''
  for c in S:
    if len(res) == K:
      break
    if c not in res:
      # Add c to res if it is lexicographically smaller than the remaining characters
      if not any(c < d for d in S[S.index(c)+1:]):
        res += c
  return res

# Test the function
T = 2
test_cases = [('abdc', 3), ('bacb', 2)]
for i in range(T):
  S, K = test_cases[i]
  print(smallest_subsequence(S, K))
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 
 Let X be the set of all integers between 0 and n-1. Suppose we have a collection S1, S2, ..., Sm of subsets of X. Say an atom A is a subset of X such that for each Si we have either A is a subset of Si or A and Si do not have any common elements.
 
 Your task is to find a collection A1, ..., Ak of atoms such that every item in X is in some Ai and no two Ai, Aj with i ≠ j share a common item. Surely such a collection exists as we could create a single set {x} for each x in X. A more interesting question is to minimize k, the number of atoms.
 Input
 
 The first line contains a single positive integer t ≤ 30 indicating the number of test cases. Each test case begins with two integers n,m where n is the size of X and m is the number of sets Si. Then m lines follow where the i'th such line begins with an integer vi between 1 and n (inclusive) indicating the size of Si. Following this are vi distinct integers between 0 and n-1 that describe the contents of Si.
 
 You are guaranteed that 1 ≤ n ≤ 100 and 1 ≤ m ≤
 30. Furthermore, each number between 0 and n-1 will appear in at least one set Si.
 Output
 
 For each test case you are to output a single integer indicating the minimum number of atoms that X can be partitioned into to satisfy the constraints.
 Example
 
 Input:
 2
 5 2
 3 0 1 2
 3 2 3 4
 4 3
 2 0 1
 2 1 2
 2 2 3
 
 Output:
 3
 4",ATOMS,S11246680,PYTH,"# Test input cases
tests = [
    {
        ""input"": ""2\n5 2\n3 0 1 2\n3 2 3 4\n4 3\n2 0 1\n2 1 2\n2 2 3\n"", 
        ""output"": ""3\n4\n""
    }, 
    # add more test cases here
]

# Test function
def test(function = None):
    for test in tests:
        is_test_passing = function(test['input']) == test['output']
        result = (
            ""PASS""
            if is_test_passing
            else f""FAIL ({function(test['input'])})""
        )
        print(f""Input:\n{test['input']}Output:\n{test['output']}Result: {result}\n"")

# Test-driven development function
def tdd(function):
    def wrapper(*args, **kwargs):
        test(function)
        return function(*args, **kwargs)
    return wrapper

# Solution function
@tdd
def find_min_atoms(test_input):
    # Split the input string into lines
    lines = test_input.strip().split(""\n"")
    
    # Parse the first line to get the number of test cases
    t = int(lines[0])
    
    # Initialize an empty list to store the results
    results = []
    
    # Initialize a line index
    i = 1
    
    # Iterate over the test cases
    for _ in range(t):
        # Parse the current line to get the size of X and the number of sets
        n, m = map(int, lines[i].split())
        i += 1
        
        # Initialize a set to store all the items in X
        all_items = set(range(n))
        
        # Initialize a set to store the items that have already been covered
        covered_items = set()
        
        # Iterate over the sets
        for _ in range(m):
            # Parse the current line to get the size of the current set
            v = int(lines[i])
            i += 1
            
            # Parse the current line to get the items in the current set
            items = set(map(int, lines[i].split()))
            i += 1
            
            # Update the set of covered items
            covered_items |= items
        
        # Calculate the number of atoms needed
        atoms = len(all_items - covered_items)
        
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 
 Digory Kirke and Polly Plummer are two kids living next door to each other. The attics of the two houses are connected to each other through a passage. Digory's Uncle Andrew has been secretly doing strange things in the attic of his house, and he always ensures that the room is locked. Being curious, Digory suspects that there is another route into the attic through Polly's house, and being curious as kids always are, they wish to find out what it is that Uncle Andrew is secretly up to.
 
 
 So they start from Polly's house, and walk along the passageway to Digory's. Unfortunately, along the way, they suddenly find that some of the floorboards are missing, and that taking a step forward would have them plummet to their deaths below.
 
 
 Dejected, but determined, they return to Polly's house, and decide to practice long-jumping in the yard before they re-attempt the crossing of the passage. It takes them exactly one day to master long-jumping a certain length. Also, once they have mastered jumping a particular length L, they are able to jump any amount less than equal to L as well.
 
 
 The next day they return to their mission, but somehow find that there is another place further up the passage, that requires them to jump even more than they had practiced for. So they go back and repeat the process.
 
 
 Note the following:
 
  At each point, they are able to sense only how much they need to jump at that point, and have no idea of the further reaches of the passage till they reach there. That is, they are able to only see how far ahead is the next floorboard. 
  The amount they choose to practice for their jump is exactly the amount they need to get across that particular part of the passage. That is, if they can currently jump upto a length L0, and they require to jump a length L1(> L0) at that point, they will practice jumping length L1 that day. 
  They start by being able to ""jump"" a length of 1. 
 
 
 Find how many days it will take them to cross the passageway. In the input, the passageway is described as a string P of '#'s and '.'s. A '#' represents a floorboard, while a '.' represents the absence of a floorboard. The string, when read from left to right, describes the passage from Polly's house to Digory's, and not vice-versa.
 
 Input
 
 The first line consists of a single integer T, the number of testcases.
 Each of the next T lines consist of the string P for that case.
 
 Output
 
 For each case, output the number of days it takes them to cross the passage.
 
 Constraints
 
  1 ≤ T ≤ 1,000,000 (106)
  1 ≤ |P| ≤ 1,000,000 (106)
  The total length of P will be ≤ 5,000,000 (5 * 106)across all test-cases of a test-file 
  P will consist of only the characters # and . 
  The first and the last characters of P will be #. 
 
 Example
 
 Input:
 4
 ####
 ##.#..#
 ##..#.#
 ##.#....#
 
 Output:
 0
 2
 1
 2
 Explanation
 
 For the first example, they do not need to learn any jump size. They are able to cross the entire passage by ""jumping"" lengths 1-1-1.
 
 
 For the second example case, they get stuck at the first '.', and take one day learning to jump length 2. When they come back the next day, they get stuck at '..' and take one day to learn to jump length 3.
 
 
 For the third example case, they get stuck first at '..', and they take one day to learn to jump length 3. On the second day, they are able to jump both length 3 as well as length 2 required to cross the passage.
 
 
 For the last test case they need to stop and learn jumping two times. At first they need to jump a length 2 and then a length 5.
 
 Appendix
 
 Irrelevant to the problem description, if you're curious about what Uncle Andrew was up to, he was experimenting on Magic Rings that could facilitate travel between worlds. One such world, as some of you might have heard of, was Narnia.",ATTIC,S12059418,PYTH,"def main():
  # Read the number of test cases
  t = int(input())

  # Process each test case
  for _ in range(t):
    # Read the passage
    passage = input()

    # Initialize the number of days needed to 0
    days = 0

    # Initialize the maximum jump length to 1
    max_jump = 1

    # Iterate through the passage
    for i in range(1, len(passage)):
      # If the current position is not a floorboard
      if passage[i] == '.':
        # Update the maximum jump length to the distance to the next floorboard
        max_jump = i - days

      # If the current jump length is smaller than the distance to the next floorboard
      if max_jump < i - days:
        # Increment the number of days needed
        days += 1

    # Print the number of days needed
    print(days)

# Call the main function
main()
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 There are a lot of problems related to the shortest paths. Nevertheless, there are not much problems, related to the shortest paths in average.
 Consider a directed graph G, consisting of N nodes and M edges. Consider a walk from the node A to the node B in this graph. The average length of this walk will be total sum of weight of its' edges divided by number of edges. Every edge counts as many times as it appears in this path.
 Now, your problem is quite simple. For the given graph and two given nodes, find out the shortest average length of the walk between these nodes. Please note, that the length of the walk need not to be finite, but average walk length will be.
 Input
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
 The first line of each test case contains a pair of space-separated integers N and M denoting the number of nodes and the number of edges in the graph.
 Each of the following M lines contains a triple of space-separated integers Xi Yi Zi, denoting the arc, connecting the node Xi to the node Yi (but not vice-versa!) having the weight of Zi.
 The next line contains a pair of space separated integers A and B, denoting the first and the last node of the path.
 Output
 For each test case, output a single line containing the length of the shortest path in average.
 If there is no path at all, output just -1 on the corresponding line of the output.
 Constraints
 
 1 ≤ N ≤ 500
 1 ≤ M ≤ 1000
 A is not equal to B
 1 ≤ A, B, Xi, Yi ≤ N
 1 ≤ Zi ≤ 100
 There are no self-loops and multiple edges in the graph.
 1 ≤ sum of N over all test cases ≤ 10000
 1 ≤ sum of M over all test cases ≤ 20000
 
 Subtasks
 
 Subtask #1 (45 points): 1 ≤ N ≤ 10, 1 ≤ M ≤ 20; Your answer will be considered correct in case it has an absolute or relative error of no more than 10-2.
 Subtask #2 (55 points): no additional constraints; Your answer will be considered correct in case it has an absolute or relative error of no more than 10-6.
 
 Example
 Input:
 2
 3 3
 1 2 1
 2 3 2
 3 2 3
 1 3
 3 3
 1 2 10
 2 3 1
 3 2 1
 1 3
 
 Output:
 1.5
 1.0
 
 Explanation
 Example case 1. The walk 1 -> 2 and 2 -> 3 has average length of 3/2 = 1.5. Any other walks in the graph will have more or equal average length than this.",AVGSHORT,S11276488,PYTH,"import heapq

def shortest_average_length(n, m, edges, source, destination):
  # Initialize the distance array
  dist = [float('inf')] * n
  dist[source] = 0

  # Initialize the priority queue
  pq = []
  heapq.heappush(pq, (0, source))

  while pq:
    # Extract the node with the minimum distance
    (length, node) = heapq.heappop(pq)

    # Check if the node has already been processed
    if length > dist[node]:
      continue

    # Update the distances of the neighbors
    for (neighbor, weight) in edges[node]:
      average_length = (length * (node - source) + weight) / (node - source + 1)
      if average_length < dist[neighbor]:
        dist[neighbor]
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 This problem was part of the CodeChef April Challenge. All user submissions for this contest problem are publicly available here.
 Bugs have gotten into The Chef’s kitchen! Help him trap them all and he’ll make you a batch of his famous chocolate chip cookies. You are given a given a square map of the kitchen divided into tiles, and in each tile sits some known number of bugs. You also have a square trap, which can be dropped to cover a certain number of tiles (the trap may only cover tiles from within the map, and must be aligned to the borders of the kitchen). However, the trap only catches bugs from one of the tiles which it has covered, having a minimum number of bugs on it. For all possible positions at which the trap can be dropped, determine number of bugs that will be caught.
 Input
 Two numbers, 0< n <= 1000 (size of the map), and 0< k <= n (size of the trap), followed by n rows with n numbers, determining the number of bugs on each tile. The number of bugs on each tile will fit in an signed 32-bit integer.
 Output
 You should output n-k+1 rows with n-k+1 numbers in each row. 
 Example
 
 Input:
 4 2
 0 1 2 3
 4 5 6 7
 8 9 0 1
 2 3 4 0
 
 Output:
 0 1 2
 4 0 0
 2 0 0",B5,S388515,PYTH,"# Test input
input_str = """"""
4 2
0 1 2 3
4 5 6 7
8 9 0 1
2 3 4 0
""""""

# Test output
output_str = """"""
0 1 2
4 0 0
2 0 0
""""""

def trap_bugs(n, k, map):
    # Initialize the result with zeros
    result = [[0 for _ in range(n - k + 1)] for _ in range(n - k + 1)]

    # Iterate over all the possible positions for the trap
    for i in range(n - k + 1):
        for j in range(n - k + 1):
            # Get the minimum number of bugs on the tiles covered by the trap
            result[i][j] = min([map[i + x][j + y] for x in range(k) for y in range(k)])

    return result
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin and Russian. Translations in Vietnamese to be uploaded soon.
 Two cheeky thieves (Chef being one of them, the more talented one of course) have came across each other in the underground vault of the State Bank of Churuland. They are shocked! Indeed, neither expect to meet a colleague in such a place with the same intentions to carry away all the money collected during Churufest 2015.
 
 
 They have carefully counted a total of exactly 1 billion (109) dollars in the bank vault. Now they must decide how to divide the booty. But there is one problem: the thieves have only M minutes to leave the bank before the police arrives. Also, the more time they spend in the vault, the less amount could carry away from the bank. Formally speaking, they can get away with all of the billion dollars right now, but after t minutes they can carry away only 1 billion * pt dollars, where p is some non-negative constant less than or equal to unity, and at t = M, they get arrested and lose all the money.
 They will not leave the vault until a decision on how to divide the money has been made.
 
 The money division process proceeds in the following way: at the beginning of each minute starting from the 1st (that is, t = 0), one of them proposes his own way to divide the booty. If his colleague agrees, they leave the bank with pockets filled with the proposed amounts of dollars. If not, the other one proposes his way at the next minute etc. To escape arrest, they can only propose plans till the beginning of the Mth minute (i.e., till t = M-1).
 Each thief wants to maximize his earnings, but if there are two plans with the same amounts for him, he would choose the one which leads to a larger total amount of stolen dollars.
 
 Chef is about to start this procedure, and he is the first to propose a plan. You are wondering what will be the final division of money, if each thief chooses the optimal way for himself and money is considering real.
 Input
 The first line of input contains an integer T denoting the number of test cases. The description of T test cases follows. The only line of input for each test case contains an integer M denoting the number of minutes until arrest and a double denoting the constant p.
 Output
 For each test case, output a single line containing two space-separated doubles denoting the amount of dollars each thief will get in the optimal division. First number: dollars amassed by Chef, and second: by his colleague. The answer will be considered correct if its absolute error doesn't exceed 10-2.
 Constraints and subtasks
 
 1 ≤ T ≤ 105
 0 ≤ p ≤ 1 
 
 Subtask 1 (15 points) :
 1 ≤ M ≤ 3
 
 Subtask 2 (55 points) :
 1 ≤ M ≤ 103
 
 Subtask 3 (30 points) :
 1 ≤ M ≤ 109
 Example
 Input:
 2
 1 0.5
 2 0.5
 Output:
 1000000000.0 0.0
 500000000.0 500000000.0
 
 Explanation
 Example case 1. In the second case, if decision isn't made at t = 0, total amount of money decreases to 5*108 at t = 1 which leads to a situation worse than the given solution.",BANROB,S8961435,PYTH,"# Number of test cases
T = int(input())

# Loop through each test case
for _ in range(T):
  # Read in M and p
  M, p = map(int, input().split())

  # Calculate the amount of money each thief will get
  chef_money = 1e9 * p / (1 + p)
  colleague_money = 1e9 - chef_money

  # Print the result
  print(""{:.2f} {:.2f}"".format(chef_money, colleague_money))
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 Harry is a bright student. To prepare thoroughly for exams, he completes all the exercises in his book! Now that the exams are approaching fast, he is doing book exercises day and night. He writes down and keeps updating the remaining number of exercises on the back cover of each book.
 Harry has a lot of books messed on the floor. Therefore, he wants to pile up the books that still have some remaining exercises into a single pile. He will grab the books one-by-one and add the books that still have remaining exercises to the top of the pile.
 Whenever he wants to do a book exercise, he will pick the book with the minimum number of remaining exercises from the pile. In order to pick the book, he has to remove all the books above it. Therefore, if there are more than one books with the minimum number of remaining exercises, he will take the one which requires the least number of books to remove. The removed books are returned to the messy floor. After he picks the book, he will do all the remaining exercises and trash the book.
 Since number of books is rather large, he needs your help to tell him the number of books he must remove, for picking the book with the minimum number of exercises.
 
 Note that more than one book can have the same name.
 
 Input
 The first line contains a single integer N denoting the number of actions. Then N lines follow. Each line starts with an integer. If the integer is -1, that means Harry wants to do a book exercise. Otherwise, the integer is number of the remaining exercises in the book he grabs next. This is followed by a string denoting the name of the book.
 Output
 For each -1 in the input, output a single line containing the number of books Harry must remove, followed by the name of the book that Harry must pick.
 Constraints
 
 1 < N ≤ 1,000,000 0 ≤ (the number of remaining exercises of each book) < 100,000 The name of each book consists of between 1 and 15 characters 'a' - 'z'. Whenever he wants to do a book exercise, there is at least one book in the pile.
 
 Example
 
 Input:
 6
 9 english
 6 mathematics
 8 geography
 -1
 3 graphics
 -1
 
 Output:
 1 mathematics
 0 graphics",BEX,S10647731,PYTH,"import heapq

# Create an empty heap and dictionary
heap = []
books = {}

# Read the number of actions
n = int(input())

# Counter to keep track of the number of removed books
removed = 0

# Process the actions
for i in range(n):
    # Read the action
    action = input().split()
    if action[0] == '-1':
        # Harry wants to do a book exercise
        
        # Remove the book with the minimum number of remaining exercises from the heap
        book = heapq.heappop(heap)
        
        # Update the dictionary and counter
        del books[book[1]]
        removed += 1
        
        # Print the number of removed
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 The relationship between The University of Byteland and King Johnny was never a friendly one. The king was the easy-going, open-minded sort of person who is prepared to turn a blind eye to the embezzlement of public funds, but inwardly revolts at the thought of money going to waste, and supporting a university was to the king a perfect example of a waste of money. On the other hand, the chancellor of the university showed no tolerance whatsoever, and frequently stated in public that Byteland was being governed by a monarch who took terrible decisions when he was drunk and even worse ones when he was sober. After some time of bad-tempered coexistence, the king had had enough and decided to close down the university. However, the king's councillors advised against this move, suggesting it might cause social unrest. The king yielded to their advice, and instead established a law which banned all organisations, clubs and associations active at the university.
 
 This action had a rather curious effect on the usually lazy students of the university. They had never before even thought of organising any sort of fellowship, but now they immediately decided they needed to set one up. And this is how the Secret Fellowship came to life.
 
 The main problem that faced the management of the Fellowship was to organise members' meetings in such a way as to minimise the risk to the participants. It was decided that the n members of the fellowship should be split into k secret divisions, each consisting of at least 2 members. All members belonging to the same division would then meet regularly, and they would take it in turns to host the meetings of the division in their houses.
 
 But one more important factor has to be taken into account -- the laziness of students. It is therefore your task to form the divisions in such a way that the furthest distance a student may ever be asked to walk is as short as possible.
 Input
 The first line of input contains a single integer t, the number of test cases (t=1000). t test cases follow.
 
 Each test cases starts with a line containing two integers n k, denoting the number of students and the number of divisions to be formed, respectively (2<=2k<=n<=200). Each of the next n lines contains two integers xi yi each (-1000 <= xi,yi <= 1000), denoting the coordinates of the houses of successive students.
 Output
 
 For the i-th test case output a line with the text case i Y or case i N, specifying whether you wish to solve the given case. Then in the former case print exactly k lines. Each line should start with integer nj (nj>=2) and be followed by a space separated list of exactly nj increasing integers sjl, denoting the students belonging to the j-th division, numbered in input order (1<=sjl<=n). All divisions must be disjoint and the sum of all numbers nj must equal n.
 Score
 
 The score awarded to your program is the total of scores for the test cases you chose to solve.
 
 For each solved test case you will receive diam / (d*k) points, where diam denotes the distance between the two furthest houses of members of the fellowship, and d is the distance between the two furthest houses of members belonging to the same division.
 Example
 
 Input:
 2
 6 3
 0 0
 1 0
 0 1
 1 1
 2 0
 2 1
 6 2
 0 0
 1 0
 0 1
 1 1
 2 0
 2 1
 6 2
 0 0
 1 0
 0 1
 1 1
 2 0
 2 1
 
 Output:
 case 1 Y
 3 1 2 4
 3 3 5 6
 case 2 Y
 3 1 2 5
 3 3 4 6
 case 3 Y
 2 1 3
 4 2 4 5 6
 
 Score:
 1.849003
 
 Bonus info: If score = xxx.xxxaaa, aaa means the number of test cases with Y answer.",BFORG,S109159,PYTH,"def solve(n, k, points):
  divisions = [[] for i in range(k)]
  for i in range(n):
    min_distance = float(""inf"")
    min_division = None
    for j in range(k):
      division = divisions[j]
      division.append(i)
      max_distance = max_distance(points[j])
      if max_distance < min_distance:
        min_distance = max_distance
        min_division = j
      division.pop()
    divisions[min_division].append(i)
  return divisions
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 WARNING: This problem has large input / output files. Use of faster I/O methods is recommended.
 You are given an array A consisting of N integers. You have to answer M queries on it. Each query belongs to one of the following three types:
 
 1 L R X : multiply each number in the range AL, AL + 1, ..., AR by X.
 2 L R Y : Replace the elements AL, AL + 1, ..., AR by Y, 2 * Y, ... (R - L + 1) * Y. In other words, the number Ai will be equal to (i - L + 1) * Y for each i from L to R.
 3 L R : Find the product of all numbers in the range AL, AL + 1, ..., AR. As this number could be very large, you have to just find the number of trailing zeros of this number when represented in decimal notation.
 
 Input
 The first line of the input contains an integer T denoting the number of test cases. T test cases follow.
 The first line of each test case contains two space-separated integers N and M.
 The second line contains N space-separated integers denoting A1, A2, ..., AN
 For next M lines, each line contains a query.
 Each query is given by three or four (please refer to the statement) space separated integers.
 The first integer denotes type of the query. For every type of query next two integers denote L and R. For each query of type 1, next integer denote X. For each query of type 2, next integer denote Y.
 Output
 For each test case, output a single line containing the sum of answers of all the queries of type 3.
 Constraints
 
 1 ≤ T ≤ 5
 1 ≤ N, M, N + M ≤ 105
 1 ≤ L ≤ R ≤ N
 1 ≤ X, Y, Ai ≤ 109
 
 Subtasks
 
 Subtask #1 (18 points): 1 ≤ N, M, X, Y, Ai ≤ 10
 Subtask #2 (31 points): 1 ≤ N, M ≤ 1000
 Subtask #3 (51 points): original constraints
 
 Example
 Input:
 1
 5 5
 2 4 3 5 5
 3 2 4
 3 2 5
 2 2 4 1
 1 3 3 10
 3 1 5
 
 Output:
 5
 
 Explanation
 Array: [2, 4, 3, 5, 5]
 
 1st query: [4, 3, 5], 4 * 3 * 5 = 60 : answer 1.
 2nd query: [4, 3, 5, 5], 4 * 3 * 5 * 5 = 300 : answer 2.
 3rd query: [2, 4, 3, 5, 5] => [2, 1, 2, 3, 5].
 4th query: [2, 1, 2, 3, 5] => [2, 1, 20, 3, 5].
 5th query: [2, 1, 20, 3, 5], 2 * 1 * 20 * 3 * 5 = 600 - answer 2.
 
 Sum of all answers = 5.",BGQRS,S11945189,PYTH,"class Node:
    def __init__(self, start, end):
        self.start = start
        self.end = end
        self.sum = 0
        self.lazy = 1
        self.left = None
        self.right = None
def build_tree(start, end):
    # base case: if start and end are the same, return a leaf node
    if start == end:
        return Node(start, end)
    
    # calculate the midpoint of the range
    mid = (start + end) // 2
    
    # create a new node and set its left and right children
    node = Node(start, end)
    node.left = build_tree(start, mid)
    node.right = build_tree(mid+1, end)
    
    # return the root node
    return node
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
 The much anticipated video game ""BiCo Grid"" has been released. The rules of ""Bico Grid"" are very simple.
 The game field is a 100x100 matrix, where each cell is either a blocked cell, or a cell with some number of coins. For a regular player the look of the field seems pretty random, but the programmer in you recognizes the following pattern: the i-th cell on the n-th row contains C(n, i) coins if and only if 0 ≤ i ≤ n, all other cells are blocked. Record C(n, i) denotes binomial coefficient ""n choose i"".
 The player starts from the cell situated at row R and column C in the matrix. The objective is to collect exactly G number of coins from matrix in several moves. There are some rules: 
 
 On each move the player must collect all the coins from some unblocked cell in the current column.
 The rules of the game state, that player mustn't be really greedy, so the number of coins he collected must not increase. In other words, if at some move the player collected X coins then further he cannot collect more than X coins in a single move.
 After each move, the player is immediately moved to some cell of the column W-1 (where W denotes the current column of the player). If the current column of the player has index 0, the game ends.
 The game ends when player collects exactly G number of coins.
 
 You are given the description of the game. Please, output the sequence of moves that win the game (collect exactly G coins)! It is guaranteed that if the player will play optimally it is possible to win the game.
 Input
 The first line of the input contains an integer T denoting the number of test cases. Then T lines follows. Each containing three integers, R denoting the starting row, C, denoting the starting column, and G, denoting the number of coins to be collected.
 Output
 For each test case, output two lines. First line contains K, the number of column visited before completion of game. Second line contains K space separated integers, the number of coins collected from the cells, in the order they were collected.
 It is guaranteed that a solution exists. And if there are multiple solutions, print any of them.
 Constraints
 1 ≤ T ≤ 100000 ≤ C ≤ 490 ≤ R ≤ 991 ≤ G ≤ 1012
 Example
 Input:
 3
 3 2 5
 3 3 10
 5 4 7
 
 Output:
 2
 3 2 
 1
 10 
 3
 5 1 1
 Explanation
 Example case 1. We first pick 3 coins from [3, 2] then we pick 2 coins from [2, 1]Example case 2. As 3rd column contains 10 coins in cell [5, 3] we pick it.Example case 3. We first pick 5 coins from [5, 4] then we pick 1 coin from [3, 3] and again we pick 1 coin from [2, 2].",BICO,S3785756,PYTH,"T = int(input())

for _ in range(T):
    R, C, G = map(int, input().split())
    column = C
    coins = 0
    while coins < G:
        coins += C(R, column)
        column -= 1
        if column == 0:
            break
    print(C - column)
    print("" "".join(str(C(R, i)) for i in range(column + 1, C + 1)))
",,,,,,,,,,,,,,,,,,,,,
"function formatTime(ts) {
  now = new Date(ts);
 
  localtime = new Date();
  hour = now.getHours();
  min = now.getMinutes();
  sec = now.getSeconds();
 
  if (min <= 9) {
  min = ""0"" + min;
  }
  if (sec <= 9) {
  sec = ""0"" + sec;
  }
  if (hour > 12) {
  hour = hour - 12;
  add = "" PM"";
  } else {
  hour = hour;
  add = "" AM"";
  }
  if (hour == 12) {
  add = "" PM"";
  }
  if (hour == 00) {
  hour = ""12"";
  }
 
  $('#server-time').html(((hour<=9) ? ""0"" + hour : hour) + "":"" + min + "":"" + sec + add);
 
  nextSec = (now.getTime() + 1000);
 
  setTimeout(""formatTime(""+nextSec+"")"", 1000);
  }
  function getDtTimeZone()
  {
  var rightNow = new Date();
  var toDay = new Date(rightNow.getFullYear(), 0, 1, 0, 0, 0, 0);
  var temp = toDay.toGMTString();
  var date2 = new Date(temp.substring(0, temp.lastIndexOf("" "") -1));
  var stdTime = (toDay - date2) / (1000 * 60 * 60);
  return stdTime;
  }
 /*var d=new Date();
 $.ajax({
 url: '/umtza',
 type:'POST',
 data: 'umtza='+d.toString(),
 });
 */
 
 CodeChef is a non-commercial competitive programming community
 
 
 
 
 About CodeChef
 About Directi
 CEO's Corner
 C-Programming
 Programming Languages
 Contact Us
 
 
 © 2009 Directi Group. All Rights Reserved. CodeChef uses SPOJ © by Sphere Research Labs
 In order to report copyright violations of any kind, send in an email to copyright@codechef.com
 
 
 
 The time now is: 
 
  formatTime('September 01, 2014 16:46:08');
  
 
 
 
 
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-53602-42']);
  _gaq.push(['_trackPageview']);
 
  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
 
  
 
 
  /* <![CDATA[ */
  var google_conversion_id = 1066618556;
  var google_conversion_language = ""en"";
  var google_conversion_format = ""3"";
  var google_conversion_color = ""666666"";
  var google_conversion_label = ""gbUUCPTlhAIQvJ3N_AM"";
  var google_conversion_value = 0;
  /* ]]> */
  
 
 
 
 
 
 
 
 
 
  /* <![CDATA[ */
  var google_conversion_id = 968176136;
  var google_conversion_language = ""en"";
  var google_conversion_format = ""3"";
  var google_conversion_color = ""ffffff"";
  var google_conversion_label = ""iDk7CPDZ7wMQiOTUzQM"";
  var google_conversion_value = 0;
  /* ]]> */
  
 
 
 
 
 
 
 
 
 CodeChef - A Platform for Aspiring Programmers
 CodeChef was created as a platform to help programmers make it big in the world of algorithms, computer programming and programming contests. At CodeChef we work hard to revive the geek in you by hosting a programming contest at the start of the month and another smaller programming challenge in the middle of the month. We also aim to have training sessions and discussions related to algorithms, binary search, technicalities like array size and the likes. Apart from providing a platform for programming competitions, CodeChef also has various algorithm tutorials and forum discussions to help those who are new to the world of computer programming.
 
 Practice Section - A Place to hone your 'Computer Programming Skills'
 Try your hand at one of our many practice problems and submit your solution in a language of your choice. Our programming contest judge accepts solutions in over 35+ programming languages. Preparing for coding contests were never this much fun! Receive points, and move up through the CodeChef ranks. Use our practice section to better prepare yourself for the multiple programming challenges that take place through-out the month on CodeChef. 
 
 Compete - Monthly Programming Contests and Cook-offs
 Here is where you can show off your computer programming skills. Take part in our 10 day long monthly coding contest and the shorter format Cook-off coding contest. Put yourself up for recognition and win great prizes. Our programming contests have prizes worth up to Rs.20,000 and $700lots more CodeChef goodies up for grabs. 
 
 Discuss
 Are you new to computer programming? Do you need help with algorithms? Then be a part of CodeChef's Forums and interact with all our programmers - they love helping out other programmers and sharing their ideas. Have discussions around binary search, array size, branch-and-bound, Dijkstra's algorithm, Encryption algorithm and more by visiting the CodeChef Forums and Wiki section.
 
 CodeChef Community
 As part of our Educational initiative, we give institutes the opportunity to associate with CodeChef in the form of Campus Chapters. Hosting online programming competitions is not the only feature on CodeChef. You can also host a coding contest for your institute on CodeChef, organize an algorithm event and be a guest author on our blog. 
 
 Go For Gold
 The Go for Gold Initiative was launched about a year after CodeChef was incepted, to help prepare Indian students for the ACM ICPC World Finals competition. In the run up to the ACM ICPC competition, the Go for Gold initiative uses CodeChef as a platform to train students for the ACM ICPC competition via multiple warm up contests. As an added incentive the Go for Gold initiative is also offering over Rs.8 lacs to the Indian team that beats the 29th position at the ACM ICPC world finals. Find out more about the Go for Gold and the ACM ICPC competition here.",BIGTREE,S11203593,PYTH,"# First, we define a function called ""format_time"" that takes in a timestamp and formats it according to the requirements specified in the problem statement
def format_time(ts):
  # Convert the timestamp to a date object
  now = datetime.fromtimestamp(ts)

  # Extract the hour, minute, and second from the date object
  hour = now.hour
  min = now.minute
  sec = now.second

  # Add a leading zero to the minute and second if they are less than 10
  if min <= 9:
    min = ""0"" + str(min)
  if sec <= 9:
    sec = ""0"" + str(sec)

  # Determine whether it is AM or PM based on the hour
  if hour > 12:
    hour = hour - 12
    add = "" PM""
  else:
    hour = hour
    add = "" AM""

  # Set the hour to 12 if it is equal to 0
  if hour == 12:
    add = "" PM""
  if hour == 0:
    hour = ""12""

  # Return the formatted time as a string
  return str(
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 Today is Chef's birthday. His mom decided to surprise him with a truly fantastic gift: his favourite binary string B. But, unfortunately, all the stocks of binary string B have been sold out, and only a binary string A (A ≠ B) is available in the market.
 She purchases the string A and tries to convert it to string B by applying any of following three operations zero or more times.
 
 AND Operation:
 She will choose a pair of indices i and j such that i != j and perform following sequence of operations.
 
 
  result = Ai & Aj 
 
 
  Ai = result & Ai 
 
 
  Aj = result & Aj 
 
 
 
 OR Operation:
 She will choose a pair of indices i and j such that i != j and perform following sequence of operations.
 
 
  result = Ai | Aj 
 
 
  Ai = result | Ai 
 
 
  Aj = result | Aj 
 
 
 
 XOR Operation:
 She will choose a pair of indices i and j such that i != j and perform following sequence of operations.
 
 
  result = Ai ^ Aj 
 
 
  Ai = result ^ Ai 
 
 
  Aj = result ^ Aj 
 
 
 Chef's mom is eagerly waiting to surprise him with his favourite gift and therefore, she wants to convert string A to string B as fast as possible. Can you please help her by telling her the minimum number of operations she will require? If it is impossible to do so, then let Chef's mom know about it.
 Input
 First line of input contains a single integer T denoting the number of test cases. T test cases follow.
 First line of each test case, will contain binary string A.
 Second line of each test case, will contain binary string B.
 Output
 For each test case, Print ""Lucky Chef"" (without quotes) in first line and minimum number of operations required to convert string A to sting B in second line if conversion is possible. Print ""Unlucky Chef"" (without quotes) in a new line otherwise.
 Constraints
 
 
 1 ≤ T ≤ 105
 
 
 1 ≤ |A| ≤ 106
 
 
 1 ≤ |B| ≤ 106
 
 
 A != B
 
 
 |A| = |B|
 
 
 sum of |A| over all test cases does not exceed 106
 
 
 sum of |B| over all test cases does not exceed 106
 
 
 Subtasks
 
 
  Subtask #1 (40 points) : Sum of |A| & |B| over all test cases does not exceed 103
 
 
  Subtask #2 (60 points) : Sum of |A| & |B| over all test cases does not exceed 106
 
 
 Example
 
 Input
 2
 101
 010
 1111
 1010
 Output
 Lucky Chef
 2
 Unlucky Chef
 
 Explanation
 Example case 1. 
 
 Applying XOR operation with indices i = 1 and j = 2. Resulting string will be 011.
 Then, Applying AND operation with indices i = 1 and j = 3. Resulting string will be 010.
 
 Example case 2. 
 
 It is impossible to convert string A to string B.",BINOP,S10511847,PYTH,"def find_operations(a, b):
  # Initialize variables to track the number of operations and whether a conversion is possible
  num_ops = 0
  possible = True

  # Iterate through the characters in the strings
  for i in range(len(a)):
    # If the characters are not equal, we need to perform an operation
    if a[i] != b[i]:
      num_ops += 1
      
      # If the characters are both 1 or both 0, we can use the AND operation
      if a[i] == '1' and b[i] == '0' or a[i] == '0' and b[i] == '1':
        # Update the characters in the strings
        a[i] = '0'
        b[i] = '0'
      # If one character is 1 and the other is 0, we can use the OR or XOR operation
      elif a[i] == '1' or b[i] == '1':
        # Update the characters in the strings
        a[i] = '1'
        b[i] = '1'
      # If none of the above conditions are met, it is not possible to convert the strings
      else:
        possible = False
        break
  
  # Return the number of operations and whether a conversion is possible
  return num_ops, possible

# Test the function with the given test cases
t = 2
test_cases = [(""101"", ""010""), (""1111"", ""1010"")]
for i in range(t):
  a, b = test_
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 Knights' tournaments were quite popular in the Middle Ages. A lot of boys were dreaming of becoming a knight, while a lot of girls were dreaming of marrying a knight on a white horse.
 
 In this problem we consider one of these tournaments.
 
 
 Let's us call a tournament binary, if it runs according to the scheme described below:
 
 
 Exactly N knights take part in the tournament, N=2K for some integer K > 0.
 Each knight has a unique skill called strength, described as an integer from the interval [1, N].
 Initially, all the knights are standing in a line, waiting for a battle. Since all their strengths are unique, each initial configuration can be described as a permutation of numbers from 1 to N.
 There are exactly K rounds in the tournament, 2K - i + 1 knights take part in the i'th round. The K'th round is called the final.
 The i'th round runs in the following way: for each positive integer j ≤ 2K - i happens a battle between a knight on the 2∙j'th position and a knight on the 2∙j+1'th position. The strongest of two continues his tournament, taking the j'th position on the next round, while the weakest of two is forced to leave.
 The only knight, who has won K rounds, is the winner. The only knight, who has won K - 1 rounds, but lost the final, is the runner-up.
 
 
 
 As you can see from the scheme, the winner is always the same, an initial configuration doesn't change anything. So, your task is to determine chances of each knight to appear in the final.
 
 
 Formally, for each knight you need to count the number of initial configurations, which will lead him to the final. Since the number can be extremly huge, you are asked to do all the calculations under modulo 109 + 9.
 
 Input
 The first line contains the only integer K, denoting the number of rounds of the tournament.
 
 Output
 Output should consist of 2K lines. The i'th line should contain the number of initial configurations, which lead the participant with strength equals to i to the final.
 
 Constraints
 1 ≤ K < 20
 
 Examples
 Input:
 1
 
 Output:
 2
 2
 
 Input:
 2
 
 Output:
 0
 8
 16
 24
 
 Explanation
 
 In the first example we have N=2 knights. Let's consider each initial configuration that could appear and simulate the tournament.
 
 
 (1, 2) -> (2)
 
 
 (2, 1) -> (2)
 
 
 In the second example we have N=4 knights. Let's consider some initial configurations that could appear and simulate the tournament.
 
 
 (1, 2, 3, 4) -> (2, 4) -> (4)
 
 
 (3, 2, 4, 1) -> (3, 4) -> (4)
 
 
 (4, 1, 3, 2) -> (4, 3) -> (4)",BINTOUR,S10533647,PYTH,"def knight_chances(K: int):
    mod = 10**9 + 9
    # Initialize an array to store the number of configurations for each knight
    chances = [0] * (2**K)
    # Iterate over all pairs of knights
    for i in range(2**K):
        for j in range(2**K):
            if i == j:
                continue
            # Compute the number of configurations where i and j face off in the final
            configs = 1
            for round in range(K):
                pos_i = i // (2**round)
                pos_j = j // (2**round)
                configs *= ((2*pos_i-1)! * (2*pos_j-1)!) * ((2*pos_i)! * (2*pos_j)!)
            configs %= mod
            # Add the configurations to the count for each knight
            chances[i] += configs
            chances[j] += configs
    # Return the result
    return chances
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 Consider an infinite full binary tree (each node has two children except the leaf nodes) defined as follows. For a node labelled v its left child will be labelled 2*v and its right child will be labelled 2*v+1. The root is labelled as 1.
 You are given N queries of the form i j. For each query, you have to print the length of the shortest path between node labelled i and node labelled j.
 
 Input
 First line contains N, the number of queries. Each query consists of two space separated integers i and j in one line.
 Output
 For each query, print the required answer in one line.
 Constraints
 
 1 ≤ N ≤ 105
 1 ≤ i,j ≤ 109
 
 Example
 Input:
 3
 1 2
 2 3
 4 3
 
 Output:
 1
 2
 3
 Explanation
 For first query, 1 is directly connected to 2 by an edge. Hence distance 1.",BINTREE,S10386259,PYTH,"def shortest_path(N: int, queries: List[Tuple[int, int]]):
    # Function to find the depth of a node in the tree
    def depth(node):
        d = 0
        while node > 1:
            node //= 2
            d += 1
        return d
    
    # Function to find the LCA of two nodes
    def lca(node1, node2):
        d1 = depth(node1)
        d2 = depth(node2)
        # Bring the deeper node to the same depth as the shallower node
        if d1 > d2:
            node1 //= 2**(d1-d2)
        elif d2 > d1:
            node2 //= 2**(d2-d1)
        # Iterate through the nodes from the shallower node to the deeper node
        # and divide their labels by 2 until we reach a node where the two labels are equal
        while node1 != node2:
            node1 //= 2
            node2 //= 2
        return node1
    
    # Find the shortest path between the two nodes for each query
    for i, j in queries:
        print(depth(i) + depth(j) - 2 * depth(lca(i, j)) + 1)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 Let's consider a rooted binary tree with the following properties:
 
 The number of nodes and edges in the tree is infinite
 The tree root is labeled by 1
 A node labeled by v has two children: 2 × v (the left son of v) and 2 × v + 1 (the right son of v)
 
 
 Here is an image of the first several tree layers of such a tree:
 
 Let's consider four operations, that are allowed to apply during the tree traversal:
 
 move to the left son - move from v to 2 × v
 move to the right son - move from v to 2 × v + 1
 move to the parent as a left son - move from v to v / 2 if v is an even integer
 move to the parent as a right son - move from v to (v - 1) / 2 if v is an odd integer
 
 
 It can be proven, that for any pair of two nodes u and v, there is only one sequence of such commands, that moves from u to v and visits each node of the tree at most once. Let's call such a sequence of commands a path configuration for a pair of nodes (u, v).
 You are asked to process a series of the following queries:
 You are given three integers n, u and v (1 ≤ u, v ≤ n). Count the pairs of nodes (w, t) (1 ≤ w, t ≤ n) such that the path configuration for (w, t) is the same with the path configuration for (u, v).
 Input
 The first line of input contains an integer Q denoting the number of queries to process.
 Each of the next Q lines contains three space-separated integers n, u and v denoting a query.
 Output
 For each query, print the answer on a separate line.
 Constraints
 
 1 ≤ Q ≤ 20000
 1 ≤ u, v ≤ n ≤ 109
 
 Example
 Input:
 3
 11 9 11
 10 2 2
 8 1 8
 
 Output:
 2
 10
 1
 Explanation
 In the first query from the example test case, you should count pairs (5, 7) and (9, 11).
 In the second query from the example test case, you should count the following pairs: (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9) and (10, 10).
 In the third query from the example test case, you should only count a pair (1, 8).",BINTREEQ,S10068668,PYTH,"def count_pairs(N: int, queries: List[Tuple[int, int, int]]):
    # Function to find the common ancestor of two nodes
    def common_ancestor(node1, node2):
        while node1 != node2:
            if node1 > node2:
                node1 //= 2
            else:
                node2 //= 2
        return node1

    for n, u, v in queries:
        # Find the common ancestor of u and v
        ancestor = common_ancestor(u, v)
        # Initialize the count to the number of nodes on the same side of the ancestor as u and v
        count = (n+1) // 2
        # Iterate through the depths of the tree, starting from the common ancestor
        depth = 1
        while ancestor > 1:
            ancestor //= 2
            # Add the number of nodes at this depth that are on the opposite side of the ancestor as u and v
            count += (n+1) // (2**depth)
            depth += 1
        print(count)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 Zombies zombies everywhere!! 
 In a parallel world of zombies, there are N zombies. There are infinite number of unused cars, each of same model only differentiated by the their colors. The cars are of K colors.
 
 
 A zombie parent can give birth to any number of zombie-children (possibly zero), i.e. each zombie will have its parent except the head zombie which was born in the winters by combination of ice and fire.
 
 
 Now, zombies are having great difficulties to commute to their offices without cars, so they decided to use the cars available. Every zombie will need only one car. Head zombie called a meeting regarding this, in which he will allow each zombie to select a car for him.
 
 
 Out of all the cars, the head zombie chose one of cars for him. Now, he called his children to choose the cars for them. After that they called their children and so on till each of the zombie had a car. Head zombie knew that it won't be a good idea to allow children to have cars of same color as that of parent, as they might mistakenly use that. So, he enforced this rule during the selection of cars.
 
 Professor James Moriarty is a criminal mastermind and has trapped Watson again in the zombie world. Sherlock somehow manages to go there and met the head zombie. Head zombie told Sherlock that they will let Watson free if and only if Sherlock manages to tell him the maximum number of ways in which the cars can be selected by N Zombies among all possible hierarchies. A hierarchy represents parent-child relationships among the N zombies. Since the answer may be large, output the answer modulo 109 + 7. Sherlock can not compute big numbers, so he confides you to solve this for him.
 
 Input
 The first line consists of a single integer T, the number of test-cases.
 Each test case consists of two space-separated integers N and K, denoting number of zombies and the possible number of colors of the cars respectively.
 
 Output
 For each test-case, output a single line denoting the answer of the problem.
 Constraints
 
 1 ≤ T ≤ 100
 1 ≤ N ≤ 10^9
 1 ≤ K ≤ 10^9
 
 Subtasks
 
 Subtask #1 : (10 points)
 
 
 1 ≤ T ≤ 20
 1 ≤ N, K ≤ 10
 
 
 
 Subtask 2 : (20 points) 
 
 
 1 ≤ T ≤ 10
 1 ≤ N, K ≤ 10000
 
 
 
 Subtask 3 : (70 points) 
 
 
 1 ≤ T ≤ 100
 1 ≤ N, K ≤ 10^9
 
 
 Example
 Input
 2
 2 2
 3 3
 Output:
 2
 12
 Explanation
 In the first sample test case, there are 2 zombies. Let us name them Z1 and Z2. Let one hierarchy be one in which Z1 is parent of Z2. There are 2 colors, suppose red and blue. If Z1 takes red, then Z2 should take a blue. If Z1 takes blue, then Z2 should take red. 
 Note that one other possible hierarchy could be one in which Z2 is a parent of Z1. In that hierarchy also, number of possible ways of assigning cars is 2.
 So there maximum number of possible ways is 2.
 
 
 In the second example, we have 3 Zombies say Z1, Z2, Z3 and cars of 3 colors, suppose red, blue and green.
 A hierarchy to maximize the number of possibilities is Z1 is the parent of Z2, Z2 is the parent of Z3.
 Zombie Z1 can choose one of red, blue or green cars. Z2 can choose one of the remaining two colors (as its car's color can not be same as its parent car.). Z3 can also choose his car in two colors, (one of them could be color same as Z1, and other being the color which is not same as cars of both Z1 and Z2.). This way, there can be 12 different ways of selecting the cars.",BIPIN3,S10250993,PYTH,"def max_ways(T: int, test_cases: List[Tuple[int, int]]):
    mod = 1000000007
    # Function to compute the number of ways to assign cars to the zombies for each hierarchy
    def dp(n, k):
        # Initialize the dp array with 0
        dp = [[0] * (k+1) for _ in range(n+1)]
        # Set the base case: dp[1][j] = j for all j
        for j in range(1, k+1):
            dp[1][j] = j
        # Iterate through the number of zombies, starting from the first zombie
        for i in range(2, n+1):
            # Compute the number of ways to assign cars to the remaining zombies in the hierarchy
            for j in range(1, k+1):
                dp[i][j] = (dp[i][j-1] + dp[i-1][j-1]) % mod
        # Return the number of ways to assign cars to all the zombies
        return sum(dp[n]) % mod
    
    # Comp
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 Consider the following game that is played on the field of the size of 1 x N cells. The cells are numbered from 1 to N. In the i-th cell there are two positive integers written - Ai and Bi.
 The game is as follows. Initially, the player stands at the fictive cell with the index 0 that is located right before all the N cells of the board. Then, he makes moves. Each move consists in moving by no more than by K cells forward. The goal of the game is to reach the fictive N+1-th cell that is located right after all the N cells.
 After the N+1-th cell is reached, the player's penalty is calculated. The penalty equals to max(Ax) * max(By), where x and y are the indices of the cells that were visited in between (during the movement to the N+1-th cell).
 Please find the minimal possible penalty that can be reached in this game.
 Input
 The first line of input contains two single space separated integer numbers - N and K respectively.
 Then, there are N lines, each containing a pair of signle space separated integers - Ai and Bi respectively.
 Output
 Output the minimal possible penalty on the first line.
 Constraints
 
 
 1 ≤ K ≤ N
 1 ≤ N ≤ 100, 1 ≤ Ai, Bi ≤ 100 - 27 points.
 1 ≤ N ≤ 1000, 1 ≤ Ai, Bi ≤ 32000 - 20 points.
 1 ≤ N ≤ 5 * 105, 1 ≤ Ai, Bi ≤ 32000 - 53 points.
 
 
 Example
 Input:
 5 3
 1 5
 2 4
 3 3
 4 2
 5 1
 
 Output:
 9",BNGAME,S3943760,PYTH,"def minimal_penalty(N, K, A, B):
    dp = [0] * (N+2)
    for i in range(1, N+2):
        dp[i] = float('inf')
        for j in range(max(0, i-k-1), i-1):
            dp[i] = min(dp[i], dp[j] + max(A[j+1:i]) * max(B[j+1:i]))
    return dp[N+1]
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 
 Recently Johnny have learned bogosort sorting algorithm. He thought that it is too ineffective. So he decided to improve it. As you may know this algorithm shuffles the sequence randomly until it is sorted. Johnny decided that we don't need to shuffle the whole sequence every time. If after the last shuffle several first elements end up in the right places we will fix them and don't shuffle those elements furthermore. We will do the same for the last elements if they are in the right places. For example, if the initial sequence is (3, 5, 1, 6, 4, 2) and after one shuffle Johnny gets (1, 2, 5, 4, 3, 6) he will fix 1, 2 and 6 and proceed with sorting (5, 4, 3) using the same algorithm. Johnny hopes that this optimization will significantly improve the algorithm. Help him calculate the expected amount of shuffles for the improved algorithm to sort the sequence of the first n natural numbers given that no elements are in the right places initially.
 Input
 The first line of input file is number t - the number of test cases. Each of the following t lines hold single number n - the number of elements in the sequence.
 Constraints
 1 <= t <= 150
 2 <= n <= 150
 Output
 For each test case output the expected amount of shuffles needed for the improved algorithm to sort the sequence of first n natural numbers in the form of irreducible fractions.
 Example
 
 Input:
 3
 2
 6
 10
 
 Output:
 2
 1826/189
 877318/35343",BOGOSORT,S10906322,PYTH,"def shuffles_needed(permutation):
    counter = 0
    while not is_sorted(permutation):
        counter += 1
        i = 0
        while i < len(permutation) and permutation[i] == i + 1:
            i += 1
        j = len(permutation) - 1
        while j >= 0 and permutation[j] == j + 1:
            j -= 1
        permutation = permutation[:i] + shuffle(permutation[i:j+1]) + permutation[j+1:]
    return counter

def is_sorted(permutation):
    for i in range(len(permutation)):
        if permutation[i] != i + 1:
            return False
    return True

def shuffle(sequence):
    # shuffle the elements of the sequence randomly
    pass

def expected_value(n):
    total = 0
    for permutation in permutations(range(1, n+1)):
        probability = 1 / math.factorial(n)
        shuffles = shuffles_needed(permutation)
        total += probability * shuffles
    return total / math.factorial(n)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 Chef Watson uses a social network called ChefBook, which has a new feed consisting of posts by his friends. Each post can be characterized by f - the identifier of the friend who created the post, p - the popularity of the post(which is pre-calculated by ChefBook platform using some machine learning algorithm) and s - the contents of the post which is a string of lower and uppercase English alphabets.
 Also, Chef has some friends, which he has marked as special.
 The algorithm used by ChefBook for determining the order of posts in news feed is as follows:
 
 Posts of special friends should be shown first, irrespective of popularity. Among all such posts the popular ones should be shown earlier.
 Among all other posts, popular posts should be shown earlier.
 
 
 Given, a list of identifiers of Chef's special friends and a list of posts, you have to implement this algorithm for engineers of ChefBook and output the correct ordering of posts in the new feed. 
 Input
 First line contains N, number of special friends of Chef and M, the number of posts. Next line contains N integers A1, A2, ..., AN denoting the identifiers of special friends of Chef. Each of the next M lines contains a pair of integers and a string denoting f, p and s, identifier of the friend who created the post, the popularity of the post and the contents of the post, respectively. It is guaranteed that no two posts have same popularity.
 Output
 Output correct ordering of posts in news feed in M lines. Output only the contents of a post.
 
 Constraints
 
 1 ≤ N, M ≤ 103
 1 ≤ Ai, f, p ≤ 105
 1 ≤ length(s) ≤ 100
 
 Example
 Input:
 2 4
 1 2
 1 1 WhoDoesntLoveChefBook
 2 2 WinterIsComing
 3 10 TheseViolentDelightsHaveViolentEnds
 4 3 ComeAtTheKingBestNotMiss
 
 Output:
 WinterIsComing
 WhoDoesntLoveChefBook
 TheseViolentDelightsHaveViolentEnds
 ComeAtTheKingBestNotMiss
 
 
 Explanation
 
 First we should show posts created by friends with identifiers 1 and 2. Among the posts by these friends, the one with more popularity should be shown first.
 Among remaining posts, we show those which are more popular first.",BOOKCHEF,S11939128,PYTH,"def sort_posts(a, b):
    # Check if a or b are special friends
    a_is_special = a[0] in special_friends
    b_is_special = b[0] in special_friends

    # If both are special or both are not special, compare their popularity
    if a_is_special == b_is_special:
        return b[1] - a[1]

    # If a is special and b is not, a comes first
    if a_is_special:
        return -1

    # If b is special and a is not, b comes first
    if b_is_special:
        return 1

posts = [(f, p, s) for f, p, s in zip(f_values, p_values, s_values)]
posts.sort(key=sort_posts)

for f, p, s in posts:
    print(s)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 It's autumn now, the time of the leaf fall.
 Sergey likes to collect fallen leaves in autumn. In his city, he can find fallen leaves of maple, oak and poplar. These leaves can be of three different colors: green, yellow or red.
 Sergey has collected some leaves of each type and color. Now he wants to create the biggest nice bouquet from them. He considers the bouquet nice iff all the leaves in it are either from the same type of tree or of the same color (or both). Moreover, he doesn't want to create a bouquet with even number of leaves in it, since this kind of bouquets are considered to attract bad luck. However, if it's impossible to make any nice bouquet, he won't do anything, thus, obtaining a bouquet with zero leaves.
 Please help Sergey to find the maximal number of leaves he can have in a nice bouquet, which satisfies all the above mentioned requirements.
 Please note that Sergey doesn't have to use all the leaves of the same color or of the same type. For example, if he has 20 maple leaves, he can still create a bouquet of 19 leaves.
 Input
 IThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.""
 The first line of each test case contains three space-separated integers MG MY MR denoting the number of green, yellow and red maple leaves respectively.
 The second line contains three space-separated integers OG OY OR denoting the number of green, yellow and red oak leaves respectively.
 The third line of each test case contains three space-separated integers PG PY PR denoting the number of green, yellow and red poplar leaves respectively.
 Output
 For each test case, output a single line containing the maximal amount of flowers in nice bouquet, satisfying all conditions or 0 if it's impossible to create any bouquet, satisfying the conditions.
 Constraints
 
 
 1 ≤ T ≤ 10000
 Subtask 1 (50 points): 0 ≤ MG, MY, MR, OG, OY, OR, PG, PY, PR ≤ 5
 Subtask 2 (50 points): 0 ≤ MG, MY, MR, OG, OY, OR, PG, PY, PR ≤ 109
 
 
 Example
 Input:
 1
 1 2 3
 3 2 1
 1 3 4
 
 Output:
 7
 
 Explanation
 Example case 1. We can create a bouquet with 7 leaves, for example, by collecting all yellow leaves. This is not the only way to create the nice bouquet with 7 leaves (for example, Sergey can use all but one red leaves), but it is impossible to create a nice bouquet with more than 7 leaves.",BOUQUET,S11979980,PYTH,"MG = 1, MY = 2, MR = 3
OG = 3, OY = 2, OR = 1
PG = 1, PY = 3, PR = 4

PR = 4
OG = 3
MY = 2
OY = 2
MR = 3
OR = 1
PG = 1
MG = 1

function maximal_nice_bouquet(MG, MY, MR, OG, OY, OR, PG, PY, PR):
    bouquet = []
    leaves = [(PR, ""PR""), (OG, ""OG""), (MY, ""MY""), (OY, ""OY""), (MR, ""MR""), (OR, ""OR""), (PG, ""PG""), (MG, ""MG"")]
    for (count, type) in leaves:
        if count % 2 == 1 and count > 0:
            bouquet.append(type)
            eval(type + "" -= 1"")
    return len(bouquet)

def maximal_nice_bouquet(MG, MY, MR, OG, OY, OR, PG, PY, PR):
    bouquet = []
    leaves = [(PR, ""PR""), (OG, ""OG""), (MY, ""MY""), (OY, ""OY""), (MR, ""MR""), (OR, ""OR""), (PG, ""PG""), (MG, ""MG"")]
    for (count, type) in leaves:
        if count % 2 == 1 and count > 0:
            bouquet.append(type)
            eval(type + "" -= 1"")
    return len(bouquet)

T = int(input())
for _ in range(T):
    MG, MY, MR = map(int, input().split())
    OG, OY, OR = map(int, input().split())
    PG, PY, PR = map(int, input().split())
    print(maximal_nice_bouquet(MG, MY, MR, OG, OY, OR, PG, PY, PR))
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
 
 A valid parentheses sequence is a non-empty string where each character is either '(' or ')', which satisfies the following constraint:
 
 
 You can find a way to repeat erasing adjacent pairs of parentheses '()' until it becomes empty.
 
 
 For example, '(())' and '()((()()))' are valid parentheses sequences, but ')()(' and '(()' are not.
 
 
 Mike has a valid parentheses sequence. He really likes everything about his sequence, except the fact that it is quite long. So Mike has recently decided that he will replace his parentheses sequence with a new one in the near future. But not every valid parentheses sequence will satisfy him. To help you understand his requirements we'll introduce the pseudocode of function F(S):
 
 
 FUNCTION F( S - a valid parentheses sequence )
 BEGIN
 balance = 0
 max_balance = 0
 FOR index FROM 1 TO LENGTH(S)
 BEGIN
 if S[index] == '(' then balance = balance + 1
 if S[index] == ')' then balance = balance - 1
 max_balance = max( max_balance, balance )
 END
 RETURN max_balance
 END
 
 
 In other words, F(S) is equal to the maximal balance over all prefixes of S.
 
 
 Let's denote A as Mike's current parentheses sequence, and B as a candidate for a new one. Mike is willing to replace A with B if F(A) is equal to F(B). He would also like to choose B with the minimal possible length amongst ones satisfying the previous condition. If there are several such strings with the minimal possible length, then Mike will choose the least one lexicographically, considering '(' to be less than ')'.
 
 
 Help Mike!
 
 Input
 
 The first line of the input contains one integer T denoting the number of testcases to process.
 
 
 The only line of each testcase contains one string A denoting Mike's parentheses sequence. It is guaranteed that A only consists of the characters '(' and ')'. It is also guaranteed that A is a valid parentheses sequence.
 
 Output
 
 The output should contain exactly T lines, one line per each testcase in the order of their appearance. The only line of each testcase should contain one string B denoting the valid parentheses sequence that should be chosen by Mike to replace A.
 
 Constraints
 1 ≤ T ≤ 5;
 1 ≤ |A| ≤ 100000(105).
 Example
 Input:
 1
 ()((()()))
 
 Output:
 ((()))",BRACKETS,S12104032,PYTH,"FUNCTION solve(A: string): string
    B = """"
    balance = 0
    FOR i = 1 TO LENGTH(A)
        IF A[i] == '('
            balance = balance + 1
            B = B + '('
        ELSE IF balance > 0
            balance = balance - 1
            B = B + ')'
    END FOR
    FOR i = 1 TO balance
        B = B + ')'
    END FOR
    RETURN B
END FUNCTION
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 Each cell of an N x N grid is either a 0 or a 1. You are given two such N x N grids, the initial grid and the final grid. There is a button against each row and each column of the initial N x N grid. Pressing a row-button toggles the values of all the cells in that row, and pressing a column-button toggles the values of all the cells in that column. You are required to find the minimum number of button presses required to transform the grid from the initial configuration to the final configuration, and the buttons that must be pressed in order to make this transformation.
 Edit: When the initial and the final configurations are the same, print ""0"".
 Input
 The first line contains t, the number of test cases (about 10). Then t test cases follow.
 Each test case has the following form:
  * The first line contains n, the size of the board (1 ≤ n ≤ 1000).
  * n lines follow. The ith line contains n space separated integers representing the ith row of the initial grid. Each integer is either a 0 or a 1.
  * n lines follow, representing the final grid, in the same format as above.
 Output
 For each test case, output the number of row-button presses, followed by the row buttons that must be pressed. Print the number of column-button presses next, followed by 0-indexed indices of the column buttons that must be pressed. The total number of button presses must be minimized.
 Output ""-1"" if it is impossible to achieve the final configuration from the initial configuration. If there is more than one solution, print any one of them.
 Example
 
 Input:
 1
 3
 0 0 0
 1 1 0
 1 1 0
 1 1 0
 1 1 1
 1 1 1
 
 Output:
 1
 0 
 1
 2",BUTTONS,S1106729,PYTH,"for each test case:
  row_toggles = 0
  row_indices = []
  col_toggles = 0
  col_indices = []
  for i from 0 to n-1:
    if the ith row of the initial grid is not equal to the ith row of the final grid:
      row_toggles += 1
      row_indices.append(i)
    if the ith column of the initial grid is not equal to the ith column of the final grid:
      col_toggles += 1
      col_indices.append(i)
  if row_toggles + col_toggles is minimum possible:
    output row_toggles
    output row_indices
    output col_toggles
    output col_indices
  else:
    output ""-1""
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 Emily is coming back from her two-week vacation at the other continent. But when Emily arrived at the airport, she realized that she had got no presents for her K friends! She still had some time before her flight, so she went for a walk around the airport hoping to find something suitable.
 Soon Emily found a candy store and decided to buy some of her favorite candies for her friends. The store offers N packs of these candies, where pack i contains Ai candies.
 Another reason Emily decided to buy candies is that she is fond of collecting empty candy packs from various parts of the world. That's why she decided to buy exactly M packs and present the friends with the candies and keep the packs for her collection. Emily would also like the total number of candies to be divisible by K so that an equal distribution of candies between friends is possible. Among all possible sets of packs, she would like to buy a set with the smallest possible total number of candies (money is the reason).
 Your task is to help Emily, of course.
 Input
 The first line of the input file contains an integer T -- the number of test cases (no more than 5). T test cases follow, and each test case consists of two lines. The first of them contains three integers N, M and K (1 ≤ M ≤ N ≤ 50000, 1 ≤ K ≤ 20). The second of them contains N integers Ai (1 ≤ Ai ≤ 109).
 Output
 For each test case, output just one line containing the smallest possible total number of bought candies, or -1 if it's impossible to buy exactly M packs so that the total number of candies is divisible by K.
 Example
 
 Input:
 2
 5 3 5
 1 2 3 4 5
 6 3 4
 9 5 1 7 3 7
 
 Output:
 10
 -1
 
 Explanation:
 
 In the first test case, it's impossible to buy one candy per friend as three smallest packs contain 6 candies all together. Two candies per friend is possible though -- for example, if you buy packs with 1, 4 and 5 candies.
 In the second test case, buying 3 packs implies buying an odd number of candies, which is impossible to distribute equally among 4 friends.",BUYING,S3001593,PYTH,"dp[i][j] = min(dp[i-1][j], dp[i-1][j-A[i]] + A[i])

def min_candies(N, M, K, A):
    INF = float('inf')
    dp = [[INF] * ((M+1) * K + 1) for _ in range(M+1)]
    dp[0][0] = 0
    for i in range(1, M+1):
        for j in range(K):
            dp[i][j] = dp[i-1][j]
        for j in range(K, (M+1) * K + 1):
            dp[i][j] = min(dp[i-1][j], dp[i-1][j-A[i]] + A[i])
    for j in range(K, (M+1) * K + 1):
        if dp[M][j] % K == 0:
            return dp[M][j]
    return -1
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 Banknotes in the state of Strangeland don't have any regulated values like 1, 5, 10, 20, 50, 100, etc. In fact, it's possible to see any positive integer on a banknote of Strangeland. Indeed, this isn't the most convenient thing.
 Ann is working as a sweet seller at a shop in Strangeland. Every kind of sweets in this shop has its own cost, and sweets of the same kind have the same cost.
 Customers in Strangeland are strange. A customer points at some kind of sweets and gives several banknotes to the seller. This means that he wants to buy a positive number of sweets of that kind. He doesn't tell the exact number of sweets he wants to buy. The only thing Ann knows is: an 'adequate' customer won't give any extra banknotes. It means that if you throw away any banknote, the resulting amount of money won't be enough to buy the wanted number of sweets.
 Ann has to determine the number of sweets the customer wants. Help Ann write a program which determines this number or tells that it's impossible.
 Input
 The first line of the input contains a single integer T, the number of test cases (no more than 20). T test cases follow. Each test case consists of two lines. The first of these lines contains two integers N and X (1 ≤ N, X ≤ 100) separated by a single space. N is the number of banknotes given by the customer. X is the cost of a single sweet of the chosen kind. The second of these lines contains N space-separated integers Ai (1 ≤ Ai ≤ 100), the values of the banknotes.
 Output
 For each test case output exactly one line containing a single integer:
 
 -1 if the customer is inadequate and has given extra banknotes, or
 K, the number of sweets the customer wants to buy. If there are several possible answers, output the largest of them.
 
 Example
 
 Input:
 3
 4 7
 10 4 8 5
 1 10
 12
 2 10
 20 50
 
 Output:
 -1
 1
 7
 Explanation
 In the first test case, the total amount of money received from the customer is 27. He can't buy more than 3 sweets with this amount. If you throw away the banknote of value 5 (or of value 4), it will still be possible to buy 3 sweets. Hence the customer is inadequate.
 In the second test case, it's clear that he wants to buy just one sweet (note that this number should be positive).
 In the third test case, the total amount of money received is 70, which is enough for 7 sweets. The customer might want to buy only 6 sweets, but we are interested in the largest possible answer.",BUYING2,S1491539,PYTH,"function maximum_sweets(N, X, banknotes):
    total = 0
    sweets = 0
    for i in range(N - 1, -1, -1):
        total += banknotes[i]
        while total >= X:
            total -= X
            sweets += 1
    if total > 0:
        return -1
    return sweets

def maximum_sweets(N, X, banknotes):
    total = 0
    sweets = 0
    for i in range(N - 1, -1, -1):
        total += banknotes[i]
        while total >= X:
            total -= X
            sweets += 1
    if total > 0:
        return -1
    return sweets

T = int(input())
for _ in range(T):
    N, X = map(int, input().split())
    banknotes = list(map(int, input().split()))
    print(maximum_sweets(N, X, banknotes))
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese , Russian and Vietnamese
 Chef and his best friend Aleksa are into mathematical games these days. Today, they have some ( ≥ 0 ) black cells represented as B, and a white cell represented as W, lying randomly in a straight line.
 They have decided to play with these cells. In a move, a player chooses some ( > 0 ) black cells lying on any one side of the white cell and remove them. It should be noted that a player is not allowed to choose black cells from both side of the given white cell. Both the players alternate their moves, and play optimally. The player who is unable to move in his respective turn will lose the game.
 Aleksa, being a girl, has a habit of playing first. But Chef is fairly smart himself, and will not play the game if he is going to lose it. Therefore, he wants to know the winner beforehand. Can you tell him who is going to win the game for the given configuration of cells?
 Input
  First line of input contains a single integer T denoting the number of test cases. First and the only line of each test case contains a string S consisting of the characters 'B' and 'W', denoting black and white cells, respectively.
 Output
 For each test case, output ""Chef"" if chef wins the game for the given configuration. Else print ""Aleksa"". (quotes for clarity only).
 Constraints
 
 1 ≤ T ≤ 10
 1 ≤ |S| ≤ 10000
 S contains exactly 1 white cell.
 
 Scoring
 
  Subtask 1: 1 ≤ T ≤ 10, 1 ≤ |S| ≤ 10 : ( 30 pts )
  Subtask 2: 1 ≤ T ≤ 10, 1 ≤ |S| ≤ 100 : ( 30 pts )
  Subtask 3: 1 ≤ T ≤ 10, 1 ≤ |S| ≤ 10000 : ( 40 pts )
 
 Example
 
 Input
 3
 W
 BW
 BWBB
 
 Output
 Chef
 Aleksa
 Aleksa
 
  Explanation
 
  Test 1 : Aleksa cannot make a move in her first turn as there is no black cell in the given configuration.
  Test 2 : Aleksa can remove 1 black cell lying on the left of white cell in her turn. But then, Chef cannot make a move in his turn as there will be no black cells left.
  Test 3 : Figure out yourself.",BWCELL,S11655070,PYTH,"T = int(input())

for _ in range(T):
  s = input()
  left = s.find('W')
  right = len(s) - left - 1
  if left % 2 == 1 or right % 2 == 1:
    print(""Chef"")
  else:
    print(""Aleksa"")
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 
 How many ways are there to place a black and a white knight on an N * M chessboard such that they do not attack each other? The knights have to be placed on different squares. A knight can move two squares horizontally and one square vertically, or two squares vertically and one square horizontally. The knights attack each other if one can reach the other in one move.
 
 
 Input :
 
 
 The first line contains the number of test cases T. Each of the next T lines contains two integers N and M.
 
 
 Output :
 
 
 Output T lines, one for each test case, each containing the required answer for the corresponding test case.
 
 
 Sample Input :
 3
 2 2
 2 3
 4 5
 
 
 Sample Output :
 12
 26
 312
 
 
 Constraints :
 1 <= T <= 10000
 1 <= N,M <= 100000",BWKNIGHT,S10957290,PYTH,"dp[i][j] = (dp[i-1][j-2] + dp[i-2][j-1]) * 2 + (dp[i-1][j-1] + dp[i-2][j-2]) * 4

def ways_to_place(N, M):
    dp = [[0] * (M+1) for _ in range(N+1)]
    dp[1][1] = 0
    dp[2][2] = 6
    for i in range(2, N+1):
        for j in range(2, M+1):
            dp[i][j] = (dp[i-1][j-2] + dp[i-2][j-1]) * 2 + (dp[i-1][j-1] + dp[i-2][j-2]) * 4
    return dp[N][M]
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 This problem was part of the CodeChef April Challenge. All user submissions for this contest problem are publicly available here.
 The following a tie breaker problem. The best solution will receive one point. All other successful answers will be scored on a curve and receive a fraction of a point based on how close they come to the best answer.
 Let's have some fun with soap bubbles... We drive several sticks vertically into a flat surface (so that they look like points from above), and spread a thin film of soap over all of them. The soap film tends to minimize the area of its surface, and eventually becomes very thin, with surfaces turning into lines spread over all points. When everything has settled down, we can assume that the ""bubble"" we have is in fact a set of line segments, which connect all of our sticks into one network (possibly via some intermediate points which can also be the endpoints of lines).
 Input
 First, 1<=n<=1000, the number of starting points to connect. Then, n pairs of numbers follow, representing the coordinates of sticks which the soap film will connect.
 Output
 First, you should output the number m of intermediate points you create. Then, the next m pairs of numbers are coordinates of intermediate points.
 Then, you should output e, the number of soap-bubble lines you create. Then, the next 2*e numbers represent the indexes of points which are connected by the given line. Each index i should be a number 0<=i < n+m. If i < n, then it represents the i-th input point (stick). If i>=n, then it corresponds to the (i-n)-th intermediate point.
 Scoring
 
 Your goal is to minimize the score obtained in this problem.
 
 As longer lines tends to get thinner, for each line segment of length t, you will receive t / max(1, ln(t)) penalty points, where ""ln"" is the logarithm in the natural base.
 You will additionally receive ln(m+1) penalty points if your solution uses m intermediate points.
 
 If the soap film given at output does not span all the input points (connecting them into a network), your solution will be judged as incorrect.
 Example
 
 Input:
 3
 0.0 0.0
 0.0 3.0
 4.0 0.0
 
 Output:
 1
 1.0 1.0
 3
 0 3
 1 3
 2 3
 
 Score:
 7.090148",BX,S5302368,PYTH,"function minimum_score(n, points):
    # Sort the points by their x coordinate.
    points.sort(key=lambda point: point[0])

    # Initialize the list of intermediate points and lines.
    intermediate_points = []
    lines = []

    # Iterate over the points and connect them with lines.
    for i in range(n - 1):
        x1, y1 = points[i]
        x2, y2 = points[i + 1]
        distance = sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)
        if distance > 1:
            # If the distance between the points is greater than 1, we need to
            # add an intermediate point.
            x3 = (x1 + x2) / 2
            y3 = (y1 + y2) / 2
            intermediate_points.append((x3, y3))
            lines.append((i, n + len(intermediate_points) - 1))
            lines.append((i + 1, n + len(intermediate_points) - 1))
        else:
            # If the distance is less than or equal to 1, we can directly
            # connect the points with a line.
            lines.append((i, i + 1))
    return len(intermediate_points), intermediate_points, len(lines), lines

from math import sqrt

def minimum_score(n, points):
    # Sort the points by their x coordinate.
    points.sort(key=lambda point: point[0])

    # Initialize the list of intermediate points and lines.
    intermediate_points = []
    lines = []

    # Iterate over the points and connect them with lines.
    for i in range(n - 1):
        x1, y1 = points[i]
        x2, y2 = points[i + 1]
        distance = sqrt((x1 - x2) ** 2 + (
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 A long school holiday has come, and you decided to visit the famous Byte Island. You know there are only two types of Bytelandians: Byteknights and Byteknaves. A Byteknight always tells the truth, whereas a Byteknave always lies.
 It is known that there are N Bytelandians in the island, and now you meet all of them. You are curious about their types. Because you are a smart logician, you don't want to ask them questions that immediately reveal their types (that's too boring). Instead, to each Bytelandian you ask, ""How many Byteknights are there here?""
 To your surprise, they also don't answer your questions directly. Instead, the i-th Bytelandian answers of the form ""The number of Byteknights here is between ai and bi, inclusive"". You record all answers in your pocket note.
 Now that you have collected all information you need, determine the type of each Bytelandian.
 Input
 The first line contains a single integer T, the number of test cases. T test cases follow. The first line of each test case contains a single integer N. N lines follow. The i-th line contains two integers ai and bi.
 Output
 For each test case, output two lines. In the first line, output a single integer indicating the number of different solutions, modulo 1000000007. In the next line, output the lexicographically smallest solution. A solution is a string consisting of N characters, where the i-th character of the string is '1' if the i-th Bytelandian is a Byteknight, or '0' in case of a Byteknave. It is guaranteed that there is at least one valid solution.
 Example
 
 Input:
 3
 1
 0 1
 4
 1 4
 2 4
 3 4
 4 4
 3
 1 2
 0 0
 1 3
 
 Output:
 1
 1
 5
 0000
 1
 101
 Constraints
 
 1 <= T <= 5
 1 <= N <= 50000
 0 <= ai <= bi <= N",BYTEISLE,S1560067,PYTH,"for each test case:
    read N
    dp[0] = 0
    for i = 1 to N:
        read ai, bi
        dp[i] = infinity
        for k = ai to bi:
            dp[i] = min(dp[i], dp[i-k] + k)
    print 1
    for i = N downto 1:
        if dp[i] == dp[i-1]:
            print 0
        else:
            print 1
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 You are given a sequence w of integers. A mismatch is any such pair of neighbouring elements of sequence w[i] and w[i+1], that w[i]>w[i+1]+1.
 As long as there is any mismatch, you solve it by swapping the mismatching numbers. Given an input sequence, calculate one of the possible output mismatch-less sequences obtained by successively solving mistmatches by swapping.
 Input
 First - 1<=t<=10 - the number of tests. For each test: first - 1<=n<=100000. Then, n nonnegative integers.
 Output
 For each test, you should output exactly n integers.
 Example
 
 Input:
 2
 4
 4 3 2 1
 4
 4 3 1 2
 
 Output:
 4 3 2 1
 1 4 3 2",C1,S465172,PYTH,"def solve_mismatch(w):
    for i in range(len(w)-1):
        if w[i] > w[i+1]+1:
            w[i], w[i+1] = w[i+1], w[i]
            i -= 1
    return w
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 Let us calculate the sum of k-th powers of natural numbers from 1 to n. As the result can be quite large, output the result modulo some integer p.
 Input
 First t<=10 - the number of test cases.
 Each test case consist of numbers: 1<=n<=1000000000, 1<=k<=100, 1<=p<=1000000000.
 Output
 For each test case, output the value: (1k+2k+...+nk) mod p.
 Example
 For input:
 4
 10 1 1000000
 10 2 1000000
 10 3 1000000
 10 4 1000000
 the correct output is:
 55
 385
 3025
 25333",C2,S144087,PYTH,"1^k + 2^k + ... + n^k = (n^(k+1) - 1) / (n - 1)

t = int(input())
for _ in range(t):
    n, k, p = map(int, input().split())
    result = (n ** (k + 1) - 1) // (n - 1) % p
    print(result)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 In the magic land of Mathtopia, the words of the language are written only using two symbols: ones and zeros.
 
 A given word w is called ""prime"" if it cannot be written in the form of the concatenation of several copies of some shorter word. So, for example the words '100', '1100', and '001100' are prime, while the words '0101', '100100', '1111', and '101010' are not prime.
 Your task is to calculate the number of prime words which can be built from exactly a ones and b zeros.
 Input
 t - the number of test cases. For each test case, two integers: 1<=a<=109, 1<=b<=109.
 Output
 For each test case, output the required answer modulo 531169.
 Example
 
 Input:
 1
 2 2
 
 Output:
 4
 
 Explanation: the 4 words from the example are:
 '0011','1100','0110','1001'.",C3,S10050474,PYTH,"def solve(a, b):
  # Initialize the dp array with all zeros
  dp = [[0 for j in range(b+1)] for i in range(a+1)]
  # Set the base case dp[0][0] = 1
  dp[0][0] = 1
  # Iterate through all possible values of i and j
  for i in range(1, a+1):
    for j in range(1, b+1):
      # Iterate through all possible values of k
      for k in range(1, i+1):
        # If the shorter word of length k cannot be used to form a prime word, continue to the next value of k
        if dp[i-k][j-k] == 0:
          continue
        # Otherwise, add the value of dp[i-k][j-k] to dp[i][j]
        dp[i][j] = (dp[i][j] + dp[i-k][j-k]) % 531169
  # Return the final result
  return dp[a][b]
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 
 From the FAQ:
 
 What am I allowed to post as a comment for a problem?
 
 
 Do NOT post code.
 Do NOT post a comment asking why your solution is wrong.
 Do NOT post a comment asking if you can be given the test case your program fails on.
 Do NOT post a comment asking how your solution can be improved.
 Do NOT post a comment giving any hints or discussing approaches to the problem, or what type or speed of algorithm is required.
 
 
 Problem Statement
 
 Chef Doom has decided to bake a circular cake. He wants to place N colored cherries around the cake in a circular manner. As all great chefs do, Doom doesn't want any two adjacent cherries to have the same color. Chef has unlimited supply of cherries of K ≤ 10 different colors. Each color is denoted by the digit from the set {0, 1, ..., K – 1}. Different colors are denoted by different digits. Some of the cherries are already placed and the Chef wants you to place cherries in the remaining positions. He understands that there can be many such arrangements, so in the case when the answer is not unique he asks you to find the lexicographically smallest one.
 
 
 What does it mean?
 
 
 Let's numerate positions for the cherries by the numbers 1, 2, ..., N starting from one of the positions in a clockwise direction. Then the current (possibly partial) arrangement of the cherries can be represented by a string of N characters. For each position i of the arrangement if the cherry of the color C is placed at this position then the ith character of the string is equal to the digit C. Otherwise, it is equal to the question mark ?. We identify the arrangement with the string that represents it.
 
 
 One arrangement is called lexicographically smaller than the other arrangement if at the first position where they differ the first one has smaller digit (we compare only complete arrangements so we don't care about relation between digits and the question mark). For example, the arrangement 1230123 is lexicographically smaller than 1231230 since they have first 3 equal characters but the 4th character in the first arrangement is 0 and it is less than 1 which is the 4th character of the second arrangement.
 
 
 Notes
 
 
  The cherries at the first and the last positions are adjacent to each other (recall that we have a circular cake).
 
  In the case N = 1 any arrangement is valid as long as the color used for the only cherry of this arrangement is less than K.
 
  Initial arrangement can be already invalid (see the case 3 in the example).
 
 
 
 
 Just to make all things clear. You will be given a usual string of digits and question marks. Don't be confused by circular stuff we have in this problem. You don't have to rotate the answer once you have replaced all question marks by the digits. Think of the output like the usual string for which each two consecutive digits must be different but having additional condition that the first and the last digits must be also different (of course if N > 1).
 
 
 Next, you don't have to use all colors. The only important condition is that this string should be lexicographically smaller than all other strings that can be obtained from the input string by replacement of question marks by digits and of course it must satisfy conditions on adjacent digits.
 
 
 One more thing, K here is not the length of the string but the number of allowed colors. Also we emphasize that the given string can have arbitrary number of question marks. So it can have zero number of question marks as well as completely consists of question marks but of course in general situation it can have both digits and question marks.
 
 
 OK. Let's try to formalize things in order to make all even more clear. You will be given an integer K and a string S=S[1]S[2]...S[N] where each S[i] is either the decimal digit less than K or the question mark. We are serious. In all tests string S can have only digits less than K. Don't ask about what to do if we have digit ≥ K. There are no such tests at all! We guarantee this! OK, let's continue. Your task is to replace each question mark by some digit strictly less than K. If there were no question marks in the string skip this step. Now if N=1 then your string is already valid. For N > 1 it must satisfy the following N conditions S[1] ≠ S[2], S[2] ≠ S[3], ..., S[N-1] ≠ S[N], S[N] ≠ S[1]. Among all such valid strings that can be obtained by replacement of question marks you should choose lexicographically smallest one. I hope now the problem is really clear.
 
 
 Input
 
 The first line of the input file contains an integer T, the number of test cases. T test cases follow. Each test case consists of exactly two lines. The first line contains an integer K, the number of available colors for cherries. The second line contains a string S that represents the current arrangement of the cherries in the cake.
 
 Constraints
 1 ≤ T ≤ 1000
 1 ≤ K ≤ 10
 1 ≤ |S| ≤ 100, where |S| denotes the length of the string S
 Each character in S is either the digit from the set {0, 1, ..., K – 1} or the question mark ?
 Output
 
 For each test case output the lexicographically smallest valid arrangement of the cherries in the cake that can be obtained from the given arrangement by replacement of each question mark by some digit from 0 to K – 1. If it is impossible to place the cherries output NO (output is case sensitive).
 
 Example
 
 Input:
 7
 1
 ?
 2
 ?0
 10
 79259?087
 2
 ??
 3
 0?1
 4
 ?????
 3
 012
 
 Output:
 0
 10
 NO
 01
 021
 01012
 012
 Explanation
 
 Case 2. The only possible replacement here is 10. Note that we output 10 since we can not rotate the answer to obtain 01 which is smaller.
 
 
 Case 3. Arrangement is impossible because cherries at the first and the last positions are already of the same color. Note that K = 10 but the string has length 9. It is normal. K and |S| don't have any connection.
 
 
 Case 4. There are two possible arrangements: 01 and 10. The answer is the first one since it is lexicographically smaller.
 
 
 Case 5. There are three possible ways to replace question mark by the digit: 001, 011 and 021. But the first and the second strings are not valid arrangements as in both of them there exists an adjacent pair of cherries having the same color. Hence the answer is the third string.
 
 
 Case 6. Note that here we do not use all colors. We just find the lexicographically smallest string that satisfies condition on adjacent digit.
 
 
 Case 7. The string is already valid arrangement of digits. Hence we simply print the same string to the output.",CAKEDOOM,S1123304,PYTH,"def solve_cake(K, S):
    # replace question marks at the beginning and end with the smallest available digit
    if S[0] == ""?"":
        S[0] = ""0""
    if S[-1] == ""?"":
        S[-1] = ""0""
    # replace the remaining question marks with the smallest available digit
    # that is different from the previous and the next digit
    for i in range(1, len(S)-1):
        if S[i] == ""?"":
            for j in range(K):
                if str(j) != S[i-1] and str(j) != S[i+1]:
                    S[i] = str(j)
                    break
    return S
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 The chef is a fan of candies with chocolate and caramel, and has devoted much of his life
 to finding the perfect ratio of chocolate to caramel.
 He recently discovered the perfect ratio, but to his dismay,
 none of his favourite candy shoppes sell candies with exactly that ratio.
 So the chef crafted a plan to buy several candies, and melt them together into a larger candy
 so that the resulting candy will have the perfect ratio.
 How many candies will he have to buy?
 The chef may buy multiple candies of the same type.
 
 Input:
 Input begins with an integer N,
 the number of different candies available at the various shoppes.
 N lines follow, each containing 2 integers Chocolatei and Carameli indicating the grams of chocolate and caramel,
 respectively, contained in the (i)th candy.
 Finally, there is a line containing 2 integers desiredChocolate and desiredCaramel, indicating the chef's desired ratio of
 chocolate to caramel.
 Output:
 For each test case, output on a single line the minimum number of candies the chef will have to buy.
 If it is impossible to produce a candy with the desired ratio, output -1 instead.
 Example
 Input 1:
 3
 4 5
 2 4
 4 1
 1 1
  
 Output 1:
 3
  
 In this example, the chef purchases one of each candy and combines them to form a candy with 8 grams chocolate and 8 grams caramel.
 Input 2:
 3
 2 3
 4 6
 10 15
 5 8
  
 Output 2:
 -1
  
 Constraints:
 1 ≤ N ≤ 15
 1 ≤ Chocolatei ≤ 500
 1 ≤ Carameli ≤ 500
 1 ≤ desiredChocolate ≤ 500
 1 ≤ desiredCaramel ≤ 500
 For all candies, Chocolatei/Carameli ≠ desiredChocolate/desiredCaramel
 No two candies will be identical.",CANDY,S359793,PYTH,"import itertools

def solve(candies, desired):
    for i in range(1, len(candies) + 1):
        for combination in itertools.combinations(candies, i):
            chocolate = sum(c[0] for c in combination)
            caramel = sum(c[1] for c in combination)
            if chocolate * desired[1] == caramel * desired[0]:
                print(i)
                return
    print(-1)

t = int(input())
for _ in range(t):
    n = int(input())
    candies = []
    for _ in range(n):
        candies.append(tuple(map(int, input().split())))
    desired = tuple(map(int, input().split()))
    solve(candies, desired)
",,,,,,,,,,,,,,,,,,,,,
"function formatTime(ts) {
  now = new Date(ts);
 
  localtime = new Date();
  hour = now.getHours();
  min = now.getMinutes();
  sec = now.getSeconds();
 
  if (min <= 9) {
  min = ""0"" + min;
  }
  if (sec <= 9) {
  sec = ""0"" + sec;
  }
  if (hour > 12) {
  hour = hour - 12;
  add = "" PM"";
  } else {
  hour = hour;
  add = "" AM"";
  }
  if (hour == 12) {
  add = "" PM"";
  }
  if (hour == 00) {
  hour = ""12"";
  }
 
  $('#server-time').html(((hour<=9) ? ""0"" + hour : hour) + "":"" + min + "":"" + sec + add);
 
  nextSec = (now.getTime() + 1000);
 
  setTimeout(""formatTime(""+nextSec+"")"", 1000);
  }
  function getDtTimeZone()
  {
  var rightNow = new Date();
  var toDay = new Date(rightNow.getFullYear(), 0, 1, 0, 0, 0, 0);
  var temp = toDay.toGMTString();
  var date2 = new Date(temp.substring(0, temp.lastIndexOf("" "") -1));
  var stdTime = (toDay - date2) / (1000 * 60 * 60);
  return stdTime;
  }
 /*var d=new Date();
 $.ajax({
 url: '/umtza',
 type:'POST',
 data: 'umtza='+d.toString(),
 });
 */
 
 CodeChef is a non-commercial competitive programming community
 
 
 
 
 About CodeChef
 About Directi
 CEO's Corner
 C-Programming
 Programming Languages
 Contact Us
 
 
 © 2009 Directi Group. All Rights Reserved. CodeChef uses SPOJ © by Sphere Research Labs
 In order to report copyright violations of any kind, send in an email to copyright@codechef.com
 
 
 
 The time now is: 
 
  formatTime('September 01, 2014 16:46:08');
  
 
 
 
 
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-53602-42']);
  _gaq.push(['_trackPageview']);
 
  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
 
  
 
 
  /* <![CDATA[ */
  var google_conversion_id = 1066618556;
  var google_conversion_language = ""en"";
  var google_conversion_format = ""3"";
  var google_conversion_color = ""666666"";
  var google_conversion_label = ""gbUUCPTlhAIQvJ3N_AM"";
  var google_conversion_value = 0;
  /* ]]> */
  
 
 
 
 
 
 
 
 
 
  /* <![CDATA[ */
  var google_conversion_id = 968176136;
  var google_conversion_language = ""en"";
  var google_conversion_format = ""3"";
  var google_conversion_color = ""ffffff"";
  var google_conversion_label = ""iDk7CPDZ7wMQiOTUzQM"";
  var google_conversion_value = 0;
  /* ]]> */
  
 
 
 
 
 
 
 
 
 CodeChef - A Platform for Aspiring Programmers
 CodeChef was created as a platform to help programmers make it big in the world of algorithms, computer programming and programming contests. At CodeChef we work hard to revive the geek in you by hosting a programming contest at the start of the month and another smaller programming challenge in the middle of the month. We also aim to have training sessions and discussions related to algorithms, binary search, technicalities like array size and the likes. Apart from providing a platform for programming competitions, CodeChef also has various algorithm tutorials and forum discussions to help those who are new to the world of computer programming.
 
 Practice Section - A Place to hone your 'Computer Programming Skills'
 Try your hand at one of our many practice problems and submit your solution in a language of your choice. Our programming contest judge accepts solutions in over 35+ programming languages. Preparing for coding contests were never this much fun! Receive points, and move up through the CodeChef ranks. Use our practice section to better prepare yourself for the multiple programming challenges that take place through-out the month on CodeChef. 
 
 Compete - Monthly Programming Contests and Cook-offs
 Here is where you can show off your computer programming skills. Take part in our 10 day long monthly coding contest and the shorter format Cook-off coding contest. Put yourself up for recognition and win great prizes. Our programming contests have prizes worth up to Rs.20,000 and $700lots more CodeChef goodies up for grabs. 
 
 Discuss
 Are you new to computer programming? Do you need help with algorithms? Then be a part of CodeChef's Forums and interact with all our programmers - they love helping out other programmers and sharing their ideas. Have discussions around binary search, array size, branch-and-bound, Dijkstra's algorithm, Encryption algorithm and more by visiting the CodeChef Forums and Wiki section.
 
 CodeChef Community
 As part of our Educational initiative, we give institutes the opportunity to associate with CodeChef in the form of Campus Chapters. Hosting online programming competitions is not the only feature on CodeChef. You can also host a coding contest for your institute on CodeChef, organize an algorithm event and be a guest author on our blog. 
 
 Go For Gold
 The Go for Gold Initiative was launched about a year after CodeChef was incepted, to help prepare Indian students for the ACM ICPC World Finals competition. In the run up to the ACM ICPC competition, the Go for Gold initiative uses CodeChef as a platform to train students for the ACM ICPC competition via multiple warm up contests. As an added incentive the Go for Gold initiative is also offering over Rs.8 lacs to the Indian team that beats the 29th position at the ACM ICPC world finals. Find out more about the Go for Gold and the ACM ICPC competition here.",CAOS1,S10990080,PYTH,"def solve():
  T = int(input())
  for _ in range(T):
    N, M, Z, L, R, B = map(int, input().split())
    attendance = 0
    for _ in range(N):
      both_seats = B // N
      one_seats = (L + R) // N
      none_seats = Z // N
      seats = both_seats + one_seats + none_seats
      attendance += seats
      B -= both_seats * N
      L -= one_seats * N
      R -= one_seats * N
      Z -= none_seats * N
    max_attendance += attendance
  print(max_attendance)

solve()
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 Chef loves to prepare delicious dishes. This time, Chef has decided to prepare a special dish for you, and needs to gather several apples to do so.
 Chef has N apple trees in his home garden. Each tree has a certain (non-zero) number of apples on it. In order to create his dish, Chef wants to pluck every apple from every tree.
 Chef has an unusual method of collecting apples. In a single minute, he can perform the following task:
 
 Pick any subset of trees such that every tree in the subset has the same number of apples.
 From each tree in the subset, pluck any number of apples, as long as the number of apples left on the tree equals the number of apples on a tree not in the subset.
 
 If all trees have the same number of apples left, Chef can pluck all of the apples remaining in a single minute.
 Chef does not want to keep you waiting, so wants to achieve this task in the minimum possible time. Can you tell him what the minimum time required is?
 Input
 The first line of the input contains a single integer T denoting the number of test cases. This will be followed by T test cases. The first line of each test case contains a single integer N denoting the number of apple trees in Chef's garden. The next line of each test case contains N space separated integers denoting the number of apples on each tree.
 Output
 For each of the T test cases, output a single line - the minimum time to pluck all apples from all trees.
 Constraints
 
 1 <= T <= 10
 1 <= N <= 105
 1 <= Number of apples on a tree <= 105
 
 Scoring
 
 Subtask 1 : 1 <= T <= 10 , 1 <= N <= 103: (27 pts) 
 Subtask 2 : 1 <= T <= 10 , 1 <= N <= 104: (25 pts) 
 Subtask 3 : 1 <= T <= 10 , 1 <= N <= 105: (48 pts) 
 
 Example
 
 Input
 2
 3
 3 3 3
 4
 1 2 3 3
 
 Output
 1
 3
 Explanation
 For test 1, Chef can select all the trees and can pluck all the apples in 1 minute.
 For test 2, there are many ways Chef can pluck all of the apples in 3 minutes. Here is one example: 
 
 First minute: Select the third and fourth trees. Pluck 1 apple from the third tree, and 2 apples from the fourth tree.
 Second minute: Select the second and third tree. Pluck 1 apple from each tree.
 Third minute: Select all of the trees and pluck the last apple from each tree.",CAPPLE,S10535911,PYTH,"# Read the input
T = int(input())
for _ in range(T):
    # Read the number of trees
    N = int(input())

    # Create a dictionary to store the number of trees for each number of apples
    tree_count = {}

    # Read the number of apples for each tree
    for i in range(N):
        apples = int(input())
        if apples in tree_count:
            tree_count[apples] += 1
        else:
            tree_count[apples] = 1

    # Find the minimum time required by counting the number of keys in the dictionary
    min_time = len(tree_count)

    # Print the minimum time required
    print(min_time)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 Chef is organizing an online card game tournament and for this purpose he has to provide a card shuffling software. This software has to simulate the following shuffling process. A stack of N cards is placed face down on the table. Cards in the stack are ordered by value. Topmost card has value 1 and the one on the bottom has value N. To shuffle the cards we repeat the following steps M times:
 
 take A cards from the top of the deck.
 take another B cards from the top of the deck.
 put the A cards, which you removed in the first step, back on top of the remaining deck.
 take C cards from the deck
 put the B cards, which you're still holding from the second move, card by card on top of the deck.
 finally, return the block of C cards on top
 
 Note: taking a block of cards from the top of the deck does not change their order. The entire block is removed in a single move and not card by card. The only exception is the fifth move, where you return cards one by one from the top.
 Input
 The first line contains integers N and M. The following M lines describe the moves by integers Ai, Bi, Ci as described in the previous section.
 
 In the spirit of random card shuffling, all test cases were generated with uniform random distributions to select where to cut the deck of cards.
 Output
 In a single line output the cards in the deck after performing all the moves. Cards should be listed from top of the deck to bottom and separated by spaces.
 Constraints
 
 1 <= N, M <= 100 000
 
 Example
 
 Input:
 10 2
 6 2 2
 5 3 6
 
 Output:
 1 2 8 7 3 9 6 5 4 10",CARDSHUF,S808230,PYTH,"#parse input
N, M = map(int, input().split())
deck = list(range(1, N+1))
moves = []
for i in range(M):
    A, B, C = map(int, input().split())
    moves.append((A, B, C))

#simulate shuffling process
for move in moves:
    A, B, C = move
    top_a = deck[:A]
    top_b = deck[A:A+B]
    rest = deck[A+B:]
    deck = top_a + rest
    deck = top_b + deck
    top_c = deck[:C]
    rest = deck[C:]
    deck = rest + top_c

#print shuffled deck
print(' '.join(map(str, deck)))
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 Most problems on CodeChef highlight chef's love for food and cooking but little is known about his love for racing sports. He is an avid Formula 1 fan. He went to watch this year's Indian Grand Prix at New Delhi. He noticed that one segment of the circuit was a long straight road. It was impossible for a car to overtake other cars on this segment. Therefore, a car had to lower down its speed if there was a slower car in front of it. While watching the race, Chef started to wonder how many cars were moving at their maximum speed.
 Formally, you're given the maximum speed of N cars in the order they entered the long straight segment of the circuit. Each car prefers to move at its maximum speed. If that's not possible because of the front car being slow, it might have to lower its speed. It still moves at the fastest possible speed while avoiding any collisions. For the purpose of this problem, you can assume that the straight segment is infinitely long.
 Count the number of cars which were moving at their maximum speed on the straight segment.
 Input
 The first line of the input contains a single integer T denoting the number of test cases to follow. Description of each test case contains 2 lines. The first of these lines contain a single integer N, the number of cars. The second line contains N space separated integers, denoting the maximum speed of the cars in the order they entered the long straight segment.
 Output
 For each test case, output a single line containing the number of cars which were moving at their maximum speed on the segment.
 Example
 
 Input:
 3
 1
 10
 3
 8 3 6
 5
 4 5 1 2 3
 
 Output:
 1
 2
 2
 Constraints
 
 1 ≤ T ≤ 100
 1 ≤ N ≤ 10,000
 All speeds are distinct positive integers that fit in a 32 bit signed integer.
 Each input file will not be larger than 4 MB (4,000,000,000 bytes) in size.
 
 WARNING! The input files are very large. Use faster I/O.",CARVANS,S10107156,PYTH,"# Read the input
T = int(input())
for _ in range(T):
    # Read the number of prime powers
    m = int(input())

    # Initialize the value of N
    N = 1

    # Calculate the value of N as the product of the prime powers
    for i in range(m):
        p, k = map(int, input().split())
        N *= p**k

    # Initialize a counter
    X = 1

    # Calculate the value of NX
    NX = N
    while NX != 1:
        NX = math.euler_phi(NX)
        X += 1

    # Print the result
    print(X)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 Recently Chef has decided to make some changes in our beloved Codechef. As you know, each problem at Codechef has its memory and time limits. To make problems even more challenging, he decided to measure allocated memory in a different way. Now judge program will be calculating not the maximum memory usage during the execution of all test files, but all the memory ever allocated by the solution program. But as Chef is not that good in algorithms, so he asks you to write a program that will calculate total memory usage of a solution.
 So, you are given N numbers M1, , ,MN representing the measurements of consumed memory (in MBs) for N test files. In other terms, it means that on i-th test file, program took Mi MBs of memory. Initially, there is no memory allocated for your program. Before running your program on each test file, if the currently allocated memory is more than memory needed for the current test file, then there will be a deallocation of the memory to fit the current program. Also, if there is less than needed memory available, then allocation of memory will happen so as to fit the current program. e.g. Let us say that our program took 10 MBs on current test file. So, assuming if there was 12 MBs memory allocated before running the program on current test file, then there will happen a deallocation of 2 MBs. Assuming if there was 8 MBs memory allocated before running the program on current test file, then there will happen a allocation of 2 MBs.
 
 
 Calculate the total memory allocated for running the solution program on all the N test files. Please see third sample for more clarity.
 Input
 First line of input contains a single integer T denoting the number of test cases. First line of each test case contains a single integer N denoting the number of measurements. Second line of each test case contains N space separated integers, where ith integer denotes the consumption of memory for ith i-th test file.
 Output
 For each test case, print total memory allocated for running the solution program.
 Constraints
 
 1 ≤ T ≤ 105
 1 ≤ N ≤ 105
 1 ≤ Mi ≤ 109
  sum of N over all test cases does not exceed 105
 
 Subtasks
 
 Subtask 1 (30 points):
 
 1 ≤ T ≤ 100
 1 ≤ N ≤ 100
 1 ≤ Mi ≤ 100
 
 
 Subtask 3 (70 points): 
 
 Original constraints.
 
 
 Example
 Input:
 3
 2
 1 1
 5
 1 2 3 4 5
 3
 1 3 2
 
 Output:
 1
 5
 3
 Explanation
 Example case 1. Initially, there was no memory allocated. For running first test file, there was a memory allocation of 1 MBs. There was no allocation/ deallocation for running your program on second test file. 
 Example case 2. On running on each test file, there was a further allocation of 1 MBs from previous one. So, there are total 5 MBs of memory allocated while running the program.
 Example case 3. Initially, there was no memory allocated. For running first test file, there was a memory allocation of 1 MBs. For running second test file, there was a further memory allocation of 2 MBs to have 3 MBs of memory needed, then in the last file, there was a deallocation of 1 MB of memory so as to get 2 MBs of memory needed for running the program. So, overall, there was 1 + 2 = 3 MBs of memory ever allocated in the program. Note that we are only counting allocated memory, not allocated + unallocated.",CBARG,S7233815,PYTH,"if m > max_memory:
    max_memory = m

for each test case:
    max_memory = 0
    read N
    for i = 1 to N:
        read m
        if m > max_memory:
            max_memory = m
    print max_memory
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 
 A few days ago Chef decided to cook a new dish – chocolate. This must be something amazing. The idea is that chocolate bar will be divided into cells. It must be long, but narrow. To interest customers every bar must be unique. Bar will consist of cells of black or white chocolate. In addition every bar must be good looking. It means that the bar must not contain any totally white or totally black rectangle, whose width and length are more than 1 (Note that a bar is good if (width > 1 and length = 1) or (length > 1 and width = 1)). Now, Chef wants to know how many bars can he cook? He’s not good in computer programming, so this task is for you.
  By the way, it's not permitted to rorate bars. It means that WBB and BBW are different bars.
 Input
 
 Input contains two integers: width a (1 ≤ a ≤ 6) and length b (1 ≤ b < 263).
 Output
 
 Print in output a single integer which is the answer. Answer can be a very big number, so print it modulo 109+7 (1000000007).
 Example
 
 Input:
 2 2
 
 Output:
 14
 
 Input:
 3 3
 
 Output:
 322
 Explanation
 
 In the first sample, there are 2^(2*2) = 16 ways coloring the chocolate in total, and the only following 2 chocolates are not good
 
 
 WW
 WW
 The bar contains a totally white rectangle of length = 2 and width = 2.
 
 BB
 BB
 The bar contains a totally black rectangle of length = 2 and width = 2.",CBARS,S1553776,PYTH,"dp[1][1] = 2

dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]

#include <iostream>

using namespace std;

const int MOD = 1000000007;

int main() {
    int a, b;
    cin >> a >> b;

    long long dp[7][263];
    dp[1][1] = 2;

    for (int i = 1; i <= a; i++) {
        for (int j = 1; j <= b; j++) {
            if (i > 1 || j > 1) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];
                dp[i][j] %= MOD;
            }
        }
    }

    cout << dp[a][b] << endl;

    return 0;
}
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
 
 Devu has n weird friends. Its his birthday today, so they thought that this is the best occasion for testing their friendship with him. They put up conditions before Devu that they will break the friendship unless he gives them a grand party on their chosen day. Formally, ith friend will break his friendship if he does not receive a grand party on dith day.
 
 
 Devu despite being as rich as Gatsby, is quite frugal and can give at most one grand party daily. Also, he wants to invite only one person in a party. So he just wonders what is the maximum number of friendships he can save. Please help Devu in this tough task !!
 
 Input
 
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
 First line will contain a single integer denoting n.
 Second line will contain n space separated integers where ith integer corresponds to the day dith as given in the problem.
 
 Output
 Print a single line corresponding to the answer of the problem.
 Constraints
 
 1 ≤ T ≤ 104
 1 ≤ n ≤ 50
 1 ≤ di ≤ 100
 
 Example
 Input:
 2
 2
 3 2
 2
 1 1
 Output:
 2
 1
 
 Explanation
 Example case 1. Devu can give party to second friend on day 2 and first friend on day 3, so he can save both his friendships.
 Example case 2. Both the friends want a party on day 1, and as the Devu can not afford more than one party a day, so he can save only one of the friendships, so answer is 1.",CFRTEST,S10154207,PYTH,"T = int(input())

for _ in range(T):
    n = int(input())
    days = list(map(int, input().split()))
    days.sort()
    count = 0
    planned_parties = set()
    for day in days:
        if day not in planned_parties:
            planned_parties.add(day)
            count += 1
    print(count)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 Chef is an advocate for Go Green Initiative. Today he had n trees planted in a row outside his his restaurant. Today, the height of i-th tree is hi feet. The trees grow at a rate of mi feet per day.
 Chef knows that trees will look beautiful if they form a zig-zag sequence. The trees will be said to be in Zig-zag sequence if the heights of tree first increases or decreases, then alternates between decreasing/increasing respectively. Formally, the trees will be said to in Zig-zag sequence if one of the following two conditions holds.
 
 
 h1 < h2 > h3 < h4 and so on..
 h1 > h2 < h3 > h4 and so on..
 
 
 Chef wants to know intervals of time when the heights of the trees will form a zig-zag sequence.
 Input
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
 The first line of each test case contains a single integer n, denoting the number of trees.
 The ith of following N lines contains two space separated integers hi and mi, denoting the initial height and the growth speed for ith tree.
 
 Output
 For each test case, output an integer Q - the amount of the periods of consecutive moments of time, when the trees for a zig-zag sequence.
 On the following Q lines, output the intervals of time when the trees' heights form a zig-zag sequence. For each intervals, output its' smallest and the largest instants of time. If the range is infinite, output Inf as the right bound.
 The test cases are designed in such a way that the total output won't exceed 2 MB.
 Constraints
 
 
 1 ≤ T ≤ 105
 1 ≤ n ≤ 10
 Subtask 1 (23 points): 0 ≤ hi, mi ≤ 10
 Subtask 2 (77 points): 0 ≤ hi, mi ≤ 109
 1 ≤ sum of n over a test cases in a single test file ≤ 5 × 105
 
 
 Example
 Input:
 3
 3
 0 1
 2 2
 0 3
 2
 2 1
 1 2
 3
 1 1
 2 2
 3 3
 
 Output:
 1
 0 1
 2
 0 0
 2 Inf
 0
 
 Explanation
 Example case 1. In the first case 0 2 0 is already a zig-zag sequence, but on the 2nd second it will become 2 6 6 and will never turn back into zig-zag",CHAHG,S11237504,PYTH,"#parse input
T = int(input())
test_cases = []
for i in range(T):
    N = int(input())
    trees = []
    for j in range(N):
        h, m = map(int, input().split())
        trees.append((h, m))
    test_cases.append((N, trees))

#iterate through test cases
for test_case in test_cases:
    N, trees = test_case
    Q = 0
    intervals = []
    #iterate through trees
    for i in range(1, N):
        prev_h, prev_m = trees[i-1]
        h, m = trees[i]
        if i % 2 == 1:
            #check for decreasing sequence
            if h < prev_h:
                #compute interval of time
                t1 = (prev_h - h) / (m - prev_m)
                t2 = float('inf')
                intervals.append((t1, t2))
                Q += 1
        else:
            #check for increasing sequence
            if h > prev_h:
                #compute interval of time
                t1 = (h - prev_h) / (m - prev_m)
                t2 = float('inf')
                intervals.append((t1, t2))
                Q += 1
    print(Q)
    for interval in intervals:
        print(interval[0], interval[1])
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 Chef has recently discovered a weakness in the password verification system on a network of servers, and has enlisted your help in determining the practicality of an attack. Chef discovered that if he simultaneously sends password guesses to all servers, he can measure the response time to determine how accurately the guesses were. Some of the servers in the network are ""honeypot"" servers that accept password guesses but cannot be accessed. Chef does not know which servers are honeypots, but he knows how many there are.
 Each server has a password consisting of between 8 and 12 lowercase alphabetic characters. There is also a ""salt"" string which is 8 characters long. When a password guess comes to a server, the password guess is appended with the salt string, and then hashed with the SHA1 hashing algorithm. (Most of the details of the SHA1 hashing algorithm are not relevant to this problem, other than the fact that it has an output size of 160 bits, each of which equally likely to be 0 or 1.) The result is compared to the SHA1 hash of the actual password appended with the salt string. Chef is able to calculate the sum of the squares of the number of matching bits on each non-honeypot server (after all, the honeypot servers don't give any feedback). This sum is denoted the ""score"" of a guess.
 There is a limit on the number of password guesses Chef can make. Chef would like you to make password guesses, and try to attain a high guess score.
 Input + Output
 Input will begin with a line containing three integers: T, the number of password guesses to perform, N, the total number of servers, and H, the number of honeypot servers. After reading T, N, and H, repeat the following procedure T times.
 Print a password guess, consisting of N lowercase alphabetic strings of length between 8 and 12. Make sure to print a newline and flush the output buffer after printing the last string. Then read a line containing a single integer S, the score of the guess.
 Attention: the program should clear the output buffer after printing each guess. It can be done using fflush(stdout) command or by setting the proper type of buffering at the beginning of the execution - setlinebuf(stdout). Failure to flush the output buffer will result in Time Limit Exceeded verdict.
 Scoring
 Your score will be the highest score across all password guesses, divided by N-H.
 The goal is to maximise this score.
 Sample Input + Output
 
 In: 4 3 1
 Out: applepie
 Out: berrypie
 Out: cherrypie
 In: 12186
 Out: bananapie
 Out: custardpie
 Out: lemonpie
 In: 13466
 Out: keylimepie
 Out: pecanpie
 Out: blueberrypie
 In: 7785
 Out: chocolatepie
 Out: custardpie
 Out: peachpie
 In: 10517
 
 Explanation
 The salt is ""codechef"". The first server's password is ""challenge"". The second server is the honeypot, and the third server's password is ""maythirteen"". On the first guess, the hash of ""applepiecodechef"" is compared to the hash of ""challengecodechef"" and the hash of ""cherrypiecodechef"" is compared to the hash of ""maythirteencodechef"". The hash of ""applepiecodechef"" is ""EC70A4442061F08180BDD0E1A4BD8284C5C72978"", and the hash of ""challengecodechef"" is ""4DE646F7F99F2735957070C9D49F1DA6960A8DD1"". The hashes share 81 bits. On the third server, the hashes share 75 bits. Thus the first guess scores 81*81+75*75 = 12186.
 The best score across all 4 guesses is 13466, therefore this sample would score 13466/(3-1) = 6733.
 Test Case Generation
 T is chosen randomly and uniformly between 250 and 2000. N is chosen randomly and uniformly between 50 and 200. H is chosen randomly and uniformly between max(N-50,N/2) and N-10, inclusive. The salt and each of the N-H password strings are generated by first randomly choosing a length L between 8 and 12, and then choosing L random lowercase alphabetic characters. Each of the N-H password strings is assigned to a random server, ensuring no server is assigned multiple passwords. The remaining H servers become honeypot servers.
 Note: The test data is not guaranteed to be the same across multiple submissions, however T, N, and H will be the same across all submissions.",CHALENGE,S2299299,PYTH,"import random

# Read input
T, N, H = map(int, input().split())

# Initialize best score
best_score = 0

# Loop through password guesses
for i in range(T):
  # Generate random password guess
  guess = [''.join(random.choices(string.ascii_lowercase, k=random.randint(8, 12))) for _ in range(N)]
  
  # Print password guess
  print(' '.join(guess))
  sys.stdout.flush()
  
  # Read score of guess
  score = int(input())
  
  # Update best score if necessary
  best_score = max(best_score, score)

# Print best score
print(best_score / (N - H))
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.
 Problem description.
  Chef became the problem writer of ACM/ICPC regional contest this year. One week before the contest, Chef came up with an interesting idea, and wrote the following problem : 
  Given N integers A1, A2, ..., An, print YES (or NO) if there exists (or not) 3 numbers that form an arithmetic sequence. All integers are between 0 and 99999 (inclusive).
  As Chef expected, during the contest, most teams cannot figure out an efficient algorithm to solve it. But in the last minute of the contest, judges get one 10-lines submission, which is judged as correct. The short solution works as follows, if N > 2000, output YES, otherwise brute-force it. 
  Chef felt extremely disappointed, and he/she believed that the solution is definitely wrong. Chef is now interested in how to challenge the submission. 
  Chef needs your help. Chef would like you to find a set of integers, such that no 3 integers form an arithmetic sequence. To make the task more challenging, you are given a list of M integers B1, B2, ..., BM. You can only use integers from this list. The set does not require maximality, but larger sets will score more points.
 Input
  The first line of the input contains an integer M denoting the length of the list. The second line contains M space-separated integers B1, B2, ..., BM denoting the list.
 Output
 First output the integer N on the first line. Then output N integers A1, A2, ..., AN on the second line.
 Constraints
 
 1 ≤ M ≤ 100000
 0 ≤ Bi < 100000 for each 1 ≤ i ≤ M
 
 Scoring
 Your score for each test file is 100*N/M. Your overall score is the average of your scores on the individual test files. The goal is to maximize your score.
 Example
 Input:
 10
 1 2 3 4 5 6 7 8 9 10
 
 Output:
 4
 1 4 6 9
 
 Explanation
 This sample output would score 100*4/10=40.
 Test Generation
  We have 50 official test cases, each of them is created as follows:
 An integer L is chosen from [10000, 100000] uniformly at random. An real value p is chosen from [0.1, 0.9] uniformly at random. Then each number x from [0, L - 1], x is added into the list with probability p, independently. Regenerate the list if it's empty.",CHAORNOT,S9726870,PYTH,"def find_non_arithmetic_sequence(list):
  while True:
    # choose three random integers from the list
    int1, int2, int3 = choose_random_integers(list)
    
    # check if they form an arithmetic sequence
    if (int2 - int1 == int3 - int2):
      # remove one of the integers and try again
      list.remove(int2)
    else:
      # we found a set of integers that do not form an arithmetic sequence
      return [int1, int2, int3]

# choose three random integers from the list
def choose_random_integers(list):
  int1 = choose_random_integer(list)
  int2 = choose_random_integer(list)
  int3 = choose_random_integer(list)
  return [int1, int2, int3]

# choose a random integer from the list
def choose_random_integer(list):
  index = random.randint(0, len(list) - 1)
  return list[index]

import random

# find a set of integers that do not form an arithmetic sequence
def find_non_arithmetic_sequence(list):
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 Today Chef wants to clean his garden. Chef has N columns of ground. Each column has it's height . Chef can choose any column and increase its height by 1 using 1 cube of ground. 
 Chef wants to spend exactly M cubes. Can he make this in such way that the heights of all columns will become equal? 
 Input
 
  First line of input contains an integer T denoting number of test cases.
 Then for each test case, The first line contains two integers N and M. 
 The second line contains N space-separated integers A1, A2, ..., AN denoting the initial heights of the columns"". 
 
 Output
 
 If Chef can spend all cubes and make the columns equal print Yes else print No. 
 
 Constraints
 
 1 ≤ T ≤ 10^2
 1 ≤ N ≤ 10^2
 1 ≤ Ai ≤ 10^2
 0 ≤ M ≤ 10^4
 
 Example
 Input:
 3
 5 7
 3 3 4 2 1
 5 6
 3 3 4 2 1
 5 8
 3 3 4 2 1
 
 Output:
 Yes
 No
 No
 Explanation
 In the first case we can put cubes on columns in such count: 1, 1, 0, 2, 3. The sum equals M.
 In the second case we can't make the columns equal as we will receive something like 44443.
 In the third case we can make all columns equal but we will still have one cube extra, By using that cube, our heights of columns will become 44445.",CHEFGR,S5147767,PYTH,"# Read the number of test cases
t = int(input())

# Process each test case
for _ in range(t):
  # Read the number of columns and the number of cubes
  n, m = map(int, input().split())

  # Read the initial heights of the columns
  heights = list(map(int, input().split()))

  # Calculate the minimum height of the columns
  min_height = min(heights)

  # Calculate the total number of cubes needed to raise the other columns to the minimum height
  total_cubes = sum(h - min_height for h in heights)

  # Check if we have enough cubes
  if total_cubes <= m:
    print(""Yes"")
  else:
    print(""No"")
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian as well.
 Chef has bought ten balls of five colours. There are two balls of each colour. Balls of same colour have same weight. Let us enumerate colours by numbers from 1 to 5. Chef knows that all balls, except two (of same colour), weigh exactly one kilogram. He also knows that each of these two balls is exactly 1 kg heavier than other balls.
 
 You need to find the colour which balls are heavier than others. 
 To do that, you can use mechanical scales with two weighing pans. As your scales are very accurate, you can know the exact difference of weights of objects from first and second pans. Formally, the scales will give you the difference (signed difference) of weights of the objects put into the first pan and the second pan. See the following examples for details.
 
 If you put two balls of the same colour on your scales, each ball to one pan, the scales will tell you that difference is ""0"".
 But if you put into the first pan some balls of total weight 3 kg, and into the second pan of 5 kg, then scales will tell you ""-2"" because the second pan is 2 kg heavier than first. 
 Similarly, if you put 5 kg weight in first pan and 3 kg in the second pan, then scale will tell you ""2"" as first pan is 2 kg heavier than second.
 
 
 Input & Output
 
 The interaction process have two phases. At first phase you perform sequence of weighings on the mechanical scales. At the second phase you should output the colour of the heavier balls.
 To use the mechanical scales, you should print ""1""(without quotes) and then print two lines, the first line will describe the enumeration of colours of balls on the first pan and second line should that of second pan.
 To describe some pan, you need to print one integer n - the number of balls you put in this pan, followed by n space-separated integers - colours of the balls you put in this pan. 
 Once you have printed required data, you can read from the standard input one integer - the difference of weights of the first and the second pans.
 To output the colour of the heavier balls, you should print ""2""(without quotes) and one integer in next line - colour of the heavier balls. 
 
 Constraints
 
 Each colour you print should be between 1 and 5.
 In each weighings, you can use at most two balls of same colour.
 Note that you can use scales as much times as you want (even zero).
 Once your program printed the colour of the heavier balls, it should finish its work, i.e. you should exit the program. 
 Do not forget to flush standard output after each line you print.
 
 Subtasks
 
 If you output incorrect colour (i.e. colour you printed is not that of heavier balls), your score will be zero.
 Let K will be the number of times you used scales.
 Then your score will be 100/K points.
 Please note that if K equals to zero, your score also will also be 100 points.
 
 Example 1
 
 Please note that the content in left side denotes output of your program where content in the right side denotes the response of judge which you should read as input. 
 
 Input and Output
 1
 1 1
 1 1 
 0
 1
 1 1
 1 5
 -1
 2
 5
 
 Example 2
 Input and Output
 1
 3 1 2 5
 0
 4
 1
 0
 1 2
 -1
 1
 0
 1 5
 -2
 2
 5
 
 Explanation
 In the first example, you first printed :
 
 1
 1 1
 1 1
 
 
 
 This means that you want to use the scale. Each of the first and second pan has one ball of colour 1.
 Don't forget to flush the standard output after printing this.
 
 
 After that you should read the input, the difference of weights between the two pans, in this case, it will be 0. 
 
 
 Now you printed : 
 
 1
 1 1
 1 5
 
 
 
 It means, that you decided to use scale again. Now first pan contains one ball of colour 1 and the second pan contains one ball of colour 5.
 
 
 Now, you should read the input, the difference of weights between the two pans, in this case, it will be -1.
 
 
 Now, you realize that ball of colour 5 is heavier than of colour 1. It means that 5th colour is the colour of heaviest ball. So your print 2 followed by 5 in separate lines and exit your program.
 
 
 You have used scale total 2 times. Hence your score will be 100/2 = 50.
 
 In the second example, your score will be 100 / 3 = 33.3333333
 Notes
 
 Please note that clearing the output buffer can be done by using fflush(stdout) command or by setting the proper type of buffering at the beginning of the execution - setlinebuf(stdout). Failure to flush the output buffer will result in Time Limit Exceeded verdict.
 
 
 There are 5 test files. For each of the test file, score you will get is described above. The total sum of scores of your program for all the test files will be displayed on the contest page. This will be considered your final score for the problem. 
 
 
 Total points awarded for this problem will be equal to (your score) / (best score achieved in the contest) * 100.",CHBLLS,S10138937,PYTH,"function findHeavierBalls(colors):
  # Compare the weights of two balls of the same color
  for color in colors:
    print ""1""
    print ""1"", color
    print ""1"", color
    difference = read input
    if difference != 0:
      heavier_color = color
      break
  # Compare the weights of two balls of different colors
  for color1 in colors:
    for color2 in colors:
      if color1 == color2:
        continue
      print ""1""
      print ""1"", color1
      print ""1"", color2
      difference = read input
      if difference != 0:
        # Determine which of these balls is heavier
        print ""1""
        print ""1"", color1
        print ""1"", color1
        difference1 = read input
        print ""1""
        print ""1"", color2
        print ""1"", color2
        difference2 = read input
        if difference1 > 0:
          heavier_color = color1
        else:
          heavier_color = color2
        break
  print ""2""
  print heavier_color
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 Chef has a standard chocolate of n by m pieces. More formally, chocolate is a rectangular plate consisting of n rows and m columns. 
 Here you can see an example of a standard 5 by 7 chocolate. 
 
 
 
 He has two friends and they will play with this chocolate. First friend takes the chocolate and cuts it into two parts by making either a horizontal or vertical cut. Then, the second friend takes one of the available pieces and divides into two parts by either making a horizontal or vertical cut. Then the turn of first friend comes and he can pick any block of the available chocolates and do the same thing again. The player who cannot make a turn loses. 
 Now Chef is interested in finding which of his friends will win if both of them play optimally. Output ""Yes"", if the friend who plays first will win, otherwise print ""No"".
 Input
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
 The only line of each test case contains two space separated integers n and m - the sizes of the chocolate.
 Output
 For each test case, output a single line containing one word ""Yes"" (without quotes) if there is a sequence of moves leading to the winning of the person who moves first and ""No"" (without quotes) otherwise.
 Constraints
 
 1 ≤ T ≤ 100
 1 ≤ n, m ≤ 109
 
 Subtasks
 Subtask #1 (10 points):
 
 1 ≤ n, m ≤ 10
 
 Subtask #2 (30 points):
 
 n = 1 or m = 1
 
 Subtask #3 (60 points): No additional constraints
 
 Example
 Input:
 2
 1 2
 1 3
 
 Output:
 Yes
 No
 
 Explanation
 Example case 1. There is only one possible move, so the second player even won't have a chance to make move.
 Example case 2. There are only two ways first player can make first move, after each of them only one move left, so the first player cannot win.",CHCHCL,S11183694,PYTH,"# Read T, N, and H
T, N, H = map(int, input().split())

# Iterate T times
for _ in range(T):
  # Print 1 to use the scales
  print(""1"")

  # Compare the weights of two balls of color 1 against two balls of color 2
  print(""2 1 2"")
  print(""2 1 2"")
  difference = int(input())
  
  # If the difference in weight is not zero, then we know that the heavier balls are either color 1 or color 2
  if difference != 0:
    print(""2"")
    print(1 if difference > 0 else 2)
    break

  # Compare the weights of two balls of color 3 against two balls of color 4
  print(""2 3 4"")
  print(""2 3 4"")
  difference = int(input())
  
  # If the difference in weight is not zero, then we know that the heavier balls are either color 3 or color 4
  if difference != 0:
    print(""2"")
    print(3 if difference > 0 else 4)
    break
    
  # If the difference in weight is still zero after comparing the weights of the balls of color 3 and 4,
  # then we know that the heavier balls must be color 5
  print(""2"")
  print(5)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 
 Probably everyone has experienced an awkward situation due to shared armrests between seats in cinemas. A highly accomplished cinema manager named ""Chef"" decided to solve this problem.
 
 
 When a customer wants to buy a ticket, the clerk at the ticket window asks the visitor if they need the armrests, and if so, which of them: left, right, or both. We know that out of the audience expected to show up, L of them only need the left armrest, R of them need just the right one, Z need none and B need both. Your task is to calculate the maximum number of people that can attend the show. In the cinema hall there are N rows with M seats each. There is only one armrest between two adjacent seats. Seats at the beginning and at the end of the row have two armrests
 Input
 
 Input begins with an integer T: the number of test cases.
 Each test case consists of a single line with 6 space-separated integers: N, M, Z, L, R, B.
 
 Output
 
 For each test case, output a line containing the answer for the task.
 
 Constraints and Subtasks
 
 1 ≤ T ≤ 105 
 
 Subtask 1 : 10 points 
 1 ≤ N, M ≤ 3 
 0 ≤ Z, L, R, B ≤ 3 
 
 Subtask 2 : 20 points 
 1 ≤ N, M ≤ 30 
 0 ≤ Z, L, R ≤ 30 
 0 ≤ B ≤ 109 
 
 Subtask 3 : 30 points
 1 ≤ N, M ≤ 106 
 0 ≤ Z, L, R ≤ 106 
 0 ≤ B ≤ 1016 
 
 Subtask 4 : 40 points
 1 ≤ N, M ≤ 108 
 0 ≤ Z, L, R, B ≤ 1016 
 
 Example
 Input:
 2
 2 2 3 2 1 1
 3 3 1 2 0 9
 
 Output:
 4
 8
 
 Explanation
 'L' - needs left
 'R - needs right
 'Z' - doesn't need any
 'B' - needs both
 '-' - empty place
 
 Example case 1.
 ZZ
 ZB
 Example case 2.
 LLB
 BZB
 B-B",CHCINEMA,S12054517,PYTH,"T = int(input()) # number of test cases

for _ in range(T):
  N, M, Z, L, R, B = map(int, input().split())

  # Calculate the number of people that can attend the show
  people = 0

  # First, we will try to fill the rows with B people, as they need both armrests
  people += B

  # Then, we will try to fill the rows with L and R people, as they only need one armrest
  # We need to make sure that there are enough seats available for them
  available_seats = N * M - people
  if available_seats >= L + R:
    people += L + R
  else:
    people += available_seats

  # Finally, we will try to fill the remaining seats with Z people, as they don't need any armrest
  available_seats = N * M - people
  people += min(available_seats, Z)

  # Print the result
  print(people)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 Chef is playing a game with his friend Misha. They have a pile containg N coins. Players take alternate turns, removing some coins from the pile. On each turn, a player can remove either one coin or coins equal to some prime power (i.e. px coins, where p - prime number and x - positive integer). Game ends when the pile becomes empty. The player who can not make a move in his turn loses.
 
 Chef plays first. Your task is to find out who will win the game, provided that both of the player play optimally.
 Input
 
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
 The only line of each test case contains one integer N.
 
 Output
 
 For each test case, output a single line containing one word - the name of the winner of the game. Print ""Chef"" (without quotes) if Chef wins the game, print ""Misha"" (without quotes) otherwise. 
 
 Constraints
 
 1 ≤ T ≤ 1000
 1 ≤ N ≤ 109
 
 Subtasks
 Subtask #1 (20 points): 
 
 1 ≤ N ≤ 10
 
 Subtask #2 (30 points): 
 
 1 ≤ N ≤ 104
 
 Subtask #3 (50 points): No additional constraints.
 Example
 Input:
 2
 1
 8
 
 Output:
 Chef
 Chef
 Explanation
 Example case 1. Chef will remove the only coin from the pile and will win the game.
 Example case 2. Chef will remove all 8 coins from the pile and win the game. Chef can remove 8 coins because 8 is a prime power, as 8 = 23.",CHCOINSG,S10986842,PYTH,"function solve():
  T = read input
  for i = 1 to T:
    N = read input
    if is_prime_power(N):
      print ""Chef""
    else:
      print ""Misha""

function is_prime_power(N):
  for p in prime_numbers:
    x = 0
    while N % p == 0:
      N /= p
      x += 1
    if x > 0:
      return x > 1
  return False
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.Read problems statements in Mandarin Chinese and Russian.
 One day, Chef found a cube which has each of its sides painted in some color out of black, blue, red, green, yellow and orange.
 Now he asks you to check if he can choose three sides such that they are pairwise adjacent and painted in the same color.
 Input
 
 The first line of the input contains an integer T denoting the number of test cases.
 A single line of each test case contains six words denoting the colors of painted sides in the order: front, back, left, right, top and bottom, respectively.
 
 Output
 For each test case, output a single line containing the word ""YES"" or ""NO"" (without quotes) corresponding to the answer of the problem.
 Constraints
 
 1 ≤ T ≤ 50000 
 Each color will be from the list {""black"", ""blue"", ""red"", ""green"", ""yellow"", ""orange""}
 
 Subtasks
 Subtask 1: (25 points)
 
 1 ≤ T ≤ 12000 
 For each test case there will be at most three different colors
 
 
 Subtask 2: (75 points)
 
 Original constraints
 
 
 Example
 Input:
 2
 blue yellow green orange black green
 green yellow green orange black green
  
 Output:
 NO
 YES
 
 Explanation
 
 Example case 1.
 There are no three sides with the same color.
 
 Example case 2.
 In this test case, the front, bottom and left sides are green (see picture).",CHCUBE,S10823925,PYTH,"# Read the number of test cases
t = int(input())

# Process each test case
for _ in range(t):
  # Read the colors of the six sides
  colors = input().split()
  
  # Check if there are three consecutive elements with the same color
  for i in range(4):
    if colors[i] == colors[i+1] and colors[i+1] == colors[i+2]:
      print(""YES"")
      break
  else:
    print(""NO"")
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 
 Chef and Roma are playing a game. Rules of the game are quite simple.
 Initially there are N piles of stones on the table.
 In each turn, a player can choose one pile and remove it from the table.
 Each player want to maximize the total number of stones removed by him.
 Chef takes the first turn.
 
 
 Please tell Chef the maximum number of stones he can remove assuming that both players play optimally.
 Input
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
 The first line of each test case contains a single integer N denoting the number of piles.
 The second line contains N space separated integers A1, A2, ..., AN denoting the number of stones in each pile.
 Output
 For each test case, output a single line containg the maximum number of stones that Chef can remove.
 Constraints
 
 1 ≤ Ai ≤ 109
 Subtask 1 (35 points): T = 10, 1 ≤ N ≤ 1000
 Subtask 2 (65 points): T = 10, 1 ≤ N ≤ 105 
 
 Example
 
 Input:
 2
 3
 1 2 3
 3
 1 2 1
 
 Output:
 4
 3",CHEFA,S10529849,PYTH,"for each test case:
  sort the piles in decreasing order of the number of stones
  total_stones = 0
  while there are still piles:
    remove the first pile and add the number of stones to total_stones
  print total_stones
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 Chef has an array A consisting of N integers. He also has an intger K.
 Chef wants you to find out number of different arrays he can obtain from array A by applying the following operation exactly K times.
 
 Pick some element in the array and multiply it by -1
 
 
 As answer could be quite large, print it modulo 109 + 7.
 
 Input
 
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
 The first line of each test case contains two space separated integers N, K as defined above.
 The second line contains N space-separated integers A1, A2, ..., AN denoting the elements of the array.
 
 Output
 
 For each test case, output a single line containing an integer corresponding to the number of different arrays Chef can get modulo 109 + 7.
 
 Constraints
 
 1 ≤ T ≤ 10
 1 ≤ N, K ≤ 105
 -106 ≤ Ai ≤ 106
 
 Subtasks
 
 Subtask #1 (10 points) : N, K ≤ 10
 Subtask #2 (30 points) : N, K ≤ 100
 Subtask #3 (60 points) : N, K ≤ 105
 
 Example
 Input:
 3
 1 3
 100
 3 1
 1 2 1
 3 2
 1 2 1
 
 Output:
 1
 3
 4
 Explanation
 Example case 1.
 Chef has only one element and must apply the operation 3 times to it. After applying the operations, he will end up with -100. That is the only array he will get.
 
 Example case 2.
 Chef can apply operation to one of three elements. So, he can obtain three different arrays.
 
 Example case 3.
 Note that other than applying operation to positions (1, 2), (1, 3), (2, 3), Chef can also apply the operation twice on some element and get the original.
 
 In summary, Chef can get following four arrays.
 
 [1, 2, 1]
 [-1, -2, 1]
 [-1, 2, -1]
 [1, -2, -1]",CHEFARK,S10531885,PYTH,"MOD = 10**9 + 7

def solve(n, k, a):
  # Count the number of positive, negative, and zero elements in the array
  pos = neg = zero = 0
  for x in a:
    if x > 0:
      pos += 1
    elif x < 0:
      neg += 1
    else:
      zero += 1

  # If K is even, we can always obtain the original array
  if k % 2 == 0:
    return 1

  # If there are zero elements, we can obtain only one array
  if zero > 0:
    return 1

  # If there are an odd number of negative elements, we can obtain two arrays
  if neg % 2 == 1:
    return 2
  
  # Otherwise, we can obtain only one array
  return 1

# Read the input and call the solve function for each test case
t = int(input())
for _ in range(t):
  n, k = map(int, input().split())
  a = list(map(int, input().split()))
  print(solve(n, k, a) % MOD)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 
 Chef likes problems involving arrays. Unfortunately, the last one he tried to solve didn't quite get solved.
 
 
 Chef has an array A of N positive numbers. He wants to find the number of subarrays for which the sum and product of elements are equal.
 
 
 Please help Chef find this number.
 
 Input
 The first line of input contains an integer T denoting the number of test cases. T test cases follow. The first line of each test contains the integer N. The next line contains N integers — A1, A2, ..., AN — denoting the array.
 Output
 For each test case, output a single line with the answer for the instance.
 Constraints
 
 1 ≤ T ≤ 50
 1 ≤ n ≤ 50
 1 ≤ Ai ≤ 109
 A1 * A2 * ... * An ≤ 109 
 
 Example
 
 Input:
 3
 3
 1 3 2
 4
 4 1 2 1
 6
 1 2 2 2 2 1
 
 Output:
 4
 5
 9
 Explanation:
 
 Example case 1. There are 4 such subarrays: A[1..1], A[2..2], A[3..3], A[1..3]. Consider A[1..3], sum = 1 + 3 + 2 = 6, product = 1 * 3 * 2 = 6.",CHEFARRP,S10130908,PYTH,"def count_subarrays(n, a):
  # Initialize the result to 0
  result = 0
  
  # Loop through the array and consider each element as the starting point of a subarray
  for i in range(n):
    # Initialize the sum and product for the current subarray to the value of the element at the starting point
    curr_sum = a[i]
    curr_prod = a[i]
    # Loop through the rest of the array, starting from the next element after the starting point of the current subarray
    for j in range(i+1, n):
      # Update the sum and product by adding the value of the current element
      curr_sum += a[j]
      curr_prod *= a[j]
      # If the sum and product are equal, increment the result
      if curr_sum == curr_prod:
        result += 1
  # Return the result
  return result

# Test the function with the example from the prompt
print(count_subarrays(3, [1, 3, 2]))  # Expected output: 4
print(count_subarrays(4, [4, 1, 2, 1]))  # Expected output: 5
print(count_subarrays(6, [1, 2, 2, 2, 2, 1]))  # Expected output: 9
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 
 Roma gave Chef an array of intergers.
 Chef wants to make all integers in the array equal to 1.
 In a single operation, he can select a prime number p and a subset of the integers, and then divide all of the integers in the subset by p.
 Chef can make this operation only if every integer in the selected subset is divisible by p.
 
 
 Please help Chef to make all the integers in the array equal to 1 with minimum number of operations.
 Input
 The first line of input contains a single integer T denoting the number of test cases. The description of T test cases follows.
 The first line of each test case contains a single integer N denoting the length of the array that Roma gave Chef.
 The second line contains N space-separated integers A1, A2, ..., AN denoting the integers in the array.
 Output
 For each test case, output a single line containing one integer - the minimum number of operations needed to make all numbers equal to 1.
 Constraints
 
 Subtask 1 (10 points): T = 5, 1 ≤ N ≤ 105, 1 ≤ Ai ≤ 3
 Subtask 2 (40 points): T = 3, 1 ≤ N ≤ 10, 1 ≤ Ai ≤ 106
 Subtask 3 (50 points): T = 3, 1 ≤ N ≤ 105, 1 ≤ Ai ≤ 106
 
 Example
 Input:
 1
 3
 1 2 4
 
 Output:
 2",CHEFB,S4921194,PYTH,"def is_prime(n):
  # Return True if n is a prime number, and False otherwise
  if n <= 1:
    return False
  for i in range(2, int(n ** 0.5) + 1):
    if n % i == 0:
      return False
  return True

def solve(n, a):
  # Return the minimum number of operations needed to make all numbers in the array a equal to 1
  # Initialize the number of operations to 0
  operations = 0
  # Iterate over the elements of the array
  for x in a:
    # Divide x by all the prime divisors until it becomes 1
    while x != 1:
      for p in range(2, x+1):
        if is_prime(p) and x % p == 0:
          x /= p
          operations += 1
  return operations

# Read the input
T = int(input())
for _ in range(T):
  n = int(input())
  a = list(map(int, input().split()))
  # Print the solution for this test case
  print(solve(n, a))
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 Spring is interesting season of year. Chef is thinking about different things, but last time he thinks about interesting game - ""Strange Matrix"". 
 Chef has a matrix that consists of n rows, each contains m elements. Initially, the element aij of matrix equals j. (1 ≤ i ≤ n, 1 ≤ j ≤ m). 
 Then p times some element aij is increased by 1. 
 Then Chef needs to calculate the following: 
 
 For each row he tries to move from the last element (with number m) to the first one (with the number 1). 
 While staying in aij Chef can only move to aij - 1 only if aij - 1 ≤ aij. 
 The cost of such a movement is aij - aij - 1.
 Otherwise Chef can't move and lose (in this row).
 If Chef can move from the last element of the row to the first one, then the answer is the total cost of all the movements. 
 If Chef can't move from the last element of the row to the first one, then the answer is -1. 
 
  Help Chef to find answers for all the rows after P commands of increasing. 
 Input
 
 
 The first line contains three integers n, m and p denoting the number of rows, the number of elements a single row and the number of increasing commands. 
 Each of next p lines contains two integers i and j denoting that the element aij is increased by one. 
 
 
 Output
 
 For each row in a single line print the answer after the P increasing commands.
 
 
 Constraints
 
 1 ≤ n, m, p ≤ 10 ^ 5
 1 ≤ i ≤ n
 1 ≤ j ≤ m
 
 
 Example
 Input:
 4 4 6
 2 2
 3 2 
 3 2 
 4 3
 4 4
 4 3
 
 Output:
 3
 3
 -1
 4
 
 
 Explanation
 
 Here is the whole matrix after P commands:
 1 2 3 4
 1 3 3 4
 1 4 3 4
 1 2 5 5
  Explanations to the answer: 
 
 The first line is without changes: 4-3=1, 3-2=1, 2-1=1. answer = 3. 
 The second line: 4-3=1, 3-3=0, 3-1=2. The answer is 3. 
 The third line: 4-3=1, 3-4=-1, Chef can't move to the first number here. Therefore, the answer is -1. 
 The fourth line: 5-5=0, 5-2=3, 2-1=1. The answer is 4.",CHEFBM,S3906296,PYTH,"# Read input
n, m, p = map(int, input().split())

# Initialize matrix
matrix = [[j for j in range(1, m+1)] for i in range(n)]

# Process increasing commands
for _ in range(p):
  i, j = map(int, input().split())
  matrix[i-1][j-1] += 1

# Calculate answers for each row
for row in matrix:
  cost = 0
  for i in range(m-1, 0, -1):
    if row[i-1] > row[i]:
      print(-1)
      break
    cost += row[i] - row[i-1]
  else:
    print(cost)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available.Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 Chef recently learned about ratios and proportions. He wrote some positive integers a, b, c, d on a paper. Chef wants to know whether he can shuffle these numbers so as to make some proportion? Formally, four numbers x, y, z, w are said to make a proportion if ratio of x : y is same as that of z : w.
 Input
 Only line of the input contains four space separated positive integers - a, b, c, d.
 Output
 Print ""Possible"" if it is possible to shuffle a, b, c, d to make proportion, otherwise ""Impossible"" (without quotes).
 Constraints
 
 1 ≤ a, b, c, d ≤ 1000
 
 Example
 Input:
 1 2 4 2
 
 Output:
 Possible
 
 Explanation
 By swapping 4 and the second 2, we get 1 2 2 4. Note that 1 2 2 4 make proportion as 1 : 2 = 2 : 4. Hence answer is ""Possible""",CHEFCBA,S10900529,PYTH,"def solve(a, b, c, d):
  # Check if a : b = c : d
  if a * d == b * c:
    return ""Possible""
  # Check if a : c = b : d
  elif a * d == b * c:
    return ""Possible""
  # Check if a : d = b : c
  elif a * c == b * d:
    return ""Possible""
  else:
    return ""Impossible""

# Read the input
a, b, c, d = map(int, input().split())

# Print the solution
print(solve(a, b, c, d))
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 Chef had a hard day and want to play little bit. The game is called ""Chain"". Chef has the sequence of symbols. Each symbol is either '-' or '+'. The sequence is called Chain if each two neighboring symbols of sequence are either '-+' or '+-'. 
  For example sequence '-+-+-+' is a Chain but sequence '-+-+--+' is not. 
  Help Chef to calculate the minimum number of symbols he need to replace (ex. '-' to '+' or '+' to '-') to receive a Chain sequence. 
 Input
 
 First line contains single integer T denoting the number of test cases. 
 Line of each test case contains the string S consisting of symbols '-' and '+'. 
 
 Output
 
 For each test case, in a single line print single interger - the minimal number of symbols Chef needs to replace to receive a Chain. 
 
 Constraints
 
 1 ≤ T ≤ 7
 1 ≤ |S| ≤ 10^5
 
 Subtasks
 
 Subtask 1 ≤ |S| ≤ 10, 1 ≤ T ≤ 7 Points: 20 
 Subtask 1 ≤ |S| ≤ 1000, 1 ≤ T ≤ 7 Points: 30 
 Subtask 1 ≤ |S| ≤ 10^5, 1 ≤ T ≤ 7Points: 50 
 
 Example
 Input:
 2
 ---+-+-+++
 -------
 Output:
 2
 3
 Explanation
 Example case 1.
 We can change symbol 2 from '-' to '+' and symbol 9 from '+' to '-' and receive '-+-+-+-+-+'. 
 Example case 2.
 We can change symbols 2, 4 and 6 from '-' to '+' and receive '-+-+-+-'.",CHEFCH,S10231788,PYTH,"# Read the number of test cases
t = int(input())

# Iterate through each test case
for _ in range(t):
    # Read the string
    s = input()
    
    # Initialize the counter to 0
    counter = 0
    
    # Iterate through the string
    for i in range(1, len(s)):
        # Check if the current character is different from the previous one
        if s[i] != s[i-1]:
            # Increment the counter
            counter += 1
    
    # Print the result
    print(counter)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 
 
 Will Hunting was learning about Greatest Common Divisor (gcd) of two numbers and properties related to it. He came across the concept of a closed set. He learned that a set is said to be closed under some operation iff for any two elements in the set, the result obtained after applying the operation on those two elements is also a part of the set.
 
 
 Professor Lambeau wants to test Will on this newly learned topic. He comes up with the following challenge for Will. Consider an array A of length N. The array may or may not be closed under some operation. He wants to add exactly K elements in the array in the range [1, L] such that the resulting array is closed under the gcd operation. Note that the order in which the elements are going to be added does not matter. Also, an array B will be called closed under gcd operation, if for any two indices i, j, the element gcd(Bi, Bj) is also present in the array.
 
 
 Will has started thinking about this problem. Can you beat him to the task and compute the number 
 of ways before he does? Note that the answer could be large, so you must report it modulo 109 + 7.
 
 Input
 
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
 
 
 For each test case, first line consists three space separated integers denoting N, K, L.
 
 
 Second line of each test case, contains N space separated integers denoting array A.
 
 Output
 
 For each test case, output a single line containing an integer corresponding to the number of ways of adding elements in the range [1, L] to make the array closed under gcd operation.
 
 Constraints
 
 1 ≤ T ≤ 10
 1 ≤ N, Ai, K, L ≤ 27
 There exists an i such that Ai = 1
 Maximum value in the array A ≤ L
 
 Subtasks
 Subtask #1 (40 points), Time limit : 4 secs
 
 1 ≤ N, Ai, K, L ≤ 15
 
 Subtask #2 (40 points), Time limit : 4 secs
 
 1 ≤ N, Ai, K, L ≤ 25
 
 Subtask #3 (20 points), Time limit : 2 secs
 
 1 ≤ N, Ai, K, L ≤ 27
 
 Example
 Input:
 2
 2 1 2
 2 1
 3 1 6
 1 4 6
 
 Output:
 2
 1
 
 Explanation
 In Test 1 : The array A = [2, 1]. The array is already closed under gcd operation since gcd(2, 2) = 2, gcd(1, 1) = 1 and gcd(2, 1) = 2. So, the remaining element which needs to be added can be either 1 or 2. So, answer is 2.
 In Test 2 : The array A = [1, 4, 6]. gcd(1, 1), gcd(1, 4) and gcd(1, 6) = 1 which is present in the array. gcd(4, 6) is 2 which is not present in the array. We have to add only one element in the array and make it closed under gcd operation. So the number to be added can only be 2. There is only one way of doing that. So, the answer is 1.",CHEFCLOS,S10974338,PYTH,"def gcd(a, b):
  # Return the greatest common divisor of a and b using the Euclidean algorithm
  if a == 0:
    return b
  return gcd(b % a, a)

def is_closed_set(A):
  # Return True if the set A is closed under the gcd operation, and False otherwise
  for i in range(len(A)):
    for j in range(i+1, len(A)):
      if gcd(A[i], A[j]) not in A:
        return False
  return True

def solve(N, K, L, A):
  # Return the number of ways to add K elements in the range [1, L] to the array A such that the resulting array is closed under the gcd operation
  if is_closed_set(A):
    # The array A is already closed under the gcd operation, so we just need to count the number of ways to add K elements in the range [1, L]
    return pow(L, K, 1000000007)
  else:
    # The array A is not closed under the gcd operation, so we need to add at least one element that makes the array closed
    ways = 0
    # Try adding each element in the range [1, L]
    for i in range(1, L+1):
      if gcd(A[0], i) in A:
        # Adding i makes the array closed, so count the number of ways to add the remaining K-1 elements
        ways += solve(N, K-1, L, A + [i])
        ways %= 1000000007
    return ways

# Read the input
T = int(input())
for _ in range(T):
  N, K, L = map(int, input().split())
  A = list(map(int, input().split()))
  # Print the solution for this test case
  print(solve(N, K, L, A))
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 Chef likes to play with graphs a lot. Today he created a graph in the following way. He first lays down N nodes in a circle. The nodes nodes are numbered from 1 to N, in the clockwise order, i.e. the node 2 is followed by 1, 3 is followed by 2, and 1 is followed by N. Two vertices are said to be adjacent if they don't have an intermediate vertex placed between them. There is an edge between each adjacent pair of vertices, so there are total N such edges. Each edge has an integer associated with it (may be negative). 
 
 Chef wants to find a walk from node start to node end using the above described edges. Chef has to pay cost for each edge in the walk equal to the integer associated with the edge. He wants to minimize the total cost he will incur. Also, Chef does not like to move through an edge more than twice. Find out minimum cost that Chef has to pay.
 Note that a walk from a node u to v can contain repeated vertices in it. Please refer to link for a formal definition.
 Input
 The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.
 The first line of each test case contains a single integer N denoting the number of nodes. 
 The second line contains N space-separated integers R1, R2, ..., RN denoting the integer of the rib from node i to node (i % N) + 1. Note that RN is an integer on a rib from node N to node 1. 
 The third line contains two integers start and end denoting the first and the last node of the walk. 
 Output
 For each test case, output a single line containing the minimal possible cost Chef need to pay.
 Constraints
 
 -106 ≤ Ri ≤ 106
 1 ≤ start < end ≤ N
 
 Subtasks
 
 Subtask #1 (20 points): 1 ≤ sum of N ≤ 20; 1 ≤ N ≤ 8
 Subtask #2 (30 points): 1 ≤ sum of all N ≤ 103; 1 ≤ N ≤ 200
 Subtask #3 (50 points): 1 ≤ sum of all N ≤ 106; 1 ≤ N ≤ 2 × 105 
 
 Example
 
 Input:
 2
 4
 1 2 1 1
 1 3
 5
 -5 100 100 100 2
 1 5
 
 Output:
 2
 -8
 
 Explanation
 Example case 1. Chef's walk starts with node 1. He goes to node 4 by incurring a cost of 1. Then from node 4, he goes to node 3 by incurring a cost of 1 more. Total cost incurred is 2.
 Example case 2. Chef goes from 1 to 2 by incurring a cost of -5. Then from 2 to 1 using the edge second time and incurring cost of -5 again. Now, he can not use the edge between 1 and 2 again, as he has traversed the edge already twice. Now he will go from node 1 to node 4 by paying a cost of 2. Total sum of costs incurred is -5 + -5 + 2 = -8. This is the minimum possible cost that Chef can have.",CHEFCRUN,S11196688,PYTH,"# Get the number of test cases
t = int(input())

# Iterate through the test cases
for _ in range(t):
  # Get the number of nodes
  n = int(input())

  # Get the list of edge costs
  edge_costs = list(map(int, input().split()))

  # Get the start and end nodes
  start, end = map(int, input().split())

  # Initialize the total cost and the number of times we have traversed each edge
  total_cost = 0
  edge_counts = [0] * n

  # Set the current node to the start node
  current_node = start

  # Keep looping until we reach the end node
  while current_node != end:
    # Get the next node
    next_node = (current_node % n) + 1

    # Get the cost of the edge between the current node and the next node
    cost = edge_costs[current_node-1]

    # Increment the count of the number of times we have traversed the edge
    edge_counts[current_node-1] += 1

    # If we have traversed the edge more than twice, skip it
    if edge_counts[current_node-1] > 2:
      current_node = next_node
      continue

    # Add the cost to the total cost
    total_cost += cost

    # Set the current node to the next node
    current_node = next_node

  # Print the total cost
  print(total_cost)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese and Russian.
 Chef has an array containing N integers. You have to make M queries. Each query has one of the two types:
 
 1 l r p - Select all the numbers having indices between l and r (inclusive) that are divisible by p and divide them by p,
  where p is in set {2, 3, 5}.
 2 l d - Modify the l-th number in the array to d.
 
 
 
 Please help Chef in finding out the array after all the M queries.
 
 Input
 The first line of the input contains a single integer N denoting the number of integers in given array. 
 The second line contains N space-separated integers A1, A2, ..., AN denoting the given array.
 Next line contains a single integer M denoting the number of queries.
 Each of the following M lines describes a single query in the format given in the statement.
 Output
  Output a single line containing N integers denoting the array after all the M queries.
 Constraints
 
 1 ≤ M ≤ 105
 1 ≤ l ≤ r ≤ N
 1 ≤ Ai ≤ 109
 In each query of first type, p is in set {2, 3, 5} 
 Subtask 1 (20 points): 1 ≤ N ≤ 100
 Subtask 2 (35 points): 1 ≤ N ≤ 105, there is no query of second type
 Subtask 3 (45 points): 1 ≤ N ≤ 105
 
 Example
 
 Input:
 3
 1 2 3
 5
 1 2 2 2
 1 2 2 2
 2 2 3
 1 2 3 3
 2 1 5
 
 Output:
 5 1 1",CHEFD,S4919293,PYTH,"# Initialize the array with the given values
n = int(input())
arr = list(map(int, input().split()))

# Process the queries
m = int(input())
for i in range(m):
    query = list(map(int, input().split()))
    if query[0] == 1:
        # Divide the numbers in the given range by the given value
        for j in range(query[1] - 1, query[2]):
            if arr[j] % query[3] == 0:
                arr[j] //= query[3]
    else:
        # Modify the value at the given index
        arr[query[1] - 1] = query[2]

# Print the final array
print("" "".join(str(x) for x in arr))
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 Chef is a private detective. He was asked to investigate a case of murder in the city of Frangton.
 Chef arrived in Frangton to find out that the mafia was involved in the case. Chef spent some time watching for people that belong to the clan and was able to build a map of relationships between them. He knows that a mafia's organizational structure consists of a single Don, heading a hierarchical criminal organization. Each member reports exactly to one other member of the clan. It's obvious that there are no cycles in the reporting system of the mafia.
 There are N people in the clan, for simplicity indexed from 1 to N, and Chef knows who each of them report to. Member i reports to member Ri.
 Now, Chef needs to identfy all potential killers to continue his investigation. Having considerable knowledge about the mafia's activities, Chef knows that the killer must be a minor criminal, that is, one of the members who nobody reports to. Please find the list of potential killers for Chef. Since Don reports to nobody, his Ri will be equal to 0.
 Input
 The first line of input contains one integer N.
 Next line has N space-separated integers, the ith integer denotes Ri — the person whom the ith member reports to.
 Output
 Output a list of space-separated integers in ascending order — the indices of potential killers.
 Constraints
 
 1 ≤ N ≤ 105
 1 ≤ Ri ≤ N except for Don, whose Ri equals to 0.
 It is guaranteed that there are no cycles in the reporting structure.
 
 Subtasks
 
 Subtask #1 [50 points]: N ≤ 10000
 Subtask #2 [50 points]: No additional constraints
 
 Example
 Input:
 6
 0 1 1 2 2 3
 
 Output:
 4 5 6
 
 Explanation
 The reporting structure:",CHEFDETE,S11512039,PYTH,"# Read the input
n = int(input())
relationships = list(map(int, input().split()))

# Create a list to store the potential killers
potential_killers = []

# Iterate through the list of relationships
for i, r in enumerate(relationships):
  # If the current member has no reports, add their index to the list
  if r == 0:
    potential_killers.append(i+1)

# Sort the list of potential killers
potential_killers.sort()

# Print the list of potential killers
print("" "".join(str(x) for x in potential_killers))
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese , Russian and Vietnamese as well.
 Chef likes problems with arrays. Let's call an array V dominating if there exists a number x (the dominator) whose number of occurrences is strictly greater than half the size of the array (that is, floor(|V|/2)).
 
 
 For example, the arrays {1, 2, 1} is dominating, with the number 1 being the dominator, since half the size of the array is 1, while the number 1 occurs twice. Similarly, the array {1, 1, 1, 2} is dominating. On the other hand, the arrays {1, 2, 3} and {1, 2, 2, 1} are not dominating.
 
 Given an array A consisting of N positive integers, you need to help Chef find the number of subarrays of A which are dominating.
 Input
 The first line of input contains one integer N denoting the number of elements in the array A. The second line of input contains N space-separated integers denoting the array A.
 Output
 Output the answer to the query in a single line.
 Constraints
 
 1 ≤ N ≤ 5 × 105
 1 ≤ Ai ≤ 109
 
 Example
 Input:
 5
 1 2 1 2 1
 
 Output:
 9
 
 Input:
 7
 1 2 3 3 2 1 3
 
 Output:
 11
 
 Subtasks
 
 Subtask 1: N ≤ 102. Points - 10
 Subtask 2: N ≤ 104. Points - 20
 Subtask 3: N ≤ 105. Points - 30
 Subtask 4: Original constraints. Points - 40
 
 Explanation
 
 Test #1:
 The dominating subarrays are A[1..1], A[2..2], A[3..3], A[4..4], A[5..5], A[6..6], A[1..3], A[2..4], A[3..5].
 Test #2:
 The dominating subarrays are A[1..1], A[2..2], A[3..3], A[4..4], A[5..5], A[6..6], A[7..7], A[3..4], A[2..4], A[3..5], A[3..7].",CHEFDOMA,S9559565,PYTH,"# Read the input
n = int(input())
a = list(map(int, input().split()))

# Initialize the result
result = 0

# For each element in the array
for i in range(n):
  # Initialize the count for this element
  count = 1
  
  # Check how many times this element appears in the array
  for j in range(i+1, n):
    if a[j] == a[i]:
      count += 1
  
  # If the count is greater than half the size of the array,
  # add the number of subarrays starting at this position to the result
  if count > n//2:
    result += (n - i)

# Print the result
print(result)
",,,,,,,,,,,,,,,,,,,,,
"All submissions for this problem are available. Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.
 There are n villages in a Chefland. Some of the villages have electricity facilities, other doesn't. You can consider the villages arranged in line in the order 1 to n from left to right. i-th of village can be considered at xi coordinates.
 
 Chef decided that electricity should be provided to all the villages. So, he decides to buy some amount of electric wires to connect the villeges without electricity to some villages with electricity. As Chef does not want to spend too much amount of money on wires, can you find out minimum amount of length of wire Chef should buy.
 
 Input
 First line of the input contains an integer T denoting the number of test cases. T test cases follow.
 First line of each test case contains an integer n denoting number of villages in Chefland.
 Second line will contain a string of length n containing '0' or '1's only. If i-th character of the string is '1', then it denotes that i-th village has electricity.
 Next line contains n space separated integers denoting the x coordinates of the villages in the order from village 1 to n
 Output
 For each test case, output a single line containing a integer corresponding to the minimum length of wire Chef needs to buy.
 Constraints
 
 1 ≤ T ≤ 10
 It is guaranteed that there will be at least one village which will have electricity.
 1 ≤ x1 < x2 < ... < xn ≤ 109
 
 Subtasks
 
 Subtask #1 : 30 points
 
 1 ≤ N ≤ 1000
 
 
 Subtask #2 : 70 points
 
 1 ≤ N ≤ 105
 
 Example
 Input
 2
 2
 01
 1 2
 3
 100
 1 5 6
 Output:
 1
 5
 Explanation
 In the first example, first village does not have electricity. If we put a wire between village 1 and 2 of length 1, then both the villages will have electricity.
 
 In the second example,
 We can a draw a wire from first village to third village, passing through second village. Its total length will be 5. Now all the villages will have electricity. This is the minimum length of wire you will require.",CHEFELEC,S10815855,PYTH,"def find_min_distance(n, electricity, coordinates):
  # Initialize minimum distance to be the maximum possible value
  min_distance = float(""inf"")
  
  # Initialize the last village with electricity to be -1
  last_electricity = -1
  
  # Loop through the villages
  for i in range(n):
    # If the current village has electricity
    if electricity[i] == '1':
      # Update the last village with electricity
      last_electricity = coordinates[i]
    # If the current village does not have electricity
    else:
      # Calculate the distance between the current village and the last village with electricity
      distance = coordinates[i] - last_electricity
      # Update the minimum distance if necessary
      min_distance = min(min_distance, distance)
      
  # Return the minimum distance
  return min_distance

# Read the number of test cases
t = int(input())

# Loop through the test cases
for _ in range(t):
  # Read the number of villages and the electricity array
  n = int(input())
  electricity = input()
  
  # Read the coordinates of the villages
  coordinates = list(map(int, input().split()))
  
  # Find the minimum distance
  min_distance = find_min_distance(n, electricity, coordinates)
  
  # Print the minimum distance
  print(min_distance)
",,,,,,,,,,,,,,,,,,,,,
